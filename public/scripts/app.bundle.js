/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-dom.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */function _typeof(obj){\"@babel/helpers - typeof\";return _typeof=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(obj){return typeof obj;}:function(obj){return obj&&\"function\"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj;},_typeof(obj);}if(true){(function(){'use strict';/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());}var React=__webpack_require__(/*! react */ \"./node_modules/react/index.js\");var Scheduler=__webpack_require__(/*! scheduler */ \"./node_modules/scheduler/index.js\");var ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var suppressWarning=false;function setSuppressWarning(newSuppressWarning){{suppressWarning=newSuppressWarning;}}// In DEV, calls to console.warn and console.error get replaced\n// by calls to these methods by a Babel plugin.\n//\n// In PROD (or in packages without access to React internals),\n// they are left as they are instead.\nfunction warn(format){{if(!suppressWarning){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}printWarning('warn',format,args);}}}function error(format){{if(!suppressWarning){for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2];}printWarning('error',format,args);}}}function printWarning(level,format,args){// When changing this logic, you might want to also\n// update consoleWithStackDev.www.js as well.\n{var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var stack=ReactDebugCurrentFrame.getStackAddendum();if(stack!==''){format+='%s';args=args.concat([stack]);}// eslint-disable-next-line react-internal/safe-string-coercion\nvar argsWithFormat=args.map(function(item){return String(item);});// Careful: RN currently depends on this prefix\nargsWithFormat.unshift('Warning: '+format);// We intentionally don't use spread (or .apply) directly because it\n// breaks IE9: https://github.com/facebook/react/issues/13610\n// eslint-disable-next-line react-internal/no-production-logging\nFunction.prototype.apply.call(console[level],console,argsWithFormat);}}var FunctionComponent=0;var ClassComponent=1;var IndeterminateComponent=2;// Before we know whether it is function or class\nvar HostRoot=3;// Root of a host tree. Could be nested inside another node.\nvar HostPortal=4;// A subtree. Could be an entry point to a different renderer.\nvar HostComponent=5;var HostText=6;var Fragment=7;var Mode=8;var ContextConsumer=9;var ContextProvider=10;var ForwardRef=11;var Profiler=12;var SuspenseComponent=13;var MemoComponent=14;var SimpleMemoComponent=15;var LazyComponent=16;var IncompleteClassComponent=17;var DehydratedFragment=18;var SuspenseListComponent=19;var ScopeComponent=21;var OffscreenComponent=22;var LegacyHiddenComponent=23;var CacheComponent=24;var TracingMarkerComponent=25;// -----------------------------------------------------------------------------\nvar enableClientRenderFallbackOnTextMismatch=true;// Recoil still uses useMutableSource in www, need to delete\n// the react-reconciler package.\nvar enableNewReconciler=false;// Support legacy Primer support on internal FB www\nvar enableLazyContextPropagation=false;// FB-only usage. The new API has different semantics.\nvar enableLegacyHidden=false;// Enables unstable_avoidThisFallback feature in Fiber\nvar enableSuspenseAvoidThisFallback=false;// Enables unstable_avoidThisFallback feature in Fizz\n// React DOM Chopping Block\n//\n// Similar to main Chopping Block but only flags related to React DOM. These are\n// grouped because we will likely batch all of them into a single major release.\n// -----------------------------------------------------------------------------\n// Disable support for comment nodes as React DOM containers. Already disabled\n// in open source, but www codebase still relies on it. Need to remove.\nvar disableCommentsAsDOMContainers=true;// Disable javascript: URL strings in href for XSS protection.\n// and client rendering, mostly to allow JSX attributes to apply to the custom\n// element's object properties instead of only HTML attributes.\n// https://github.com/facebook/react/issues/11347\nvar enableCustomElementPropertySupport=false;// Disables children for <textarea> elements\nvar warnAboutStringRefs=false;// -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\nvar enableSchedulingProfiler=true;// Helps identify side effects in render-phase lifecycle hooks and setState\nvar enableProfilerTimer=true;// Record durations for commit and passive effects phases.\nvar enableProfilerCommitHooks=true;// Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\nvar allNativeEvents=new Set();/**\n * Mapping from registration name to event name\n */var registrationNameDependencies={};/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true\nfunction registerTwoPhaseEvent(registrationName,dependencies){registerDirectEvent(registrationName,dependencies);registerDirectEvent(registrationName+'Capture',dependencies);}function registerDirectEvent(registrationName,dependencies){{if(registrationNameDependencies[registrationName]){error('EventRegistry: More than one plugin attempted to publish the same '+'registration name, `%s`.',registrationName);}}registrationNameDependencies[registrationName]=dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}for(var i=0;i<dependencies.length;i++){allNativeEvents.add(dependencies[i]);}}var canUseDOM=!!(typeof window!=='undefined'&&typeof window.document!=='undefined'&&typeof window.document.createElement!=='undefined');var hasOwnProperty=Object.prototype.hasOwnProperty;/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value){{// toStringTag is needed for namespaced types like Temporal.Instant\nvar hasToStringTag=typeof Symbol==='function'&&Symbol.toStringTag;var type=hasToStringTag&&value[Symbol.toStringTag]||value.constructor.name||'Object';return type;}}// $FlowFixMe only called in DEV, so void return is not possible.\nfunction willCoercionThrow(value){{try{testStringCoercion(value);return false;}catch(e){return true;}}}function testStringCoercion(value){// If you ended up here by following an exception call stack, here's what's\n// happened: you supplied an object or symbol value to React (as a prop, key,\n// DOM attribute, CSS property, string ref, etc.) and when React tried to\n// coerce it to a string using `'' + value`, an exception was thrown.\n//\n// The most common types that will cause this exception are `Symbol` instances\n// and Temporal objects like `Temporal.Instant`. But any object that has a\n// `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n// exception. (Library authors do this to prevent users from using built-in\n// numeric operators like `+` or comparison operators like `>=` because custom\n// methods are needed to perform accurate arithmetic or comparison.)\n//\n// To fix the problem, coerce this object or symbol value to a string before\n// passing it to React. The most reliable way is usually `String(value)`.\n//\n// To find which value is throwing, check the browser or debugger console.\n// Before this exception was thrown, there should be `console.error` output\n// that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n// problem and how that type was used: key, atrribute, input value prop, etc.\n// In most cases, this console output also shows the component and its\n// ancestor components where the exception happened.\n//\n// eslint-disable-next-line react-internal/safe-string-coercion\nreturn''+value;}function checkAttributeStringCoercion(value,attributeName){{if(willCoercionThrow(value)){error('The provided `%s` attribute is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',attributeName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkKeyStringCoercion(value){{if(willCoercionThrow(value)){error('The provided key is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkPropStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` prop is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkCSSPropertyStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` CSS property is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkHtmlStringCoercion(value){{if(willCoercionThrow(value)){error('The provided HTML markup uses a value of unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}function checkFormFieldValueStringCoercion(value){{if(willCoercionThrow(value)){error('Form field values (value, checked, defaultValue, or defaultChecked props)'+' must be strings, not %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n}}}// A reserved attribute.\n// It is handled by React separately and shouldn't be written to the DOM.\nvar RESERVED=0;// A simple string attribute.\n// Attributes that aren't in the filter are presumed to have this type.\nvar STRING=1;// A string attribute that accepts booleans in React. In HTML, these are called\n// \"enumerated\" attributes with \"true\" and \"false\" as possible values.\n// When true, it should be set to a \"true\" string.\n// When false, it should be set to a \"false\" string.\nvar BOOLEANISH_STRING=2;// A real boolean attribute.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\nvar BOOLEAN=3;// An attribute that can be used as a flag as well as with a value.\n// When true, it should be present (set either to an empty string or its name).\n// When false, it should be omitted.\n// For any other value, should be present with that value.\nvar OVERLOADED_BOOLEAN=4;// An attribute that must be numeric or parse as a numeric.\n// When falsy, it should be removed.\nvar NUMERIC=5;// An attribute that must be positive numeric or parse as a positive numeric.\n// When falsy, it should be removed.\nvar POSITIVE_NUMERIC=6;/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=\":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+\"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(hasOwnProperty.call(validatedAttributeNameCache,attributeName)){return true;}if(hasOwnProperty.call(illegalAttributeNameCache,attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{error('Invalid attribute name: `%s`',attributeName);}return false;}function shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag){if(propertyInfo!==null){return propertyInfo.type===RESERVED;}if(isCustomComponentTag){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return true;}return false;}function shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag){if(propertyInfo!==null&&propertyInfo.type===RESERVED){return false;}switch(_typeof(value)){case'function':// $FlowIssue symbol is perfectly valid here\ncase'symbol':// eslint-disable-line\nreturn true;case'boolean':{if(isCustomComponentTag){return false;}if(propertyInfo!==null){return!propertyInfo.acceptsBooleans;}else{var prefix=name.toLowerCase().slice(0,5);return prefix!=='data-'&&prefix!=='aria-';}}default:return false;}}function shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag){if(value===null||typeof value==='undefined'){return true;}if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag)){return true;}if(isCustomComponentTag){return false;}if(propertyInfo!==null){switch(propertyInfo.type){case BOOLEAN:return!value;case OVERLOADED_BOOLEAN:return value===false;case NUMERIC:return isNaN(value);case POSITIVE_NUMERIC:return isNaN(value)||value<1;}}return false;}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function PropertyInfoRecord(name,type,mustUseProperty,attributeName,attributeNamespace,sanitizeURL,removeEmptyString){this.acceptsBooleans=type===BOOLEANISH_STRING||type===BOOLEAN||type===OVERLOADED_BOOLEAN;this.attributeName=attributeName;this.attributeNamespace=attributeNamespace;this.mustUseProperty=mustUseProperty;this.propertyName=name;this.type=type;this.sanitizeURL=sanitizeURL;this.removeEmptyString=removeEmptyString;}// When adding attributes to this list, be sure to also add them to\n// the `possibleStandardNames` module to ensure casing and incorrect\n// name warnings.\nvar properties={};// These props are reserved by React. They shouldn't be written to the DOM.\nvar reservedProps=['children','dangerouslySetInnerHTML',// TODO: This prevents the assignment of defaultValue to regular\n// elements (not just inputs). Now that ReactDOMInput assigns to the\n// defaultValue property -- do we need this?\n'defaultValue','defaultChecked','innerHTML','suppressContentEditableWarning','suppressHydrationWarning','style'];reservedProps.forEach(function(name){properties[name]=new PropertyInfoRecord(name,RESERVED,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// A few React string attributes have a different name.\n// This is a mapping from React prop names to the attribute names.\n[['acceptCharset','accept-charset'],['className','class'],['htmlFor','for'],['httpEquiv','http-equiv']].forEach(function(_ref){var name=_ref[0],attributeName=_ref[1];properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n['contentEditable','draggable','spellCheck','value'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\n// In React, we let users pass `true` and `false` even though technically\n// these aren't boolean attributes (they are coerced to strings).\n// Since these are SVG attributes, their attribute names are case-sensitive.\n['autoReverse','externalResourcesRequired','focusable','preserveAlpha'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML boolean attributes.\n['allowFullScreen','async',// Note: there is a special case that prevents it from being written to the DOM\n// on the client side because the browsers are inconsistent. Instead we call focus().\n'autoFocus','autoPlay','controls','default','defer','disabled','disablePictureInPicture','disableRemotePlayback','formNoValidate','hidden','loop','noModule','noValidate','open','playsInline','readOnly','required','reversed','scoped','seamless',// Microdata\n'itemScope'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are the few React props that we set as DOM properties\n// rather than attributes. These are all booleans.\n['checked',// Note: `option.selected` is not updated if `select.multiple` is\n// disabled with `removeAttribute`. We have special logic for handling this.\n'multiple','muted','selected'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,true,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that are \"overloaded booleans\": they behave like\n// booleans, but can also accept a string value.\n['capture','download'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,OVERLOADED_BOOLEAN,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that must be positive numbers.\n['cols','rows','size','span'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(name){properties[name]=new PropertyInfoRecord(name,POSITIVE_NUMERIC,false,// mustUseProperty\nname,// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These are HTML attributes that must be numbers.\n['rowSpan','start'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,NUMERIC,false,// mustUseProperty\nname.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});var CAMELIZE=/[\\-\\:]([a-z])/g;var capitalize=function capitalize(token){return token[1].toUpperCase();};// This is a list of all SVG attributes that need special casing, namespacing,\n// or boolean value assignment. Regular attributes that just accept strings\n// and have the same names are omitted, just like in the HTML attribute filter.\n// Some of these attributes can be hard to find. This list was created by\n// scraping the MDN documentation.\n['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','xmlns:xlink','x-height'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,null,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// String SVG attributes with the xlink namespace.\n['xlink:actuate','xlink:arcrole','xlink:role','xlink:show','xlink:title','xlink:type'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,'http://www.w3.org/1999/xlink',false,// sanitizeURL\nfalse);});// String SVG attributes with the xml namespace.\n['xml:base','xml:lang','xml:space'// NOTE: if you add a camelCased prop to this list,\n// you'll need to set attributeName to name.toLowerCase()\n// instead in the assignment below.\n].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\nattributeName,'http://www.w3.org/XML/1998/namespace',false,// sanitizeURL\nfalse);});// These attribute exists both in HTML and SVG.\n// The attribute name is case-sensitive in SVG so we can't just use\n// the React name like we do for attributes that exist only in HTML.\n['tabIndex','crossOrigin'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty\nattributeName.toLowerCase(),// attributeName\nnull,// attributeNamespace\nfalse,// sanitizeURL\nfalse);});// These attributes accept URLs. These must not allow javascript: URLS.\n// These will also need to accept Trusted Types object in the future.\nvar xlinkHref='xlinkHref';properties[xlinkHref]=new PropertyInfoRecord('xlinkHref',STRING,false,// mustUseProperty\n'xlink:href','http://www.w3.org/1999/xlink',true,// sanitizeURL\nfalse);['src','href','action','formAction'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty\nattributeName.toLowerCase(),// attributeName\nnull,// attributeNamespace\ntrue,// sanitizeURL\ntrue);});// and any newline or tab are filtered out as if they're not part of the URL.\n// https://url.spec.whatwg.org/#url-parsing\n// Tab or newline are defined as \\r\\n\\t:\n// https://infra.spec.whatwg.org/#ascii-tab-or-newline\n// A C0 control is a code point in the range \\u0000 NULL to \\u001F\n// INFORMATION SEPARATOR ONE, inclusive:\n// https://infra.spec.whatwg.org/#c0-control-or-space\n/* eslint-disable max-len */var isJavaScriptProtocol=/^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;var didWarn=false;function sanitizeURL(url){{if(!didWarn&&isJavaScriptProtocol.test(url)){didWarn=true;error('A future version of React will block javascript: URLs as a security precaution. '+'Use event handlers instead if you can. If you need to generate unsafe HTML try '+'using dangerouslySetInnerHTML instead. React was passed %s.',JSON.stringify(url));}}}/**\n * Get the value for a property on a node. Only used in DEV for SSR validation.\n * The \"expected\" argument is used as a hint of what the expected value is.\n * Some properties have multiple equivalent values.\n */function getValueForProperty(node,name,expected,propertyInfo){{if(propertyInfo.mustUseProperty){var propertyName=propertyInfo.propertyName;return node[propertyName];}else{// This check protects multiple uses of `expected`, which is why the\n// react-internal/safe-string-coercion rule is disabled in several spots\n// below.\n{checkAttributeStringCoercion(expected,name);}if(propertyInfo.sanitizeURL){// If we haven't fully disabled javascript: URLs, and if\n// the hydration is successful of a javascript: URL, we\n// still want to warn on the client.\n// eslint-disable-next-line react-internal/safe-string-coercion\nsanitizeURL(''+expected);}var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.type===OVERLOADED_BOOLEAN){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return value;}// eslint-disable-next-line react-internal/safe-string-coercion\nif(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldRemoveAttribute(name,expected,propertyInfo,false)){// We had an attribute but shouldn't have had one, so read it\n// for the error message.\nreturn node.getAttribute(attributeName);}if(propertyInfo.type===BOOLEAN){// If this was a boolean, it doesn't matter what the value is\n// the fact that we have it is the same as the expected.\nreturn expected;}// Even if this property uses a namespace we use getAttribute\n// because we assume its namespaced name is the same as our config.\n// To use getAttributeNS we need the local name which we don't have\n// in our config atm.\nstringValue=node.getAttribute(attributeName);}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return stringValue===null?expected:stringValue;// eslint-disable-next-line react-internal/safe-string-coercion\n}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}/**\n * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n * The third argument is used as a hint of what the expected value is. Some\n * attributes have multiple equivalent values.\n */function getValueForAttribute(node,name,expected){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);{checkAttributeStringCoercion(expected,name);}if(value===''+expected){return expected;}return value;}}/**\n * Sets the value for a property on a node.\n *\n * @param {DOMElement} node\n * @param {string} name\n * @param {*} value\n */function setValueForProperty(node,name,value,isCustomComponentTag){var propertyInfo=getPropertyInfo(name);if(shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag)){return;}if(shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag)){value=null;}// If the prop isn't in the special list, treat it as a simple attribute.\nif(isCustomComponentTag||propertyInfo===null){if(isAttributeNameSafe(name)){var _attributeName=name;if(value===null){node.removeAttribute(_attributeName);}else{{checkAttributeStringCoercion(value,name);}node.setAttribute(_attributeName,''+value);}}return;}var mustUseProperty=propertyInfo.mustUseProperty;if(mustUseProperty){var propertyName=propertyInfo.propertyName;if(value===null){var type=propertyInfo.type;node[propertyName]=type===BOOLEAN?false:'';}else{// Contrary to `setAttribute`, object properties are properly\n// `toString`ed by IE8/9.\nnode[propertyName]=value;}return;}// The rest are treated as attributes with special cases.\nvar attributeName=propertyInfo.attributeName,attributeNamespace=propertyInfo.attributeNamespace;if(value===null){node.removeAttribute(attributeName);}else{var _type=propertyInfo.type;var attributeValue;if(_type===BOOLEAN||_type===OVERLOADED_BOOLEAN&&value===true){// If attribute type is boolean, we know for sure it won't be an execution sink\n// and we won't require Trusted Type here.\nattributeValue='';}else{// `setAttribute` with objects becomes only `[object]` in IE8/9,\n// ('' + value) makes it output the correct toString()-value.\n{{checkAttributeStringCoercion(value,attributeName);}attributeValue=''+value;}if(propertyInfo.sanitizeURL){sanitizeURL(attributeValue.toString());}}if(attributeNamespace){node.setAttributeNS(attributeNamespace,attributeName,attributeValue);}else{node.setAttribute(attributeName,attributeValue);}}}// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE=Symbol[\"for\"]('react.element');var REACT_PORTAL_TYPE=Symbol[\"for\"]('react.portal');var REACT_FRAGMENT_TYPE=Symbol[\"for\"]('react.fragment');var REACT_STRICT_MODE_TYPE=Symbol[\"for\"]('react.strict_mode');var REACT_PROFILER_TYPE=Symbol[\"for\"]('react.profiler');var REACT_PROVIDER_TYPE=Symbol[\"for\"]('react.provider');var REACT_CONTEXT_TYPE=Symbol[\"for\"]('react.context');var REACT_FORWARD_REF_TYPE=Symbol[\"for\"]('react.forward_ref');var REACT_SUSPENSE_TYPE=Symbol[\"for\"]('react.suspense');var REACT_SUSPENSE_LIST_TYPE=Symbol[\"for\"]('react.suspense_list');var REACT_MEMO_TYPE=Symbol[\"for\"]('react.memo');var REACT_LAZY_TYPE=Symbol[\"for\"]('react.lazy');var REACT_SCOPE_TYPE=Symbol[\"for\"]('react.scope');var REACT_DEBUG_TRACING_MODE_TYPE=Symbol[\"for\"]('react.debug_trace_mode');var REACT_OFFSCREEN_TYPE=Symbol[\"for\"]('react.offscreen');var REACT_LEGACY_HIDDEN_TYPE=Symbol[\"for\"]('react.legacy_hidden');var REACT_CACHE_TYPE=Symbol[\"for\"]('react.cache');var REACT_TRACING_MARKER_TYPE=Symbol[\"for\"]('react.tracing_marker');var MAYBE_ITERATOR_SYMBOL=Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||_typeof(maybeIterable)!=='object'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}var assign=Object.assign;// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth=0;var prevLog;var prevInfo;var prevWarn;var prevError;var prevGroup;var prevGroupCollapsed;var prevGroupEnd;function disabledLog(){}disabledLog.__reactDisabledLog=true;function disableLogs(){{if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */prevLog=console.log;prevInfo=console.info;prevWarn=console.warn;prevError=console.error;prevGroup=console.group;prevGroupCollapsed=console.groupCollapsed;prevGroupEnd=console.groupEnd;// https://github.com/facebook/react/issues/19099\nvar props={configurable:true,enumerable:true,value:disabledLog,writable:true};// $FlowFixMe Flow thinks console is immutable.\nObject.defineProperties(console,{info:props,log:props,warn:props,error:props,group:props,groupCollapsed:props,groupEnd:props});/* eslint-enable react-internal/no-production-logging */}disabledDepth++;}}function reenableLogs(){{disabledDepth--;if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */var props={configurable:true,enumerable:true,writable:true};// $FlowFixMe Flow thinks console is immutable.\nObject.defineProperties(console,{log:assign({},props,{value:prevLog}),info:assign({},props,{value:prevInfo}),warn:assign({},props,{value:prevWarn}),error:assign({},props,{value:prevError}),group:assign({},props,{value:prevGroup}),groupCollapsed:assign({},props,{value:prevGroupCollapsed}),groupEnd:assign({},props,{value:prevGroupEnd})});/* eslint-enable react-internal/no-production-logging */}if(disabledDepth<0){error('disabledDepth fell below zero. '+'This is a bug in React. Please file an issue.');}}}var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;var prefix;function describeBuiltInComponentFrame(name,source,ownerFn){{if(prefix===undefined){// Extract the VM specific prefix used by each line.\ntry{throw Error();}catch(x){var match=x.stack.trim().match(/\\n( *(at )?)/);prefix=match&&match[1]||'';}}// We use the prefix to ensure our stacks line up with native stack frames.\nreturn'\\n'+prefix+name;}}var reentry=false;var componentFrameCache;{var PossiblyWeakMap=typeof WeakMap==='function'?WeakMap:Map;componentFrameCache=new PossiblyWeakMap();}function describeNativeComponentFrame(fn,construct){// If something asked for a stack inside a fake render, it should get ignored.\nif(!fn||reentry){return'';}{var frame=componentFrameCache.get(fn);if(frame!==undefined){return frame;}}var control;reentry=true;var previousPrepareStackTrace=Error.prepareStackTrace;// $FlowFixMe It does accept undefined.\nError.prepareStackTrace=undefined;var previousDispatcher;{previousDispatcher=ReactCurrentDispatcher.current;// Set the dispatcher in DEV because this might be call in the render function\n// for warnings.\nReactCurrentDispatcher.current=null;disableLogs();}try{// This should throw.\nif(construct){// Something should be setting the props in the constructor.\nvar Fake=function Fake(){throw Error();};// $FlowFixMe\nObject.defineProperty(Fake.prototype,'props',{set:function set(){// We use a throwing setter instead of frozen or non-writable props\n// because that won't throw in a non-strict mode function.\nthrow Error();}});if((typeof Reflect===\"undefined\"?\"undefined\":_typeof(Reflect))==='object'&&Reflect.construct){// We construct a different control for this case to include any extra\n// frames added by the construct call.\ntry{Reflect.construct(Fake,[]);}catch(x){control=x;}Reflect.construct(fn,[],Fake);}else{try{Fake.call();}catch(x){control=x;}fn.call(Fake.prototype);}}else{try{throw Error();}catch(x){control=x;}fn();}}catch(sample){// This is inlined manually because closure doesn't do it for us.\nif(sample&&control&&typeof sample.stack==='string'){// This extracts the first frame from the sample that isn't also in the control.\n// Skipping one frame that we assume is the frame that calls the two.\nvar sampleLines=sample.stack.split('\\n');var controlLines=control.stack.split('\\n');var s=sampleLines.length-1;var c=controlLines.length-1;while(s>=1&&c>=0&&sampleLines[s]!==controlLines[c]){// We expect at least one stack frame to be shared.\n// Typically this will be the root most one. However, stack frames may be\n// cut off due to maximum stack limits. In this case, one maybe cut off\n// earlier than the other. We assume that the sample is longer or the same\n// and there for cut off earlier. So we should find the root most frame in\n// the sample somewhere in the control.\nc--;}for(;s>=1&&c>=0;s--,c--){// Next we find the first one that isn't the same which should be the\n// frame that called our sample function and the control.\nif(sampleLines[s]!==controlLines[c]){// In V8, the first line is describing the message but other VMs don't.\n// If we're about to return the first line, and the control is also on the same\n// line, that's a pretty good indicator that our sample threw at same line as\n// the control. I.e. before we entered the sample frame. So we ignore this result.\n// This can happen if you passed a class to function component, or non-function.\nif(s!==1||c!==1){do{s--;c--;// We may still have similar intermediate frames from the construct call.\n// The next one that isn't the same should be our match though.\nif(c<0||sampleLines[s]!==controlLines[c]){// V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\nvar _frame='\\n'+sampleLines[s].replace(' at new ',' at ');// If our component frame is labeled \"<anonymous>\"\n// but we have a user-provided \"displayName\"\n// splice it in to make the stack more readable.\nif(fn.displayName&&_frame.includes('<anonymous>')){_frame=_frame.replace('<anonymous>',fn.displayName);}{if(typeof fn==='function'){componentFrameCache.set(fn,_frame);}}// Return the line we found.\nreturn _frame;}}while(s>=1&&c>=0);}break;}}}}finally{reentry=false;{ReactCurrentDispatcher.current=previousDispatcher;reenableLogs();}Error.prepareStackTrace=previousPrepareStackTrace;}// Fallback to just using the name if we couldn't make it throw.\nvar name=fn?fn.displayName||fn.name:'';var syntheticFrame=name?describeBuiltInComponentFrame(name):'';{if(typeof fn==='function'){componentFrameCache.set(fn,syntheticFrame);}}return syntheticFrame;}function describeClassComponentFrame(ctor,source,ownerFn){{return describeNativeComponentFrame(ctor,true);}}function describeFunctionComponentFrame(fn,source,ownerFn){{return describeNativeComponentFrame(fn,false);}}function shouldConstruct(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function describeUnknownElementTypeFrameInDEV(type,source,ownerFn){if(type==null){return'';}if(typeof type==='function'){{return describeNativeComponentFrame(type,shouldConstruct(type));}}if(typeof type==='string'){return describeBuiltInComponentFrame(type);}switch(type){case REACT_SUSPENSE_TYPE:return describeBuiltInComponentFrame('Suspense');case REACT_SUSPENSE_LIST_TYPE:return describeBuiltInComponentFrame('SuspenseList');}if(_typeof(type)==='object'){switch(type.$$typeof){case REACT_FORWARD_REF_TYPE:return describeFunctionComponentFrame(type.render);case REACT_MEMO_TYPE:// Memo may contain any component type so we recursively resolve it.\nreturn describeUnknownElementTypeFrameInDEV(type.type,source,ownerFn);case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{// Lazy may contain any component type so we recursively resolve it.\nreturn describeUnknownElementTypeFrameInDEV(init(payload),source,ownerFn);}catch(x){}}}}return'';}function describeFiber(fiber){var owner=fiber._debugOwner?fiber._debugOwner.type:null;var source=fiber._debugSource;switch(fiber.tag){case HostComponent:return describeBuiltInComponentFrame(fiber.type);case LazyComponent:return describeBuiltInComponentFrame('Lazy');case SuspenseComponent:return describeBuiltInComponentFrame('Suspense');case SuspenseListComponent:return describeBuiltInComponentFrame('SuspenseList');case FunctionComponent:case IndeterminateComponent:case SimpleMemoComponent:return describeFunctionComponentFrame(fiber.type);case ForwardRef:return describeFunctionComponentFrame(fiber.type.render);case ClassComponent:return describeClassComponentFrame(fiber.type);default:return'';}}function getStackByFiberInDevAndProd(workInProgress){try{var info='';var node=workInProgress;do{info+=describeFiber(node);node=node[\"return\"];}while(node);return info;}catch(x){return'\\nError generating stack: '+x.message+'\\n'+x.stack;}}function getWrappedName(outerType,innerType,wrapperName){var displayName=outerType.displayName;if(displayName){return displayName;}var functionName=innerType.displayName||innerType.name||'';return functionName!==''?wrapperName+\"(\"+functionName+\")\":wrapperName;}// Keep in sync with react-reconciler/getComponentNameFromFiber\nfunction getContextName(type){return type.displayName||'Context';}// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\nfunction getComponentNameFromType(type){if(type==null){// Host root, text node or just invalid type.\nreturn null;}{if(typeof type.tag==='number'){error('Received an unexpected object in getComponentNameFromType(). '+'This is likely a bug in React. Please file an issue.');}}if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}switch(type){case REACT_FRAGMENT_TYPE:return'Fragment';case REACT_PORTAL_TYPE:return'Portal';case REACT_PROFILER_TYPE:return'Profiler';case REACT_STRICT_MODE_TYPE:return'StrictMode';case REACT_SUSPENSE_TYPE:return'Suspense';case REACT_SUSPENSE_LIST_TYPE:return'SuspenseList';}if(_typeof(type)==='object'){switch(type.$$typeof){case REACT_CONTEXT_TYPE:var context=type;return getContextName(context)+'.Consumer';case REACT_PROVIDER_TYPE:var provider=type;return getContextName(provider._context)+'.Provider';case REACT_FORWARD_REF_TYPE:return getWrappedName(type,type.render,'ForwardRef');case REACT_MEMO_TYPE:var outerName=type.displayName||null;if(outerName!==null){return outerName;}return getComponentNameFromType(type.type)||'Memo';case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{return getComponentNameFromType(init(payload));}catch(x){return null;}}// eslint-disable-next-line no-fallthrough\n}}return null;}function getWrappedName$1(outerType,innerType,wrapperName){var functionName=innerType.displayName||innerType.name||'';return outerType.displayName||(functionName!==''?wrapperName+\"(\"+functionName+\")\":wrapperName);}// Keep in sync with shared/getComponentNameFromType\nfunction getContextName$1(type){return type.displayName||'Context';}function getComponentNameFromFiber(fiber){var tag=fiber.tag,type=fiber.type;switch(tag){case CacheComponent:return'Cache';case ContextConsumer:var context=type;return getContextName$1(context)+'.Consumer';case ContextProvider:var provider=type;return getContextName$1(provider._context)+'.Provider';case DehydratedFragment:return'DehydratedFragment';case ForwardRef:return getWrappedName$1(type,type.render,'ForwardRef');case Fragment:return'Fragment';case HostComponent:// Host component type is the display name (e.g. \"div\", \"View\")\nreturn type;case HostPortal:return'Portal';case HostRoot:return'Root';case HostText:return'Text';case LazyComponent:// Name comes from the type in this case; we don't have a tag.\nreturn getComponentNameFromType(type);case Mode:if(type===REACT_STRICT_MODE_TYPE){// Don't be less specific than shared/getComponentNameFromType\nreturn'StrictMode';}return'Mode';case OffscreenComponent:return'Offscreen';case Profiler:return'Profiler';case ScopeComponent:return'Scope';case SuspenseComponent:return'Suspense';case SuspenseListComponent:return'SuspenseList';case TracingMarkerComponent:return'TracingMarker';// The display name for this tags come from the user-provided type:\ncase ClassComponent:case FunctionComponent:case IncompleteClassComponent:case IndeterminateComponent:case MemoComponent:case SimpleMemoComponent:if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}break;}return null;}var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var current=null;var isRendering=false;function getCurrentFiberOwnerNameInDevOrNull(){{if(current===null){return null;}var owner=current._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentNameFromFiber(owner);}}return null;}function getCurrentFiberStackInDev(){{if(current===null){return'';}// Safe because if current fiber exists, we are reconciling,\n// and it is guaranteed to be the work-in-progress version.\nreturn getStackByFiberInDevAndProd(current);}}function resetCurrentFiber(){{ReactDebugCurrentFrame.getCurrentStack=null;current=null;isRendering=false;}}function setCurrentFiber(fiber){{ReactDebugCurrentFrame.getCurrentStack=getCurrentFiberStackInDev;current=fiber;isRendering=false;}}function setIsRendering(rendering){{isRendering=rendering;}}// Flow does not allow string concatenation of most non-string types. To work\n// around this limitation, we use an opaque type that can only be obtained by\n// passing the value through getToStringValue first.\nfunction toString(value){// The coercion safety check is performed in getToStringValue().\n// eslint-disable-next-line react-internal/safe-string-coercion\nreturn''+value;}function getToStringValue(value){switch(_typeof(value)){case'boolean':case'number':case'string':case'undefined':return value;case'object':{checkFormFieldValueStringCoercion(value);}return value;default:// function, symbol are assigned as empty strings\nreturn'';}}var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};function checkControlledValueProps(tagName,props){{if(!(hasReadOnlyValue[props.type]||props.onChange||props.onInput||props.readOnly||props.disabled||props.value==null)){error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');}if(!(props.onChange||props.readOnly||props.disabled||props.checked==null)){error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}}}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);{checkFormFieldValueStringCoercion(node[valueField]);}var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail\n// and don't track value will cause over reporting of changes,\n// but it's better then a hard failure\n// (needed for certain tests that spyOn input values and Safari)\nif(node.hasOwnProperty(valueField)||typeof descriptor==='undefined'||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}var _get=descriptor.get,_set=descriptor.set;Object.defineProperty(node,valueField,{configurable:true,get:function get(){return _get.call(this);},set:function set(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;_set.call(this,value);}});// We could've passed this the first time\n// but it triggers a bug in IE11 and Edge 14/15.\n// Calling defineProperty() again should be equivalent.\n// https://github.com/facebook/react/issues/11768\nObject.defineProperty(node,valueField,{enumerable:descriptor.enumerable});var tracker={getValue:function getValue(){return currentValue;},setValue:function setValue(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;},stopTracking:function stopTracking(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState\nnode._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely\n// that trying again will succeed\nif(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}function getActiveElement(doc){doc=doc||(typeof document!=='undefined'?document:undefined);if(typeof doc==='undefined'){return null;}try{return doc.activeElement||doc.body;}catch(e){return doc.body;}}var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**\n * Implements an <input> host component that allows setting these optional\n * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n *\n * If `checked` or `value` are not supplied (or null/undefined), user actions\n * that affect the checked state or value will trigger updates to the element.\n *\n * If they are supplied (and not null/undefined), the rendered element will not\n * trigger updates to the element. Instead, the props must change in order for\n * the rendered element to be updated.\n *\n * The rendered element will be initialized as unchecked (or `defaultChecked`)\n * with an empty value (or `defaultValue`).\n *\n * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n */function getHostProps(element,props){var node=element;var checked=props.checked;var hostProps=assign({},props,{defaultChecked:undefined,defaultValue:undefined,value:undefined,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{checkControlledValueProps('input',props);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){error('%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){error('%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnValueDefaultValue=true;}}var node=element;var defaultValue=props.defaultValue==null?'':props.defaultValue;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:getToStringValue(props.value!=null?props.value:defaultValue),controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked,false);}}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){error('A component is changing an uncontrolled input to be controlled. '+'This is likely caused by the value changing from undefined to '+'a defined value, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){error('A component is changing a controlled input to be uncontrolled. '+'This is likely caused by the value changing from a defined to '+'undefined, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=getToStringValue(props.value);var type=props.type;if(value!=null){if(type==='number'){if(value===0&&node.value===''||// We explicitly want to coerce to number here if possible.\n// eslint-disable-next-line\nnode.value!=value){node.value=toString(value);}}else if(node.value!==toString(value)){node.value=toString(value);}}else if(type==='submit'||type==='reset'){// Submit/reset inputs need the attribute removed completely to avoid\n// blank-text buttons.\nnode.removeAttribute('value');return;}{// When syncing the value attribute, the value comes from a cascade of\n// properties:\n//  1. The value React property\n//  2. The defaultValue React property\n//  3. Otherwise there should be no change\nif(props.hasOwnProperty('value')){setDefaultValue(node,props.type,value);}else if(props.hasOwnProperty('defaultValue')){setDefaultValue(node,props.type,getToStringValue(props.defaultValue));}}{// When syncing the checked attribute, it only changes when it needs\n// to be removed, such as transitioning from a checkbox into a text input\nif(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props,isHydrating){var node=element;// Do not assign value if it is already set. This prevents user text input\n// from being lost during SSR hydration.\nif(props.hasOwnProperty('value')||props.hasOwnProperty('defaultValue')){var type=props.type;var isButton=type==='submit'||type==='reset';// Avoid setting value attribute on submit/reset inputs as it overrides the\n// default value provided by the browser. See: #12872\nif(isButton&&(props.value===undefined||props.value===null)){return;}var initialValue=toString(node._wrapperState.initialValue);// Do not assign value if it is already set. This prevents user text input\n// from being lost during SSR hydration.\nif(!isHydrating){{// When syncing the value attribute, the value property should use\n// the wrapperState._initialValue property. This uses:\n//\n//   1. The value React property when present\n//   2. The defaultValue React property when present\n//   3. An empty string\nif(initialValue!==node.value){node.value=initialValue;}}}{// Otherwise, the value attribute is synchronized to the property,\n// so we assign defaultValue to the same thing as the value property\n// assignment step above.\nnode.defaultValue=initialValue;}}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n// this is needed to work around a chrome bug where setting defaultChecked\n// will sometimes influence the value of checked (even after detachment).\n// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n// We need to temporarily unset name to avoid disrupting radio button groups.\nvar name=node.name;if(name!==''){node.name='';}{// When syncing the checked attribute, both the checked property and\n// attribute are assigned at the same time using defaultChecked. This uses:\n//\n//   1. The checked React property when present\n//   2. The defaultChecked React property when present\n//   3. Otherwise, false\nnode.defaultChecked=!node.defaultChecked;node.defaultChecked=!!node._wrapperState.initialChecked;}if(name!==''){node.name=name;}}function restoreControlledState(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,\n// but that sometimes behaves strangely in IE8. We could also try using\n// `form.getElementsByName`, but that will only return direct children\n// and won't include inputs that use the HTML5 `form=` attribute. Since\n// the input might not even be in a form. It might not even be in the\n// document. Let's just use the local `querySelectorAll` to ensure we don't\n// miss anything.\n{checkAttributeStringCoercion(name,'name');}var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type=\"radio\"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React\n// and the same name are rendered into the same form (same as #1939).\n// That's probably okay; we don't support it just as we don't support\n// mixing React radio buttons with non-React ones.\nvar otherProps=getFiberCurrentPropsFromNode(otherNode);if(!otherProps){throw new Error('ReactDOMInput: Mixing React and non-React radio inputs with the '+'same `name` is not supported.');}// We need update the tracked value on the named cousin since the value\n// was changed but the input saw no event or value set\nupdateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that\n// was previously checked to update will cause it to be come re-checked\n// as appropriate.\nupdateWrapper(otherNode,otherProps);}}}// In Chrome, assigning defaultValue to certain input types triggers input validation.\n// For number inputs, the display value loses trailing decimal points. For email inputs,\n// Chrome raises \"The specified value <x> is not a valid email address\".\n//\n// Here we check to see if the defaultValue has actually changed, avoiding these problems\n// when the user is inputting text\n//\n// https://github.com/facebook/react/issues/7253\nfunction setDefaultValue(node,type,value){if(// Focused number inputs synchronize on blur. See ChangeEventPlugin.js\ntype!=='number'||getActiveElement(node.ownerDocument)!==node){if(value==null){node.defaultValue=toString(node._wrapperState.initialValue);}else if(node.defaultValue!==toString(value)){node.defaultValue=toString(value);}}}var didWarnSelectedSetOnOption=false;var didWarnInvalidChild=false;var didWarnInvalidInnerHTML=false;/**\n * Implements an <option> host component that warns when `selected` is set.\n */function validateProps(element,props){{// If a value is not provided, then the children must be simple.\nif(props.value==null){if(_typeof(props.children)==='object'&&props.children!==null){React.Children.forEach(props.children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){return;}if(!didWarnInvalidChild){didWarnInvalidChild=true;error('Cannot infer the option value of complex children. '+'Pass a `value` prop or use a plain string as children to <option>.');}});}else if(props.dangerouslySetInnerHTML!=null){if(!didWarnInvalidInnerHTML){didWarnInvalidInnerHTML=true;error('Pass a `value` prop if you set dangerouslyInnerHTML so React knows '+'which value should be selected.');}}}// TODO: Remove support for `selected` in <option>.\nif(props.selected!=null&&!didWarnSelectedSetOnOption){error('Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');didWarnSelectedSetOnOption=true;}}}function postMountWrapper$1(element,props){// value=\"\" should make a value attribute (#6219)\nif(props.value!=null){element.setAttribute('value',toString(getToStringValue(props.value)));}}var isArrayImpl=Array.isArray;// eslint-disable-next-line no-redeclare\nfunction isArray(a){return isArrayImpl(a);}var didWarnValueDefaultValue$1;{didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){return'\\n\\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**\n * Validation function for `value` and `defaultValue`.\n */function checkSelectPropTypes(props){{checkControlledValueProps('select',props);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var propNameIsArray=isArray(props[propName]);if(props.multiple&&!propNameIsArray){error('The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&propNameIsArray){error('The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.\nselectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all\n// browsers for all cases.\nvar _selectedValue=toString(getToStringValue(propValue));var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**\n * Implements a <select> host component that allows optionally setting the\n * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n * stringable. If `multiple` is true, the prop must be an array of stringables.\n *\n * If `value` is not supplied (or null/undefined), user actions that change the\n * selected option will trigger updates to the rendered options.\n *\n * If it is supplied (and not null/undefined), the rendered options will not\n * update in response to user actions. Instead, the `value` prop must change in\n * order for the rendered options to update.\n *\n * If `defaultValue` is provided, any options with the supplied values will be\n * selected.\n */function getHostProps$1(element,props){return assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}node._wrapperState={wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){error('Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.\nif(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.\nupdateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$1(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}var didWarnValDefaultVal=false;/**\n * Implements a <textarea> host component that allows setting `value`, and\n * `defaultValue`. This differs from the traditional DOM API because value is\n * usually set as PCDATA children.\n *\n * If `value` is not supplied (or null/undefined), user actions that affect the\n * value will trigger updates to the element.\n *\n * If `value` is supplied (and not null/undefined), the rendered element will\n * not trigger updates to the element. Instead, the `value` prop must change in\n * order for the rendered element to be updated.\n *\n * The rendered element will be initialized with an empty value, the prop\n * `defaultValue` if specified, or the children content (deprecated).\n */function getHostProps$2(element,props){var node=element;if(props.dangerouslySetInnerHTML!=null){throw new Error('`dangerouslySetInnerHTML` does not make sense on <textarea>.');}// Always set children to the same thing. In IE9, the selection range will\n// get reset if `textContent` is mutated.  We could add a check in setTextContent\n// to only set the value if/when the value differs from the node value (which would\n// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n// solution. The value can be a boolean or object so that's why it's forced\n// to be a string.\nvar hostProps=assign({},props,{value:undefined,defaultValue:undefined,children:toString(node._wrapperState.initialValue)});return hostProps;}function initWrapperState$2(element,props){var node=element;{checkControlledValueProps('textarea',props);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){error('%s contains a textarea with both value and defaultValue props. '+'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it\nif(initialValue==null){var children=props.children,defaultValue=props.defaultValue;if(children!=null){{error('Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}{if(defaultValue!=null){throw new Error('If you supply `defaultValue` on a <textarea>, do not pass children.');}if(isArray(children)){if(children.length>1){throw new Error('<textarea> can only have at most one child.');}children=children[0];}defaultValue=children;}}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:getToStringValue(initialValue)};}function updateWrapper$1(element,props){var node=element;var value=getToStringValue(props.value);var defaultValue=getToStringValue(props.defaultValue);if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While\n// browsers typically do this as necessary, jsdom doesn't.\nvar newValue=toString(value);// To avoid side effects (such as losing text selection), only set value if changed\nif(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null&&node.defaultValue!==newValue){node.defaultValue=newValue;}}if(defaultValue!=null){node.defaultValue=toString(defaultValue);}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not\n// available until after the component has mounted.\nvar textContent=node.textContent;// Only set node.value if textContent is equal to the expected\n// initial value. In IE10/IE11 there is a bug where the placeholder attribute\n// will populate textContent as well.\n// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\nif(textContent===node._wrapperState.initialValue){if(textContent!==''&&textContent!==null){node.value=textContent;}}}function restoreControlledState$2(element,props){// DOM component is still mounted; update\nupdateWrapper$1(element,props);}var HTML_NAMESPACE='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';// Assumes there is no parent namespace.\nfunction getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE){// No (or default) parent namespace: potential entry point.\nreturn getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.\nreturn HTML_NAMESPACE;}// By default, pass namespace below.\nreturn parentNamespace;}/* globals MSApp */ /**\n * Create a function which has 'unsafe' privileges (required by windows8 apps)\n */var createMicrosoftUnsafeLocalFunction=function createMicrosoftUnsafeLocalFunction(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};var reusableSVGContainer;/**\n * Set the innerHTML property of a node\n *\n * @param {DOMElement} node\n * @param {string} html\n * @internal\n */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){if(node.namespaceURI===SVG_NAMESPACE){if(!('innerHTML'in node)){// IE does not have innerHTML for SVG nodes, so instead we inject the\n// new markup in a temp node and then move the child nodes across into\n// the target node\nreusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html.valueOf().toString()+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}return;}}node.innerHTML=html;});/**\n * HTML nodeType values that represent the type of the node\n */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**\n * Set the textContent property of a node. For text updates, it's faster\n * to set the `nodeValue` of the Text node directly instead of using\n * `.textContent` which will remove the existing node and create a new one.\n *\n * @param {DOMElement} node\n * @param {string} text\n * @internal\n */var setTextContent=function setTextContent(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};// List derived from Gecko source code:\n// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js\nvar shorthandToLonghand={animation:['animationDelay','animationDirection','animationDuration','animationFillMode','animationIterationCount','animationName','animationPlayState','animationTimingFunction'],background:['backgroundAttachment','backgroundClip','backgroundColor','backgroundImage','backgroundOrigin','backgroundPositionX','backgroundPositionY','backgroundRepeat','backgroundSize'],backgroundPosition:['backgroundPositionX','backgroundPositionY'],border:['borderBottomColor','borderBottomStyle','borderBottomWidth','borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth','borderLeftColor','borderLeftStyle','borderLeftWidth','borderRightColor','borderRightStyle','borderRightWidth','borderTopColor','borderTopStyle','borderTopWidth'],borderBlockEnd:['borderBlockEndColor','borderBlockEndStyle','borderBlockEndWidth'],borderBlockStart:['borderBlockStartColor','borderBlockStartStyle','borderBlockStartWidth'],borderBottom:['borderBottomColor','borderBottomStyle','borderBottomWidth'],borderColor:['borderBottomColor','borderLeftColor','borderRightColor','borderTopColor'],borderImage:['borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth'],borderInlineEnd:['borderInlineEndColor','borderInlineEndStyle','borderInlineEndWidth'],borderInlineStart:['borderInlineStartColor','borderInlineStartStyle','borderInlineStartWidth'],borderLeft:['borderLeftColor','borderLeftStyle','borderLeftWidth'],borderRadius:['borderBottomLeftRadius','borderBottomRightRadius','borderTopLeftRadius','borderTopRightRadius'],borderRight:['borderRightColor','borderRightStyle','borderRightWidth'],borderStyle:['borderBottomStyle','borderLeftStyle','borderRightStyle','borderTopStyle'],borderTop:['borderTopColor','borderTopStyle','borderTopWidth'],borderWidth:['borderBottomWidth','borderLeftWidth','borderRightWidth','borderTopWidth'],columnRule:['columnRuleColor','columnRuleStyle','columnRuleWidth'],columns:['columnCount','columnWidth'],flex:['flexBasis','flexGrow','flexShrink'],flexFlow:['flexDirection','flexWrap'],font:['fontFamily','fontFeatureSettings','fontKerning','fontLanguageOverride','fontSize','fontSizeAdjust','fontStretch','fontStyle','fontVariant','fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition','fontWeight','lineHeight'],fontVariant:['fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition'],gap:['columnGap','rowGap'],grid:['gridAutoColumns','gridAutoFlow','gridAutoRows','gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],gridArea:['gridColumnEnd','gridColumnStart','gridRowEnd','gridRowStart'],gridColumn:['gridColumnEnd','gridColumnStart'],gridColumnGap:['columnGap'],gridGap:['columnGap','rowGap'],gridRow:['gridRowEnd','gridRowStart'],gridRowGap:['rowGap'],gridTemplate:['gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],listStyle:['listStyleImage','listStylePosition','listStyleType'],margin:['marginBottom','marginLeft','marginRight','marginTop'],marker:['markerEnd','markerMid','markerStart'],mask:['maskClip','maskComposite','maskImage','maskMode','maskOrigin','maskPositionX','maskPositionY','maskRepeat','maskSize'],maskPosition:['maskPositionX','maskPositionY'],outline:['outlineColor','outlineStyle','outlineWidth'],overflow:['overflowX','overflowY'],padding:['paddingBottom','paddingLeft','paddingRight','paddingTop'],placeContent:['alignContent','justifyContent'],placeItems:['alignItems','justifyItems'],placeSelf:['alignSelf','justifySelf'],textDecoration:['textDecorationColor','textDecorationLine','textDecorationStyle'],textEmphasis:['textEmphasisColor','textEmphasisStyle'],transition:['transitionDelay','transitionDuration','transitionProperty','transitionTimingFunction'],wordWrap:['overflowWrap']};/**\n * CSS properties which accept numbers but are not in units of \"px\".\n */var isUnitlessNumber={animationIterationCount:true,aspectRatio:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridArea:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties\nfillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**\n * @param {string} prefix vendor-specific prefix, eg: Webkit\n * @param {string} key style name, eg: transitionDuration\n * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n * WebkitTransitionDuration\n */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**\n * Support style names that may come passed in prefixed by adding permutations\n * of vendor prefixes.\n */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n// infinite loop, because it iterates over the newly added props too.\nObject.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**\n * Convert a value into the proper css writable value. The style name `name`\n * should be logical (no hyphens), as specified\n * in `CSSProperty.isUnitlessNumber`.\n *\n * @param {string} name CSS property name such as `topMargin`.\n * @param {*} value CSS property value such as `10px`.\n * @return {string} Normalized style value with dimensions applied.\n */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the\n// whole string will be escaped when the attribute is injected into\n// the markup. If you provide unsafe user data here they can inject\n// arbitrary CSS which may be problematic (I couldn't repro this):\n// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n// This is not an XSS hole but instead a potential CSS injection issue\n// which has lead to a greater discussion about how we're going to\n// trust URLs moving forward. See #2115901\nvar isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers\n}{checkCSSPropertyStringCoercion(value,name);}return(''+value).trim();}var uppercasePattern=/([A-Z])/g;var msPattern=/^ms-/;/**\n * Hyphenates a camelcased CSS property name, for example:\n *\n *   > hyphenateStyleName('backgroundColor')\n *   < \"background-color\"\n *   > hyphenateStyleName('MozTransition')\n *   < \"-moz-transition\"\n *   > hyphenateStyleName('msTransition')\n *   < \"-ms-transition\"\n *\n * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n * is converted to `-ms-`.\n */function hyphenateStyleName(name){return name.replace(uppercasePattern,'-$1').toLowerCase().replace(msPattern,'-ms-');}var warnValidStyle=function warnValidStyle(){};{// 'msTransform' is correct, but the other prefixes should be capitalized\nvar badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;var msPattern$1=/^-ms-/;var hyphenPattern=/-(.)/g;// style values shouldn't contain a semicolon\nvar badStyleValueWithSemicolonPattern=/;\\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var camelize=function camelize(string){return string.replace(hyphenPattern,function(_,character){return character.toUpperCase();});};var warnHyphenatedStyleName=function warnHyphenatedStyleName(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported style property %s. Did you mean %s?',name,// As Andi Smith suggests\n// (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n// is converted to lowercase `ms`.\ncamelize(name.replace(msPattern$1,'ms-')));};var warnBadVendoredStyleName=function warnBadVendoredStyleName(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported vendor-prefixed style property %s. Did you mean %s?',name,name.charAt(0).toUpperCase()+name.slice(1));};var warnStyleValueWithSemicolon=function warnStyleValueWithSemicolon(name,value){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;error(\"Style property values shouldn't contain a semicolon. \"+'Try \"%s: %s\" instead.',name,value.replace(badStyleValueWithSemicolonPattern,''));};var warnStyleValueIsNaN=function warnStyleValueIsNaN(name,value){if(warnedForNaNValue){return;}warnedForNaNValue=true;error('`NaN` is an invalid value for the `%s` css style property.',name);};var warnStyleValueIsInfinity=function warnStyleValueIsInfinity(name,value){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;error('`Infinity` is an invalid value for the `%s` css style property.',name);};warnValidStyle=function warnValidStyle(name,value){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value);}}};}var warnValidStyle$1=warnValidStyle;/**\n * Operations for dealing with CSS properties.\n */ /**\n * This creates a string that is expected to be equivalent to the style\n * attribute generated by server-side rendering. It by-passes warnings and\n * security checks so it's not safe to use this value for anything other than\n * comparison. It is only used in DEV for SSR validation.\n */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+(isCustomProperty?styleName:hyphenateStyleName(styleName))+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**\n * Sets the value for multiple styles on a node.  If a value is specified as\n * '' (empty string), the corresponding style property will be unset.\n *\n * @param {DOMElement} node\n * @param {object} styles\n */function setValueForStyles(node,styles){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName]);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}function isValueEmpty(value){return value==null||typeof value==='boolean'||value==='';}/**\n * Given {color: 'red', overflow: 'hidden'} returns {\n *   color: 'color',\n *   overflowX: 'overflow',\n *   overflowY: 'overflow',\n * }. This can be read as \"the overflowY property was set by the overflow\n * shorthand\". That is, the values are the property that each was derived from.\n */function expandShorthandMap(styles){var expanded={};for(var key in styles){var longhands=shorthandToLonghand[key]||[key];for(var i=0;i<longhands.length;i++){expanded[longhands[i]]=key;}}return expanded;}/**\n * When mixing shorthand and longhand property names, we warn during updates if\n * we expect an incorrect result to occur. In particular, we warn for:\n *\n * Updating a shorthand property (longhand gets overwritten):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}\n *   becomes .style.font = 'baz'\n * Removing a shorthand property (longhand gets lost too):\n *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}\n *   becomes .style.font = ''\n * Removing a longhand property (should revert to shorthand; doesn't):\n *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}\n *   becomes .style.fontVariant = ''\n */function validateShorthandPropertyCollisionInDev(styleUpdates,nextStyles){{if(!nextStyles){return;}var expandedUpdates=expandShorthandMap(styleUpdates);var expandedStyles=expandShorthandMap(nextStyles);var warnedAbout={};for(var key in expandedUpdates){var originalKey=expandedUpdates[key];var correctOriginalKey=expandedStyles[key];if(correctOriginalKey&&originalKey!==correctOriginalKey){var warningKey=originalKey+','+correctOriginalKey;if(warnedAbout[warningKey]){continue;}warnedAbout[warningKey]=true;error('%s a style property during rerender (%s) when a '+'conflicting property is set (%s) can lead to styling bugs. To '+\"avoid this, don't mix shorthand and non-shorthand properties \"+'for the same value; instead, replace the shorthand with '+'separate values.',isValueEmpty(styleUpdates[originalKey])?'Removing':'Updating',originalKey,correctOriginalKey);}}}}// For HTML, certain tags should omit their close tag. We keep a list for\n// those special-case tags.\nvar omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true// NOTE: menuitem's close tag should be omitted, but that causes problems.\n};// `omittedCloseTags` except that `menuitem` should still have its closing tag.\nvar voidElementTags=assign({menuitem:true},omittedCloseTags);var HTML='__html';function assertValidProps(tag,props){if(!props){return;}// Note the use of `==` which checks for null or undefined.\nif(voidElementTags[tag]){if(props.children!=null||props.dangerouslySetInnerHTML!=null){throw new Error(tag+\" is a void element tag and must neither have `children` nor \"+'use `dangerouslySetInnerHTML`.');}}if(props.dangerouslySetInnerHTML!=null){if(props.children!=null){throw new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');}if(_typeof(props.dangerouslySetInnerHTML)!=='object'||!(HTML in props.dangerouslySetInnerHTML)){throw new Error('`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. '+'Please visit https://reactjs.org/link/dangerously-set-inner-html '+'for more information.');}}{if(!props.suppressContentEditableWarning&&props.contentEditable&&props.children!=null){error('A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.');}}if(props.style!=null&&_typeof(props.style)!=='object'){throw new Error('The `style` prop expects a mapping from style properties to values, '+\"not a string. For example, style={{marginRight: spacing + 'em'}} when \"+'using JSX.');}}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.\n// We don't mind this list too much because we expect it to never grow.\n// The alternative is to track the namespace in a few places which is convoluted.\n// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\ncase'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}// When adding attributes to the HTML or SVG allowed attribute list, be sure to\n// also add them to this module to ensure casing and incorrect name\n// warnings.\nvar possibleStandardNames={// HTML\naccept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite',\"class\":'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime',\"default\":'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',disablepictureinpicture:'disablePictureInPicture',disableremoteplayback:'disableRemotePlayback',download:'download',draggable:'draggable',enctype:'encType',enterkeyhint:'enterKeyHint',\"for\":'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',imagesizes:'imageSizes',imagesrcset:'imageSrcSet',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nomodule:'noModule',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG\nabout:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2',\"in\":'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform',\"typeof\":'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};var ariaProperties={'aria-current':0,// state\n'aria-description':0,'aria-details':0,'aria-disabled':0,// state\n'aria-hidden':0,// state\n'aria-invalid':0,// state\n'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes\n'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes\n'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes\n'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes\n'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');function validateProperty(tagName,name){{if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM\n// DOM properties, then it is an invalid aria-* attribute.\nif(correctName==null){error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',name);warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.\nif(name!==correctName){error('Invalid ARIA attribute `%s`. Did you mean `%s`?',name,correctName);warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM\n// DOM properties, then it is an invalid aria-* attribute.\nif(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.\nif(name!==standardName){error('Unknown ARIA attribute `%s`. Did you mean `%s`?',name,standardName);warnedProperties[name]=true;return true;}}}return true;}function warnInvalidARIAProps(type,props){{var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){error('Invalid aria prop %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}else if(invalidProps.length>1){error('Invalid aria props %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function validateProperties$1(type,props){{if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){error('`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.',type);}else{error('`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.',type);}}}}var validateProperty$1=function validateProperty$1(){};{var warnedProperties$1={};var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');validateProperty$1=function validateProperty$1(tagName,name,value,eventRegistry){if(hasOwnProperty.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.\nif(eventRegistry!=null){var registrationNameDependencies=eventRegistry.registrationNameDependencies,possibleRegistrationNames=eventRegistry.possibleRegistrationNames;if(registrationNameDependencies.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){error('Invalid event handler property `%s`. Did you mean `%s`?',name,registrationName);warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){error('Unknown event handler property `%s`. It will be ignored.',name);warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.\n// So we can't tell if the event name is correct for sure, but we can filter\n// out known bad ones like `onclick`. We can't suggest a specific replacement though.\nif(INVALID_EVENT_NAME_REGEX.test(name)){error('Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.',name);}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes\nif(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){error('Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){error('The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){error('Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.',_typeof(value));warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){error('Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.',name);warnedProperties$1[name]=true;return true;}var propertyInfo=getPropertyInfo(name);var isReserved=propertyInfo!==null&&propertyInfo.type===RESERVED;// Known attributes should match the casing specified in the property config.\nif(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){error('Invalid DOM property `%s`. Did you mean `%s`?',name,standardName);warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they\n// will be cased anyway with server rendering.\nerror('React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.',name,lowerCasedName);warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){if(value){error('Received `%s` for a non-boolean attribute `%s`.\\n\\n'+'If you want to write it to the DOM, pass a string instead: '+'%s=\"%s\" or %s={value.toString()}.',value,name,name,value,name);}else{error('Received `%s` for a non-boolean attribute `%s`.\\n\\n'+'If you want to write it to the DOM, pass a string instead: '+'%s=\"%s\" or %s={value.toString()}.\\n\\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',value,name,name,value,name,name,name);}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate\n// data types for reserved props\nif(isReserved){return true;}// Warn when a known attribute is a bad type\nif(shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){warnedProperties$1[name]=true;return false;}// Warn when passing the strings 'false' or 'true' into a boolean prop\nif((value==='false'||value==='true')&&propertyInfo!==null&&propertyInfo.type===BOOLEAN){error('Received the string `%s` for the boolean attribute `%s`. '+'%s '+'Did you mean %s={%s}?',value,name,value==='false'?'The browser will interpret it as a truthy value.':'Although this works, it will not work as expected if you pass the string \"false\".',name,value);warnedProperties$1[name]=true;return true;}return true;};}var warnUnknownProperties=function warnUnknownProperties(type,props,eventRegistry){{var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],eventRegistry);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){error('Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}else if(unknownProps.length>1){error('Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}}};function validateProperties$2(type,props,eventRegistry){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,eventRegistry);}var IS_EVENT_HANDLE_NON_MANAGED_NODE=1;var IS_NON_DELEGATED=1<<1;var IS_CAPTURE_PHASE=1<<2;// set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when\n// we call willDeferLaterForLegacyFBSupport, thus not bailing out\n// will result in endless cycles like an infinite loop.\n// We also don't want to defer during event replaying.\nvar SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS=IS_EVENT_HANDLE_NON_MANAGED_NODE|IS_NON_DELEGATED|IS_CAPTURE_PHASE;// This exists to avoid circular dependency between ReactDOMEventReplaying\n// and DOMPluginEventSystem.\nvar currentReplayingEvent=null;function setReplayingEvent(event){{if(currentReplayingEvent!==null){error('Expected currently replaying event to be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=event;}function resetReplayingEvent(){{if(currentReplayingEvent===null){error('Expected currently replaying event to not be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=null;}function isReplayingEvent(event){return event===currentReplayingEvent;}/**\n * Gets the target node from a native browser event by accounting for\n * inconsistencies in browser DOM APIs.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {DOMEventTarget} Target node.\n */function getEventTarget(nativeEvent){// Fallback to nativeEvent.srcElement for IE9\n// https://github.com/facebook/react/issues/12506\nvar target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963\nif(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n// @see http://www.quirksmode.org/js/events_properties.html\nreturn target.nodeType===TEXT_NODE?target.parentNode:target;}var restoreImpl=null;var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we\n// always receive the correct fiber here\nvar internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted\nreturn;}if(typeof restoreImpl!=='function'){throw new Error('setRestoreImplementation() needs to be called to handle a target for controlled '+'events. This error is likely caused by a bug in React. Please file an issue.');}var stateNode=internalInstance.stateNode;// Guard against Fiber being unmounted.\nif(stateNode){var _props=getFiberCurrentPropsFromNode(stateNode);restoreImpl(internalInstance.stateNode,internalInstance.type,_props);}}function setRestoreImplementation(impl){restoreImpl=impl;}function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function needsStateRestore(){return restoreTarget!==null||restoreQueue!==null;}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}// the renderer. Such as when we're dispatching events or if third party\n// libraries need to call batchedUpdates. Eventually, this API will go away when\n// everything is batched by default. We'll then have a similar API to opt-out of\n// scheduled work and instead do synchronous work.\n// Defaults\nvar batchedUpdatesImpl=function batchedUpdatesImpl(fn,bookkeeping){return fn(bookkeeping);};var flushSyncImpl=function flushSyncImpl(){};var isInsideEventHandler=false;function finishEventHandler(){// Here we wait until all updates have propagated, which is important\n// when using controlled components within layers:\n// https://github.com/facebook/react/issues/1698\n// Then we restore state of any controlled component.\nvar controlledComponentsHavePendingUpdates=needsStateRestore();if(controlledComponentsHavePendingUpdates){// If a controlled event was fired, we may need to restore the state of\n// the DOM node back to the controlled value. This is necessary when React\n// bails out of the update without touching the DOM.\n// TODO: Restore state in the microtask, after the discrete updates flush,\n// instead of early flushing them here.\nflushSyncImpl();restoreStateIfNeeded();}}function batchedUpdates(fn,a,b){if(isInsideEventHandler){// If we are currently inside another batch, we need to wait until it\n// fully completes before restoring state.\nreturn fn(a,b);}isInsideEventHandler=true;try{return batchedUpdatesImpl(fn,a,b);}finally{isInsideEventHandler=false;finishEventHandler();}}// TODO: Replace with flushSync\nfunction setBatchingImplementation(_batchedUpdatesImpl,_discreteUpdatesImpl,_flushSyncImpl){batchedUpdatesImpl=_batchedUpdatesImpl;flushSyncImpl=_flushSyncImpl;}function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':case'onMouseEnter':return!!(props.disabled&&isInteractive(type));default:return false;}}/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */function getListener(inst,registrationName){var stateNode=inst.stateNode;if(stateNode===null){// Work in progress (ex: onload events in incremental mode).\nreturn null;}var props=getFiberCurrentPropsFromNode(stateNode);if(props===null){// Work in progress.\nreturn null;}var listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}if(listener&&typeof listener!=='function'){throw new Error(\"Expected `\"+registrationName+\"` listener to be a function, instead got a value of `\"+_typeof(listener)+\"` type.\");}return listener;}var passiveBrowserEventsSupported=false;// Check if browser support events with passive listeners\n// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\nif(canUseDOM){try{var options={};// $FlowFixMe: Ignore Flow complaining about needing a value\nObject.defineProperty(options,'passive',{get:function get(){passiveBrowserEventsSupported=true;}});window.addEventListener('test',options,options);window.removeEventListener('test',options,options);}catch(e){passiveBrowserEventsSupported=false;}}function invokeGuardedCallbackProd(name,func,context,a,b,c,d,e,f){var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){this.onError(error);}}var invokeGuardedCallbackImpl=invokeGuardedCallbackProd;{// In DEV mode, we swap out invokeGuardedCallback for a special version\n// that plays more nicely with the browser's DevTools. The idea is to preserve\n// \"Pause on exceptions\" behavior. Because React wraps all user-provided\n// functions in invokeGuardedCallback, and the production version of\n// invokeGuardedCallback uses a try-catch, all user exceptions are treated\n// like caught exceptions, and the DevTools won't pause unless the developer\n// takes the extra step of enabling pause on caught exceptions. This is\n// unintuitive, though, because even though React has caught the error, from\n// the developer's perspective, the error is uncaught.\n//\n// To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n// DOM node, and call the user-provided callback from inside an event handler\n// for that fake event. If the callback throws, the error is \"captured\" using\n// a global event handler. But because the error happens in a different\n// event loop context, it does not interrupt the normal program flow.\n// Effectively, this gives us try-catch behavior without actually using\n// try-catch. Neat!\n// Check that the browser supports the APIs we need to implement our special\n// DEV version of invokeGuardedCallback\nif(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');invokeGuardedCallbackImpl=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// If document doesn't exist we know for sure we will crash in this method\n// when we call document.createEvent(). However this can cause confusing\n// errors: https://github.com/facebook/create-react-app/issues/3482\n// So we preemptively throw with a better message instead.\nif(typeof document==='undefined'||document===null){throw new Error('The `document` global was defined when React was initialized, but is not '+'defined anymore. This can happen in a test environment if a component '+'schedules an update from an asynchronous callback, but the test has already '+'finished running. To solve this, you can either unmount the component at '+'the end of your test (and ensure that any asynchronous operations get '+'canceled in `componentWillUnmount`), or you can change the test itself '+'to be asynchronous.');}var evt=document.createEvent('Event');var didCall=false;// Keeps track of whether the user-provided callback threw an error. We\n// set this to true at the beginning, then set it to false right after\n// calling the function. If the function errors, `didError` will never be\n// set to false. This strategy works even if the browser is flaky and\n// fails to call our global error handler, because it doesn't rely on\n// the error event at all.\nvar didError=true;// Keeps track of the value of window.event so that we can reset it\n// during the callback to let user code access window.event in the\n// browsers that support it.\nvar windowEvent=window.event;// Keeps track of the descriptor of window.event to restore it after event\n// dispatching: https://github.com/facebook/react/issues/13688\nvar windowEventDescriptor=Object.getOwnPropertyDescriptor(window,'event');function restoreAfterDispatch(){// We immediately remove the callback from event listeners so that\n// nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n// nested call would trigger the fake event handlers of any call higher\n// in the stack.\nfakeNode.removeEventListener(evtType,callCallback,false);// We check for window.hasOwnProperty('event') to prevent the\n// window.event assignment in both IE <= 10 as they throw an error\n// \"Member not found\" in strict mode, and in Firefox which does not\n// support window.event.\nif(typeof window.event!=='undefined'&&window.hasOwnProperty('event')){window.event=windowEvent;}}// Create an event handler for our fake event. We will synchronously\n// dispatch our fake event using `dispatchEvent`. Inside the handler, we\n// call the user-provided callback.\nvar funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){didCall=true;restoreAfterDispatch();func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value\n// that was thrown. It's possible that this error handler will fire more\n// than once; for example, if non-React code also calls `dispatchEvent`\n// and a handler for that event throws. We should be resilient to most of\n// those cases. Even if our error event handler fires more than once, the\n// last error event is always used. If the callback actually does error,\n// we know that the last error event is the correct one, because it's not\n// possible for anything else to have happened in between our callback\n// erroring and the code that follows the `dispatchEvent` call below. If\n// the callback doesn't error, but the error event was fired, we know to\n// ignore it because `didError` will be false, as described above.\nvar error;// Use this to track whether the error event is ever called.\nvar didSetError=false;var isCrossOriginError=false;function handleWindowError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}if(event.defaultPrevented){// Some other error handler has prevented default.\n// Browsers silence the error report if this happens.\n// We'll remember this to later decide whether to log it or not.\nif(error!=null&&_typeof(error)==='object'){try{error._suppressLogging=true;}catch(inner){// Ignore.\n}}}}// Create a fake event type.\nvar evtType=\"react-\"+(name?name:'invokeguardedcallback');// Attach our event handlers\nwindow.addEventListener('error',handleWindowError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function\n// errors, it will trigger our global error handler.\nevt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(windowEventDescriptor){Object.defineProperty(window,'event',windowEventDescriptor);}if(didCall&&didError){if(!didSetError){// The callback errored, but the error event never fired.\n// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error('An error was thrown inside one of your components, but React '+\"doesn't know what it was. This is likely due to browser \"+'flakiness. React does its best to preserve the \"Pause on '+'exceptions\" behavior of the DevTools, which requires some '+\"DEV-mode only tricks. It's possible that these don't work in \"+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){// eslint-disable-next-line react-internal/prod-error-codes\nerror=new Error(\"A cross-origin error was thrown. React doesn't have access to \"+'the actual error object in development. '+'See https://reactjs.org/link/crossorigin-error for more information.');}this.onError(error);}// Remove our event listeners\nwindow.removeEventListener('error',handleWindowError);if(!didCall){// Something went really wrong, and our event was not dispatched.\n// https://github.com/facebook/react/issues/16734\n// https://github.com/facebook/react/issues/16585\n// Fall back to the production implementation.\nrestoreAfterDispatch();return invokeGuardedCallbackProd.apply(this,arguments);}};}}var invokeGuardedCallbackImpl$1=invokeGuardedCallbackImpl;var hasError=false;var caughtError=null;// Used by event system to capture/rethrow the first error.\nvar hasRethrowError=false;var rethrowError=null;var reporter={onError:function onError(error){hasError=true;caughtError=error;}};/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){hasError=false;caughtError=null;invokeGuardedCallbackImpl$1.apply(reporter,arguments);}/**\n * Same as invokeGuardedCallback, but instead of returning an error, it stores\n * it in a global so it can be rethrown by `rethrowCaughtError` later.\n * TODO: See if caughtError and rethrowError can be unified.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){invokeGuardedCallback.apply(this,arguments);if(hasError){var error=clearCaughtError();if(!hasRethrowError){hasRethrowError=true;rethrowError=error;}}}/**\n * During execution of guarded functions we will capture the first error which\n * we will rethrow to be handled by the top level error handler.\n */function rethrowCaughtError(){if(hasRethrowError){var error=rethrowError;hasRethrowError=false;rethrowError=null;throw error;}}function hasCaughtError(){return hasError;}function clearCaughtError(){if(hasError){var error=caughtError;hasError=false;caughtError=null;return error;}else{throw new Error('clearCaughtError was called but no error was captured. This error '+'is likely caused by a bug in React. Please file an issue.');}}/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */function get(key){return key._reactInternals;}function has(key){return key._reactInternals!==undefined;}function set(key,value){key._reactInternals=value;}// Don't change these two values. They're used by React Dev Tools.\nvar NoFlags=/*                      */0;var PerformedWork=/*                */1;// You can change the rest (and add more).\nvar Placement=/*                    */2;var Update=/*                       */4;var PlacementAndUpdate=/*           */Placement|Update;var ChildDeletion=/*                */16;var ContentReset=/*                 */32;var Callback=/*                     */64;var DidCapture=/*                   */128;var ForceClientRender=/*            */256;var Ref=/*                          */512;var Snapshot=/*                     */1024;var Passive=/*                      */2048;var Hydrating=/*                    */4096;var HydratingAndUpdate=/*           */Hydrating|Update;var Visibility=/*                   */8192;var StoreConsistency=/*             */16384;var LifecycleEffectMask=Passive|Update|Callback|Ref|Snapshot|StoreConsistency;// Union of all commit flags (flags with the lifetime of a particular commit)\nvar HostEffectMask=/*               */32767;// These are not really side effects, but we still reuse this field.\nvar Incomplete=/*                   */32768;var ShouldCapture=/*                */65536;var ForceUpdateForLegacySuspense=/* */131072;var Forked=/*                       */1048576;// Static tags describe aspects of a fiber that are not specific to a render,\n// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n// This enables us to defer more work in the unmount case,\n// since we can defer traversing the tree during layout to look for Passive effects,\n// and instead rely on the static flag as a signal that there may be cleanup work.\nvar RefStatic=/*                    */2097152;var LayoutStatic=/*                 */4194304;var PassiveStatic=/*                */8388608;// These flags allow us to traverse to fibers that have effects on mount\n// without traversing the entire tree after every commit for\n// double invoking\nvar MountLayoutDev=/*               */16777216;var MountPassiveDev=/*              */33554432;// Groups of flags that are used in the commit phase to skip over trees that\n// don't contain effects, by checking subtreeFlags.\nvar BeforeMutationMask=// TODO: Remove Update flag from before mutation phase by re-landing Visibility\n// flag logic (see #20043)\nUpdate|Snapshot|0;var MutationMask=Placement|Update|ChildDeletion|ContentReset|Ref|Hydrating|Visibility;var LayoutMask=Update|Callback|Ref|Visibility;// TODO: Split into PassiveMountMask and PassiveUnmountMask\nvar PassiveMask=Passive|ChildDeletion;// Union of tags that don't get reset on clones.\n// This allows certain concepts to persist without recalculating them,\n// e.g. whether a subtree contains passive effects or portals.\nvar StaticMask=LayoutStatic|PassiveStatic|RefStatic;var ReactCurrentOwner=ReactSharedInternals.ReactCurrentOwner;function getNearestMountedFiber(fiber){var node=fiber;var nearestMounted=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted\n// yet. If it is, then it will have a pending insertion effect on it.\nvar nextNode=node;do{node=nextNode;if((node.flags&(Placement|Hydrating))!==NoFlags){// This is an insertion or in-progress hydration. The nearest possible\n// mounted fiber is the parent but we need to continue to figure out\n// if that one is still mounted.\nnearestMounted=node[\"return\"];}nextNode=node[\"return\"];}while(nextNode);}else{while(node[\"return\"]){node=node[\"return\"];}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with\n// renderContainerIntoSubtree.\nreturn nearestMounted;}// If we didn't hit the root, that means that we're in an disconnected tree\n// that has been unmounted.\nreturn null;}function getSuspenseInstanceFromFiber(fiber){if(fiber.tag===SuspenseComponent){var suspenseState=fiber.memoizedState;if(suspenseState===null){var current=fiber.alternate;if(current!==null){suspenseState=current.memoizedState;}}if(suspenseState!==null){return suspenseState.dehydrated;}}return null;}function getContainerFromFiber(fiber){return fiber.tag===HostRoot?fiber.stateNode.containerInfo:null;}function isFiberMounted(fiber){return getNearestMountedFiber(fiber)===fiber;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;if(!instance._warnedAboutRefsInRender){error('%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromFiber(ownerFiber)||'A component');}instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return getNearestMountedFiber(fiber)===fiber;}function assertIsMounted(fiber){if(getNearestMountedFiber(fiber)!==fiber){throw new Error('Unable to find node on an unmounted component.');}}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.\nvar nearestMounted=getNearestMountedFiber(fiber);if(nearestMounted===null){throw new Error('Unable to find node on an unmounted component.');}if(nearestMounted!==fiber){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root\n// to see what path the root points to. On the way we may hit one of the\n// special cases and we'll deal with them.\nvar a=fiber;var b=alternate;while(true){var parentA=a[\"return\"];if(parentA===null){// We're at the root.\nbreak;}var parentB=parentA.alternate;if(parentB===null){// There is no alternate. This is an unusual case. Currently, it only\n// happens when a Suspense component is hidden. An extra fragment fiber\n// is inserted in between the Suspense fiber and its children. Skip\n// over this extra fragment fiber and proceed to the next parent.\nvar nextParent=parentA[\"return\"];if(nextParent!==null){a=b=nextParent;continue;}// If there's no parent, we're at the root.\nbreak;}// If both copies of the parent fiber point to the same child, we can\n// assume that the child is current. This happens when we bailout on low\n// priority: the bailed out fiber's child reuses the current child.\nif(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.\nassertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.\nassertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only\n// way this could possibly happen is if this was unmounted, if at all.\nthrow new Error('Unable to find node on an unmounted component.');}if(a[\"return\"]!==b[\"return\"]){// The return pointer of A and the return pointer of B point to different\n// fibers. We assume that return pointers never criss-cross, so A must\n// belong to the child set of A.return, and B must belong to the child\n// set of B.return.\na=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the\n// default, slow path: scan the child sets of each parent alternate to see\n// which child belongs to which set.\n//\n// Search parent A's child set\nvar didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set\n_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}if(!didFindChild){throw new Error('Child was not found in either parent set. This indicates a bug '+'in React related to the return pointer. Please file an issue.');}}}if(a.alternate!==b){throw new Error(\"Return fibers should always be each others' alternates. \"+'This error is likely caused by a bug in React. Please file an issue.');}}// If the root is not a host container, we're in a disconnected tree. I.e.\n// unmounted.\nif(a.tag!==HostRoot){throw new Error('Unable to find node on an unmounted component.');}if(a.stateNode.current===a){// We've determined that A is the current branch.\nreturn fiber;}// Otherwise B has to be current branch.\nreturn alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberImpl(currentParent):null;}function findCurrentHostFiberImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.\nif(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){var match=findCurrentHostFiberImpl(child);if(match!==null){return match;}child=child.sibling;}return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberWithNoPortalsImpl(currentParent):null;}function findCurrentHostFiberWithNoPortalsImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.\nif(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){if(child.tag!==HostPortal){var match=findCurrentHostFiberWithNoPortalsImpl(child);if(match!==null){return match;}}child=child.sibling;}return null;}// This module only exists as an ESM wrapper around the external CommonJS\nvar scheduleCallback=Scheduler.unstable_scheduleCallback;var cancelCallback=Scheduler.unstable_cancelCallback;var shouldYield=Scheduler.unstable_shouldYield;var requestPaint=Scheduler.unstable_requestPaint;var now=Scheduler.unstable_now;var getCurrentPriorityLevel=Scheduler.unstable_getCurrentPriorityLevel;var ImmediatePriority=Scheduler.unstable_ImmediatePriority;var UserBlockingPriority=Scheduler.unstable_UserBlockingPriority;var NormalPriority=Scheduler.unstable_NormalPriority;var LowPriority=Scheduler.unstable_LowPriority;var IdlePriority=Scheduler.unstable_IdlePriority;// this doesn't actually exist on the scheduler, but it *does*\n// on scheduler/unstable_mock, which we'll need for internal testing\nvar unstable_yieldValue=Scheduler.unstable_yieldValue;var unstable_setDisableYieldValue=Scheduler.unstable_setDisableYieldValue;var rendererID=null;var injectedHook=null;var injectedProfilingHooks=null;var hasLoggedError=false;var isDevToolsPresent=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined';function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools\nreturn false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out\n// of DevTools integration and associated warnings and logs.\n// https://github.com/facebook/react/issues/3877\nreturn true;}if(!hook.supportsFiber){{error('The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://reactjs.org/link/react-devtools');}// DevTools exists, even though it doesn't support Fiber.\nreturn true;}try{if(enableSchedulingProfiler){// Conditionally inject these hooks only if Timeline profiler is supported by this build.\n// This gives DevTools a way to feature detect that isn't tied to version number\n// (since profiling and timeline are controlled by different feature flags).\ninternals=assign({},internals,{getLaneLabelMap:getLaneLabelMap,injectProfilingHooks:injectProfilingHooks});}rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.\ninjectedHook=hook;}catch(err){// Catch all errors because it is unsafe to throw during initialization.\n{error('React instrumentation encountered an error: %s.',err);}}if(hook.checkDCE){// This is the real DevTools.\nreturn true;}else{// This is likely a hook installed by Fast Refresh runtime.\nreturn false;}}function onScheduleRoot(root,children){{if(injectedHook&&typeof injectedHook.onScheduleFiberRoot==='function'){try{injectedHook.onScheduleFiberRoot(rendererID,root,children);}catch(err){if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitRoot(root,eventPriority){if(injectedHook&&typeof injectedHook.onCommitFiberRoot==='function'){try{var didError=(root.current.flags&DidCapture)===DidCapture;if(enableProfilerTimer){var schedulerPriority;switch(eventPriority){case DiscreteEventPriority:schedulerPriority=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriority=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriority=NormalPriority;break;case IdleEventPriority:schedulerPriority=IdlePriority;break;default:schedulerPriority=NormalPriority;break;}injectedHook.onCommitFiberRoot(rendererID,root,schedulerPriority,didError);}else{injectedHook.onCommitFiberRoot(rendererID,root,undefined,didError);}}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onPostCommitRoot(root){if(injectedHook&&typeof injectedHook.onPostCommitFiberRoot==='function'){try{injectedHook.onPostCommitFiberRoot(rendererID,root);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitUnmount(fiber){if(injectedHook&&typeof injectedHook.onCommitFiberUnmount==='function'){try{injectedHook.onCommitFiberUnmount(rendererID,fiber);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function setIsStrictModeForDevtools(newIsStrictMode){{if(typeof unstable_yieldValue==='function'){// We're in a test because Scheduler.unstable_yieldValue only exists\n// in SchedulerMock. To reduce the noise in strict mode tests,\n// suppress warnings and disable scheduler yielding during the double render\nunstable_setDisableYieldValue(newIsStrictMode);setSuppressWarning(newIsStrictMode);}if(injectedHook&&typeof injectedHook.setStrictMode==='function'){try{injectedHook.setStrictMode(rendererID,newIsStrictMode);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}}// Profiler API hooks\nfunction injectProfilingHooks(profilingHooks){injectedProfilingHooks=profilingHooks;}function getLaneLabelMap(){{var map=new Map();var lane=1;for(var index=0;index<TotalLanes;index++){var label=getLabelForLane(lane);map.set(lane,label);lane*=2;}return map;}}function markCommitStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStarted==='function'){injectedProfilingHooks.markCommitStarted(lanes);}}}function markCommitStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStopped==='function'){injectedProfilingHooks.markCommitStopped();}}}function markComponentRenderStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStarted==='function'){injectedProfilingHooks.markComponentRenderStarted(fiber);}}}function markComponentRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStopped==='function'){injectedProfilingHooks.markComponentRenderStopped();}}}function markComponentPassiveEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);}}}function markComponentPassiveEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStopped();}}}function markComponentPassiveEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);}}}function markComponentPassiveEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();}}}function markComponentLayoutEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);}}}function markComponentLayoutEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStopped();}}}function markComponentLayoutEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);}}}function markComponentLayoutEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();}}}function markComponentErrored(fiber,thrownValue,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentErrored==='function'){injectedProfilingHooks.markComponentErrored(fiber,thrownValue,lanes);}}}function markComponentSuspended(fiber,wakeable,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentSuspended==='function'){injectedProfilingHooks.markComponentSuspended(fiber,wakeable,lanes);}}}function markLayoutEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStarted==='function'){injectedProfilingHooks.markLayoutEffectsStarted(lanes);}}}function markLayoutEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStopped==='function'){injectedProfilingHooks.markLayoutEffectsStopped();}}}function markPassiveEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStarted==='function'){injectedProfilingHooks.markPassiveEffectsStarted(lanes);}}}function markPassiveEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStopped==='function'){injectedProfilingHooks.markPassiveEffectsStopped();}}}function markRenderStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStarted==='function'){injectedProfilingHooks.markRenderStarted(lanes);}}}function markRenderYielded(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderYielded==='function'){injectedProfilingHooks.markRenderYielded();}}}function markRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStopped==='function'){injectedProfilingHooks.markRenderStopped();}}}function markRenderScheduled(lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderScheduled==='function'){injectedProfilingHooks.markRenderScheduled(lane);}}}function markForceUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markForceUpdateScheduled==='function'){injectedProfilingHooks.markForceUpdateScheduled(fiber,lane);}}}function markStateUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markStateUpdateScheduled==='function'){injectedProfilingHooks.markStateUpdateScheduled(fiber,lane);}}}var NoMode=/*                         */0;// TODO: Remove ConcurrentMode by reading from the root tag instead\nvar ConcurrentMode=/*                 */1;var ProfileMode=/*                    */2;var StrictLegacyMode=/*               */8;var StrictEffectsMode=/*              */16;// TODO: This is pretty well supported by browsers. Maybe we can drop it.\nvar clz32=Math.clz32?Math.clz32:clz32Fallback;// Count leading zeros.\n// Based on:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\nvar log=Math.log;var LN2=Math.LN2;function clz32Fallback(x){var asUint=x>>>0;if(asUint===0){return 32;}return 31-(log(asUint)/LN2|0)|0;}// If those values are changed that package should be rebuilt and redeployed.\nvar TotalLanes=31;var NoLanes=/*                        */0;var NoLane=/*                          */0;var SyncLane=/*                        */1;var InputContinuousHydrationLane=/*    */2;var InputContinuousLane=/*            */4;var DefaultHydrationLane=/*            */8;var DefaultLane=/*                    */16;var TransitionHydrationLane=/*                */32;var TransitionLanes=/*                       */4194240;var TransitionLane1=/*                        */64;var TransitionLane2=/*                        */128;var TransitionLane3=/*                        */256;var TransitionLane4=/*                        */512;var TransitionLane5=/*                        */1024;var TransitionLane6=/*                        */2048;var TransitionLane7=/*                        */4096;var TransitionLane8=/*                        */8192;var TransitionLane9=/*                        */16384;var TransitionLane10=/*                       */32768;var TransitionLane11=/*                       */65536;var TransitionLane12=/*                       */131072;var TransitionLane13=/*                       */262144;var TransitionLane14=/*                       */524288;var TransitionLane15=/*                       */1048576;var TransitionLane16=/*                       */2097152;var RetryLanes=/*                            */130023424;var RetryLane1=/*                             */4194304;var RetryLane2=/*                             */8388608;var RetryLane3=/*                             */16777216;var RetryLane4=/*                             */33554432;var RetryLane5=/*                             */67108864;var SomeRetryLane=RetryLane1;var SelectiveHydrationLane=/*          */134217728;var NonIdleLanes=/*                                 */268435455;var IdleHydrationLane=/*               */268435456;var IdleLane=/*                       */536870912;var OffscreenLane=/*                   */1073741824;// This function is used for the experimental timeline (react-devtools-timeline)\n// It should be kept in sync with the Lanes values above.\nfunction getLabelForLane(lane){{if(lane&SyncLane){return'Sync';}if(lane&InputContinuousHydrationLane){return'InputContinuousHydration';}if(lane&InputContinuousLane){return'InputContinuous';}if(lane&DefaultHydrationLane){return'DefaultHydration';}if(lane&DefaultLane){return'Default';}if(lane&TransitionHydrationLane){return'TransitionHydration';}if(lane&TransitionLanes){return'Transition';}if(lane&RetryLanes){return'Retry';}if(lane&SelectiveHydrationLane){return'SelectiveHydration';}if(lane&IdleHydrationLane){return'IdleHydration';}if(lane&IdleLane){return'Idle';}if(lane&OffscreenLane){return'Offscreen';}}}var NoTimestamp=-1;var nextTransitionLane=TransitionLane1;var nextRetryLane=RetryLane1;function getHighestPriorityLanes(lanes){switch(getHighestPriorityLane(lanes)){case SyncLane:return SyncLane;case InputContinuousHydrationLane:return InputContinuousHydrationLane;case InputContinuousLane:return InputContinuousLane;case DefaultHydrationLane:return DefaultHydrationLane;case DefaultLane:return DefaultLane;case TransitionHydrationLane:return TransitionHydrationLane;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return lanes&TransitionLanes;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:return lanes&RetryLanes;case SelectiveHydrationLane:return SelectiveHydrationLane;case IdleHydrationLane:return IdleHydrationLane;case IdleLane:return IdleLane;case OffscreenLane:return OffscreenLane;default:{error('Should have found matching lanes. This is a bug in React.');}// This shouldn't be reachable, but as a fallback, return the entire bitmask.\nreturn lanes;}}function getNextLanes(root,wipLanes){// Early bailout if there's no pending work left.\nvar pendingLanes=root.pendingLanes;if(pendingLanes===NoLanes){return NoLanes;}var nextLanes=NoLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;// Do not work on any idle work until all the non-idle work has finished,\n// even if the work is suspended.\nvar nonIdlePendingLanes=pendingLanes&NonIdleLanes;if(nonIdlePendingLanes!==NoLanes){var nonIdleUnblockedLanes=nonIdlePendingLanes&~suspendedLanes;if(nonIdleUnblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdleUnblockedLanes);}else{var nonIdlePingedLanes=nonIdlePendingLanes&pingedLanes;if(nonIdlePingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdlePingedLanes);}}}else{// The only remaining work is Idle.\nvar unblockedLanes=pendingLanes&~suspendedLanes;if(unblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(unblockedLanes);}else{if(pingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(pingedLanes);}}}if(nextLanes===NoLanes){// This should only be reachable if we're suspended\n// TODO: Consider warning in this path if a fallback timer is not scheduled.\nreturn NoLanes;}// If we're already in the middle of a render, switching lanes will interrupt\n// it and we'll lose our progress. We should only do this if the new lanes are\n// higher priority.\nif(wipLanes!==NoLanes&&wipLanes!==nextLanes&&// If we already suspended with a delay, then interrupting is fine. Don't\n// bother waiting until the root is complete.\n(wipLanes&suspendedLanes)===NoLanes){var nextLane=getHighestPriorityLane(nextLanes);var wipLane=getHighestPriorityLane(wipLanes);if(// Tests whether the next lane is equal or lower priority than the wip\n// one. This works because the bits decrease in priority as you go left.\nnextLane>=wipLane||// Default priority updates should not interrupt transition updates. The\n// only difference between default updates and transition updates is that\n// default updates do not support refresh transitions.\nnextLane===DefaultLane&&(wipLane&TransitionLanes)!==NoLanes){// Keep working on the existing in-progress tree. Do not interrupt.\nreturn wipLanes;}}if((nextLanes&InputContinuousLane)!==NoLanes){// When updates are sync by default, we entangle continuous priority updates\n// and default updates, so they render in the same batch. The only reason\n// they use separate lanes is because continuous updates should interrupt\n// transitions, but default updates should not.\nnextLanes|=pendingLanes&DefaultLane;}// Check for entangled lanes and add them to the batch.\n//\n// A lane is said to be entangled with another when it's not allowed to render\n// in a batch that does not also include the other lane. Typically we do this\n// when multiple updates have the same source, and we only want to respond to\n// the most recent event from that source.\n//\n// Note that we apply entanglements *after* checking for partial work above.\n// This means that if a lane is entangled during an interleaved event while\n// it's already rendering, we won't interrupt it. This is intentional, since\n// entanglement is usually \"best effort\": we'll try our best to render the\n// lanes in the same batch, but it's not worth throwing out partially\n// completed work in order to do it.\n// TODO: Reconsider this. The counter-argument is that the partial work\n// represents an intermediate state, which we don't want to show to the user.\n// And by spending extra time finishing it, we're increasing the amount of\n// time it takes to show the final state, which is what they are actually\n// waiting for.\n//\n// For those exceptions where entanglement is semantically important, like\n// useMutableSource, we should ensure that there is no partial work at the\n// time we apply the entanglement.\nvar entangledLanes=root.entangledLanes;if(entangledLanes!==NoLanes){var entanglements=root.entanglements;var lanes=nextLanes&entangledLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;nextLanes|=entanglements[index];lanes&=~lane;}}return nextLanes;}function getMostRecentEventTime(root,lanes){var eventTimes=root.eventTimes;var mostRecentEventTime=NoTimestamp;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var eventTime=eventTimes[index];if(eventTime>mostRecentEventTime){mostRecentEventTime=eventTime;}lanes&=~lane;}return mostRecentEventTime;}function computeExpirationTime(lane,currentTime){switch(lane){case SyncLane:case InputContinuousHydrationLane:case InputContinuousLane:// User interactions should expire slightly more quickly.\n//\n// NOTE: This is set to the corresponding constant as in Scheduler.js.\n// When we made it larger, a product metric in www regressed, suggesting\n// there's a user interaction that's being starved by a series of\n// synchronous updates. If that theory is correct, the proper solution is\n// to fix the starvation. However, this scenario supports the idea that\n// expiration times are an important safeguard when starvation\n// does happen.\nreturn currentTime+250;case DefaultHydrationLane:case DefaultLane:case TransitionHydrationLane:case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return currentTime+5000;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:// TODO: Retries should be allowed to expire if they are CPU bound for\n// too long, but when I made this change it caused a spike in browser\n// crashes. There must be some other underlying bug; not super urgent but\n// ideally should figure out why and fix it. Unfortunately we don't have\n// a repro for the crashes, only detected via production metrics.\nreturn NoTimestamp;case SelectiveHydrationLane:case IdleHydrationLane:case IdleLane:case OffscreenLane:// Anything idle priority or lower should never expire.\nreturn NoTimestamp;default:{error('Should have found matching lanes. This is a bug in React.');}return NoTimestamp;}}function markStarvedLanesAsExpired(root,currentTime){// TODO: This gets called every time we yield. We can optimize by storing\n// the earliest expiration time on the root. Then use that to quickly bail out\n// of this function.\nvar pendingLanes=root.pendingLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;var expirationTimes=root.expirationTimes;// Iterate through the pending lanes and check if we've reached their\n// expiration time. If so, we'll assume the update is being starved and mark\n// it as expired to force it to finish.\nvar lanes=pendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var expirationTime=expirationTimes[index];if(expirationTime===NoTimestamp){// Found a pending lane with no expiration time. If it's not suspended, or\n// if it's pinged, assume it's CPU-bound. Compute a new expiration time\n// using the current time.\nif((lane&suspendedLanes)===NoLanes||(lane&pingedLanes)!==NoLanes){// Assumes timestamps are monotonically increasing.\nexpirationTimes[index]=computeExpirationTime(lane,currentTime);}}else if(expirationTime<=currentTime){// This lane expired\nroot.expiredLanes|=lane;}lanes&=~lane;}}// This returns the highest priority pending lanes regardless of whether they\n// are suspended.\nfunction getHighestPriorityPendingLanes(root){return getHighestPriorityLanes(root.pendingLanes);}function getLanesToRetrySynchronouslyOnError(root){var everythingButOffscreen=root.pendingLanes&~OffscreenLane;if(everythingButOffscreen!==NoLanes){return everythingButOffscreen;}if(everythingButOffscreen&OffscreenLane){return OffscreenLane;}return NoLanes;}function includesSyncLane(lanes){return(lanes&SyncLane)!==NoLanes;}function includesNonIdleWork(lanes){return(lanes&NonIdleLanes)!==NoLanes;}function includesOnlyRetries(lanes){return(lanes&RetryLanes)===lanes;}function includesOnlyTransitions(lanes){return(lanes&TransitionLanes)===lanes;}function includesBlockingLane(root,lanes){var SyncDefaultLanes=InputContinuousHydrationLane|InputContinuousLane|DefaultHydrationLane|DefaultLane;return(lanes&SyncDefaultLanes)!==NoLanes;}function includesExpiredLane(root,lanes){// This is a separate check from includesBlockingLane because a lane can\n// expire after a render has already started.\nreturn(lanes&root.expiredLanes)!==NoLanes;}function isTransitionLane(lane){return(lane&TransitionLanes)!==0;}function claimNextTransitionLane(){// Cycle through the lanes, assigning each new transition to the next lane.\n// In most cases, this means every transition gets its own lane, until we\n// run out of lanes and cycle back to the beginning.\nvar lane=nextTransitionLane;nextTransitionLane<<=1;if((nextTransitionLane&TransitionLanes)===0){nextTransitionLane=TransitionLane1;}return lane;}function claimNextRetryLane(){var lane=nextRetryLane;nextRetryLane<<=1;if((nextRetryLane&RetryLanes)===0){nextRetryLane=RetryLane1;}return lane;}function getHighestPriorityLane(lanes){return lanes&-lanes;}function pickArbitraryLane(lanes){// This wrapper function gets inlined. Only exists so to communicate that it\n// doesn't matter which bit is selected; you can pick any bit without\n// affecting the algorithms where its used. Here I'm using\n// getHighestPriorityLane because it requires the fewest operations.\nreturn getHighestPriorityLane(lanes);}function pickArbitraryLaneIndex(lanes){return 31-clz32(lanes);}function laneToIndex(lane){return pickArbitraryLaneIndex(lane);}function includesSomeLane(a,b){return(a&b)!==NoLanes;}function isSubsetOfLanes(set,subset){return(set&subset)===subset;}function mergeLanes(a,b){return a|b;}function removeLanes(set,subset){return set&~subset;}function intersectLanes(a,b){return a&b;}// Seems redundant, but it changes the type from a single lane (used for\n// updates) to a group of lanes (used for flushing work).\nfunction laneToLanes(lane){return lane;}function higherPriorityLane(a,b){// This works because the bit ranges decrease in priority as you go left.\nreturn a!==NoLane&&a<b?a:b;}function createLaneMap(initial){// Intentionally pushing one by one.\n// https://v8.dev/blog/elements-kinds#avoid-creating-holes\nvar laneMap=[];for(var i=0;i<TotalLanes;i++){laneMap.push(initial);}return laneMap;}function markRootUpdated(root,updateLane,eventTime){root.pendingLanes|=updateLane;// If there are any suspended transitions, it's possible this new update\n// could unblock them. Clear the suspended lanes so that we can try rendering\n// them again.\n//\n// TODO: We really only need to unsuspend only lanes that are in the\n// `subtreeLanes` of the updated fiber, or the update lanes of the return\n// path. This would exclude suspended updates in an unrelated sibling tree,\n// since there's no way for this update to unblock it.\n//\n// We don't do this if the incoming update is idle, because we never process\n// idle updates until after all the regular updates have finished; there's no\n// way it could unblock a transition.\nif(updateLane!==IdleLane){root.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;}var eventTimes=root.eventTimes;var index=laneToIndex(updateLane);// We can always overwrite an existing timestamp because we prefer the most\n// recent event, and we assume time is monotonically increasing.\neventTimes[index]=eventTime;}function markRootSuspended(root,suspendedLanes){root.suspendedLanes|=suspendedLanes;root.pingedLanes&=~suspendedLanes;// The suspended lanes are no longer CPU-bound. Clear their expiration times.\nvar expirationTimes=root.expirationTimes;var lanes=suspendedLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootPinged(root,pingedLanes,eventTime){root.pingedLanes|=root.suspendedLanes&pingedLanes;}function markRootFinished(root,remainingLanes){var noLongerPendingLanes=root.pendingLanes&~remainingLanes;root.pendingLanes=remainingLanes;// Let's try everything again\nroot.suspendedLanes=0;root.pingedLanes=0;root.expiredLanes&=remainingLanes;root.mutableReadLanes&=remainingLanes;root.entangledLanes&=remainingLanes;var entanglements=root.entanglements;var eventTimes=root.eventTimes;var expirationTimes=root.expirationTimes;// Clear the lanes that no longer have pending work\nvar lanes=noLongerPendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;entanglements[index]=NoLanes;eventTimes[index]=NoTimestamp;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootEntangled(root,entangledLanes){// In addition to entangling each of the given lanes with each other, we also\n// have to consider _transitive_ entanglements. For each lane that is already\n// entangled with *any* of the given lanes, that lane is now transitively\n// entangled with *all* the given lanes.\n//\n// Translated: If C is entangled with A, then entangling A with B also\n// entangles C with B.\n//\n// If this is hard to grasp, it might help to intentionally break this\n// function and look at the tests that fail in ReactTransition-test.js. Try\n// commenting out one of the conditions below.\nvar rootEntangledLanes=root.entangledLanes|=entangledLanes;var entanglements=root.entanglements;var lanes=rootEntangledLanes;while(lanes){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;if(// Is this one of the newly entangled lanes?\nlane&entangledLanes|// Is this lane transitively entangled with the newly entangled lanes?\nentanglements[index]&entangledLanes){entanglements[index]|=entangledLanes;}lanes&=~lane;}}function getBumpedLaneForHydration(root,renderLanes){var renderLane=getHighestPriorityLane(renderLanes);var lane;switch(renderLane){case InputContinuousLane:lane=InputContinuousHydrationLane;break;case DefaultLane:lane=DefaultHydrationLane;break;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:lane=TransitionHydrationLane;break;case IdleLane:lane=IdleHydrationLane;break;default:// Everything else is already either a hydration lane, or shouldn't\n// be retried at a hydration lane.\nlane=NoLane;break;}// Check if the lane we chose is suspended. If so, that indicates that we\n// already attempted and failed to hydrate at that level. Also check if we're\n// already rendering that lane, which is rare but could happen.\nif((lane&(root.suspendedLanes|renderLanes))!==NoLane){// Give up trying to hydrate and fall back to client render.\nreturn NoLane;}return lane;}function addFiberToLanesMap(root,fiber,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];updaters.add(fiber);lanes&=~lane;}}function movePendingFibersToMemoized(root,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;var memoizedUpdaters=root.memoizedUpdaters;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];if(updaters.size>0){updaters.forEach(function(fiber){var alternate=fiber.alternate;if(alternate===null||!memoizedUpdaters.has(alternate)){memoizedUpdaters.add(fiber);}});updaters.clear();}lanes&=~lane;}}var DiscreteEventPriority=SyncLane;var ContinuousEventPriority=InputContinuousLane;var DefaultEventPriority=DefaultLane;var IdleEventPriority=IdleLane;var currentUpdatePriority=NoLane;function getCurrentUpdatePriority(){return currentUpdatePriority;}function setCurrentUpdatePriority(newPriority){currentUpdatePriority=newPriority;}function runWithPriority(priority,fn){var previousPriority=currentUpdatePriority;try{currentUpdatePriority=priority;return fn();}finally{currentUpdatePriority=previousPriority;}}function higherEventPriority(a,b){return a!==0&&a<b?a:b;}function lowerEventPriority(a,b){return a===0||a>b?a:b;}function isHigherEventPriority(a,b){return a!==0&&a<b;}function lanesToEventPriority(lanes){var lane=getHighestPriorityLane(lanes);if(!isHigherEventPriority(DiscreteEventPriority,lane)){return DiscreteEventPriority;}if(!isHigherEventPriority(ContinuousEventPriority,lane)){return ContinuousEventPriority;}if(includesNonIdleWork(lane)){return DefaultEventPriority;}return IdleEventPriority;}// This is imported by the event replaying implementation in React DOM. It's\n// in a separate file to break a circular dependency between the renderer and\n// the reconciler.\nfunction isRootDehydrated(root){var currentState=root.current.memoizedState;return currentState.isDehydrated;}var _attemptSynchronousHydration;function setAttemptSynchronousHydration(fn){_attemptSynchronousHydration=fn;}function attemptSynchronousHydration(fiber){_attemptSynchronousHydration(fiber);}var attemptContinuousHydration;function setAttemptContinuousHydration(fn){attemptContinuousHydration=fn;}var attemptHydrationAtCurrentPriority;function setAttemptHydrationAtCurrentPriority(fn){attemptHydrationAtCurrentPriority=fn;}var getCurrentUpdatePriority$1;function setGetCurrentUpdatePriority(fn){getCurrentUpdatePriority$1=fn;}var attemptHydrationAtPriority;function setAttemptHydrationAtPriority(fn){attemptHydrationAtPriority=fn;}// TODO: Upgrade this definition once we're on a newer version of Flow that\n// has this definition built-in.\nvar hasScheduledReplayAttempt=false;// The queue of discrete events to be replayed.\nvar queuedDiscreteEvents=[];// Indicates if any continuous event targets are non-null for early bailout.\n// if the last target was dehydrated.\nvar queuedFocus=null;var queuedDrag=null;var queuedMouse=null;// For pointer events there can be one latest event per pointerId.\nvar queuedPointers=new Map();var queuedPointerCaptures=new Map();// We could consider replaying selectionchange and touchmoves too.\nvar queuedExplicitHydrationTargets=[];var synchronouslyHydratedEvents=['mousedown','mouseup','touchcancel','touchend','touchstart','auxclick','dblclick','pointercancel','pointerdown','pointerup','dragend','dragstart','drop','compositionend','compositionstart','keydown','keypress','keyup','input','textInput',// Intentionally camelCase\n'copy','cut','paste','click','change','contextmenu','reset','submit'];function isDiscreteEventThatRequiresHydration(eventType){return synchronouslyHydratedEvents.indexOf(eventType)>-1;}function createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){return{blockedOn:blockedOn,domEventName:domEventName,eventSystemFlags:eventSystemFlags,nativeEvent:nativeEvent,targetContainers:[targetContainer]};}// Resets the replaying for this type of continuous event to no event.\nfunction clearIfContinuousEvent(domEventName,nativeEvent){switch(domEventName){case'focusin':case'focusout':queuedFocus=null;break;case'dragenter':case'dragleave':queuedDrag=null;break;case'mouseover':case'mouseout':queuedMouse=null;break;case'pointerover':case'pointerout':{var pointerId=nativeEvent.pointerId;queuedPointers[\"delete\"](pointerId);break;}case'gotpointercapture':case'lostpointercapture':{var _pointerId=nativeEvent.pointerId;queuedPointerCaptures[\"delete\"](_pointerId);break;}}}function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent,blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){if(existingQueuedEvent===null||existingQueuedEvent.nativeEvent!==nativeEvent){var queuedEvent=createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn!==null){var _fiber=getInstanceFromNode(blockedOn);if(_fiber!==null){// Attempt to increase the priority of this target.\nattemptContinuousHydration(_fiber);}}return queuedEvent;}// If we have already queued this exact event, then it's because\n// the different event systems have different DOM event listeners.\n// We can accumulate the flags, and the targetContainers, and\n// store a single event to be replayed.\nexistingQueuedEvent.eventSystemFlags|=eventSystemFlags;var targetContainers=existingQueuedEvent.targetContainers;if(targetContainer!==null&&targetContainers.indexOf(targetContainer)===-1){targetContainers.push(targetContainer);}return existingQueuedEvent;}function queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){// These set relatedTarget to null because the replayed event will be treated as if we\n// moved from outside the window (no target) onto the target once it hydrates.\n// Instead of mutating we could clone the event.\nswitch(domEventName){case'focusin':{var focusEvent=nativeEvent;queuedFocus=accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus,blockedOn,domEventName,eventSystemFlags,targetContainer,focusEvent);return true;}case'dragenter':{var dragEvent=nativeEvent;queuedDrag=accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag,blockedOn,domEventName,eventSystemFlags,targetContainer,dragEvent);return true;}case'mouseover':{var mouseEvent=nativeEvent;queuedMouse=accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse,blockedOn,domEventName,eventSystemFlags,targetContainer,mouseEvent);return true;}case'pointerover':{var pointerEvent=nativeEvent;var pointerId=pointerEvent.pointerId;queuedPointers.set(pointerId,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,pointerEvent));return true;}case'gotpointercapture':{var _pointerEvent=nativeEvent;var _pointerId2=_pointerEvent.pointerId;queuedPointerCaptures.set(_pointerId2,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,_pointerEvent));return true;}}return false;}// Check if this target is unblocked. Returns true if it's unblocked.\nfunction attemptExplicitHydrationTarget(queuedTarget){// TODO: This function shares a lot of logic with findInstanceBlockingEvent.\n// Try to unify them. It's a bit tricky since it would require two return\n// values.\nvar targetInst=getClosestInstanceFromNode(queuedTarget.target);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted!==null){var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// We're blocked on hydrating this boundary.\n// Increase its priority.\nqueuedTarget.blockedOn=instance;attemptHydrationAtPriority(queuedTarget.priority,function(){attemptHydrationAtCurrentPriority(nearestMounted);});return;}}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){queuedTarget.blockedOn=getContainerFromFiber(nearestMounted);// We don't currently have a way to increase the priority of\n// a root other than sync.\nreturn;}}}}queuedTarget.blockedOn=null;}function queueExplicitHydrationTarget(target){{// TODO: This will read the priority if it's dispatched by the React\n// event system but not native events. Should read window.event.type, like\n// we do for updates (getCurrentEventPriority).\nvar updatePriority=getCurrentUpdatePriority$1();var queuedTarget={blockedOn:null,target:target,priority:updatePriority};var i=0;for(;i<queuedExplicitHydrationTargets.length;i++){// Stop once we hit the first target with lower priority than\nif(!isHigherEventPriority(updatePriority,queuedExplicitHydrationTargets[i].priority)){break;}}queuedExplicitHydrationTargets.splice(i,0,queuedTarget);if(i===0){attemptExplicitHydrationTarget(queuedTarget);}}}function attemptReplayContinuousQueuedEvent(queuedEvent){if(queuedEvent.blockedOn!==null){return false;}var targetContainers=queuedEvent.targetContainers;while(targetContainers.length>0){var targetContainer=targetContainers[0];var nextBlockedOn=findInstanceBlockingEvent(queuedEvent.domEventName,queuedEvent.eventSystemFlags,targetContainer,queuedEvent.nativeEvent);if(nextBlockedOn===null){var nativeEvent=queuedEvent.nativeEvent;var nativeEventClone=new nativeEvent.constructor(nativeEvent.type,nativeEvent);setReplayingEvent(nativeEventClone);nativeEvent.target.dispatchEvent(nativeEventClone);resetReplayingEvent();}else{// We're still blocked. Try again later.\nvar _fiber2=getInstanceFromNode(nextBlockedOn);if(_fiber2!==null){attemptContinuousHydration(_fiber2);}queuedEvent.blockedOn=nextBlockedOn;return false;}// This target container was successfully dispatched. Try the next.\ntargetContainers.shift();}return true;}function attemptReplayContinuousQueuedEventInMap(queuedEvent,key,map){if(attemptReplayContinuousQueuedEvent(queuedEvent)){map[\"delete\"](key);}}function replayUnblockedEvents(){hasScheduledReplayAttempt=false;// Next replay any continuous events.\nif(queuedFocus!==null&&attemptReplayContinuousQueuedEvent(queuedFocus)){queuedFocus=null;}if(queuedDrag!==null&&attemptReplayContinuousQueuedEvent(queuedDrag)){queuedDrag=null;}if(queuedMouse!==null&&attemptReplayContinuousQueuedEvent(queuedMouse)){queuedMouse=null;}queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);}function scheduleCallbackIfUnblocked(queuedEvent,unblocked){if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;if(!hasScheduledReplayAttempt){hasScheduledReplayAttempt=true;// Schedule a callback to attempt replaying as many events as are\n// now unblocked. This first might not actually be unblocked yet.\n// We could check it early to avoid scheduling an unnecessary callback.\nScheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority,replayUnblockedEvents);}}}function retryIfBlockedOn(unblocked){// Mark anything that was blocked on this as no longer blocked\n// and eligible for a replay.\nif(queuedDiscreteEvents.length>0){scheduleCallbackIfUnblocked(queuedDiscreteEvents[0],unblocked);// This is a exponential search for each boundary that commits. I think it's\n// worth it because we expect very few discrete events to queue up and once\n// we are actually fully unblocked it will be fast to replay them.\nfor(var i=1;i<queuedDiscreteEvents.length;i++){var queuedEvent=queuedDiscreteEvents[i];if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;}}}if(queuedFocus!==null){scheduleCallbackIfUnblocked(queuedFocus,unblocked);}if(queuedDrag!==null){scheduleCallbackIfUnblocked(queuedDrag,unblocked);}if(queuedMouse!==null){scheduleCallbackIfUnblocked(queuedMouse,unblocked);}var unblock=function unblock(queuedEvent){return scheduleCallbackIfUnblocked(queuedEvent,unblocked);};queuedPointers.forEach(unblock);queuedPointerCaptures.forEach(unblock);for(var _i=0;_i<queuedExplicitHydrationTargets.length;_i++){var queuedTarget=queuedExplicitHydrationTargets[_i];if(queuedTarget.blockedOn===unblocked){queuedTarget.blockedOn=null;}}while(queuedExplicitHydrationTargets.length>0){var nextExplicitTarget=queuedExplicitHydrationTargets[0];if(nextExplicitTarget.blockedOn!==null){// We're still blocked.\nbreak;}else{attemptExplicitHydrationTarget(nextExplicitTarget);if(nextExplicitTarget.blockedOn===null){// We're unblocked.\nqueuedExplicitHydrationTargets.shift();}}}}var ReactCurrentBatchConfig=ReactSharedInternals.ReactCurrentBatchConfig;// TODO: can we stop exporting these?\nfunction createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags){var eventPriority=getEventPriority(domEventName);var listenerWrapper;switch(eventPriority){case DiscreteEventPriority:listenerWrapper=dispatchDiscreteEvent;break;case ContinuousEventPriority:listenerWrapper=dispatchContinuousEvent;break;case DefaultEventPriority:default:listenerWrapper=dispatchEvent;break;}return listenerWrapper.bind(null,domEventName,eventSystemFlags,targetContainer);}function dispatchDiscreteEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(DiscreteEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchContinuousEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(ContinuousEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){var blockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);clearIfContinuousEvent(domEventName,nativeEvent);return;}if(queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent)){nativeEvent.stopPropagation();return;}// We need to clear only if we didn't queue because\n// queueing is accumulative.\nclearIfContinuousEvent(domEventName,nativeEvent);if(eventSystemFlags&IS_CAPTURE_PHASE&&isDiscreteEventThatRequiresHydration(domEventName)){while(blockedOn!==null){var fiber=getInstanceFromNode(blockedOn);if(fiber!==null){attemptSynchronousHydration(fiber);}var nextBlockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(nextBlockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);}if(nextBlockedOn===blockedOn){break;}blockedOn=nextBlockedOn;}if(blockedOn!==null){nativeEvent.stopPropagation();}return;}// This is not replayable so we'll invoke it but without a target,\n// in case the event system needs to trace it.\ndispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,null,targetContainer);}var return_targetInst=null;// Returns a SuspenseInstance or Container if it's blocked.\n// The return_targetInst field above is conceptually part of the return value.\nfunction findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){// TODO: Warn if _enabled is false.\nreturn_targetInst=null;var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted===null){// This tree has been unmounted already. Dispatch without a target.\ntargetInst=null;}else{var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// Queue the event to be replayed later. Abort dispatching since we\n// don't want this event dispatched twice through the event system.\n// TODO: If this is the first discrete event in the queue. Schedule an increased\n// priority for this boundary.\nreturn instance;}// This shouldn't happen, something went wrong but to avoid blocking\n// the whole system, dispatch the event without a target.\n// TODO: Warn.\ntargetInst=null;}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){// If this happens during a replay something went wrong and it might block\n// the whole system.\nreturn getContainerFromFiber(nearestMounted);}targetInst=null;}else if(nearestMounted!==targetInst){// If we get an event (ex: img onload) before committing that\n// component's mount, ignore it for now (that is, treat it as if it was an\n// event on a non-React tree). We might also consider queueing events and\n// dispatching them after the mount.\ntargetInst=null;}}}return_targetInst=targetInst;// We're not blocked on anything.\nreturn null;}function getEventPriority(domEventName){switch(domEventName){// Used by SimpleEventPlugin:\ncase'cancel':case'click':case'close':case'contextmenu':case'copy':case'cut':case'auxclick':case'dblclick':case'dragend':case'dragstart':case'drop':case'focusin':case'focusout':case'input':case'invalid':case'keydown':case'keypress':case'keyup':case'mousedown':case'mouseup':case'paste':case'pause':case'play':case'pointercancel':case'pointerdown':case'pointerup':case'ratechange':case'reset':case'resize':case'seeked':case'submit':case'touchcancel':case'touchend':case'touchstart':case'volumechange':// Used by polyfills:\n// eslint-disable-next-line no-fallthrough\ncase'change':case'selectionchange':case'textInput':case'compositionstart':case'compositionend':case'compositionupdate':// Only enableCreateEventHandleAPI:\n// eslint-disable-next-line no-fallthrough\ncase'beforeblur':case'afterblur':// Not used by React but could be by user code:\n// eslint-disable-next-line no-fallthrough\ncase'beforeinput':case'blur':case'fullscreenchange':case'focus':case'hashchange':case'popstate':case'select':case'selectstart':return DiscreteEventPriority;case'drag':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'mousemove':case'mouseout':case'mouseover':case'pointermove':case'pointerout':case'pointerover':case'scroll':case'toggle':case'touchmove':case'wheel':// Not used by React but could be by user code:\n// eslint-disable-next-line no-fallthrough\ncase'mouseenter':case'mouseleave':case'pointerenter':case'pointerleave':return ContinuousEventPriority;case'message':{// We might be in the Scheduler callback.\n// Eventually this mechanism will be replaced by a check\n// of the current priority on the native scheduler.\nvar schedulerPriority=getCurrentPriorityLevel();switch(schedulerPriority){case ImmediatePriority:return DiscreteEventPriority;case UserBlockingPriority:return ContinuousEventPriority;case NormalPriority:case LowPriority:// TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.\nreturn DefaultEventPriority;case IdlePriority:return IdleEventPriority;default:return DefaultEventPriority;}}default:return DefaultEventPriority;}}function addEventBubbleListener(target,eventType,listener){target.addEventListener(eventType,listener,false);return listener;}function addEventCaptureListener(target,eventType,listener){target.addEventListener(eventType,listener,true);return listener;}function addEventCaptureListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{capture:true,passive:passive});return listener;}function addEventBubbleListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{passive:passive});return listener;}/**\n * These variables store information about text content of a target node,\n * allowing comparison of content before and after a given event.\n *\n * Identify the node where selection currently begins, then observe\n * both its text content and its current position in the DOM. Since the\n * browser may natively replace the target node during composition, we can\n * use its position to find its replacement.\n *\n *\n */var root=null;var startText=null;var fallbackText=null;function initialize(nativeEventTarget){root=nativeEventTarget;startText=getText();return true;}function reset(){root=null;startText=null;fallbackText=null;}function getData(){if(fallbackText){return fallbackText;}var start;var startValue=startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;fallbackText=endValue.slice(start,sliceTail);return fallbackText;}function getText(){if('value'in root){return root.value;}return root.textContent;}/**\n * `charCode` represents the actual \"character code\" and is safe to use with\n * `String.fromCharCode`. As such, only keys that correspond to printable\n * characters produce a valid `charCode`, the only exception to this is Enter.\n * The Tab-key is considered non-printable and does not have a `charCode`,\n * presumably because it does not produce a tab-character in browsers.\n *\n * @param {object} nativeEvent Native browser event.\n * @return {number} Normalized `charCode` property.\n */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.\nif(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.\ncharCode=keyCode;}// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)\n// report Enter as charCode 10 when ctrl is pressed.\nif(charCode===10){charCode=13;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n// Must not discard the (non-)printable Enter-key.\nif(charCode>=32||charCode===13){return charCode;}return 0;}function functionThatReturnsTrue(){return true;}function functionThatReturnsFalse(){return false;}// This is intentionally a factory so that we have different returned constructors.\n// If we had a single constructor, it would be megamorphic and engines would deopt.\nfunction createSyntheticEvent(Interface){/**\n   * Synthetic events are dispatched by event plugins, typically in response to a\n   * top-level event delegation handler.\n   *\n   * These systems should generally use pooling to reduce the frequency of garbage\n   * collection. The system should check `isPersistent` to determine whether the\n   * event should be released into the pool after being dispatched. Users that\n   * need a persisted event should invoke `persist`.\n   *\n   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n   * normalizing browser quirks. Subclasses do not necessarily have to implement a\n   * DOM interface; custom application-specific events can also subclass this.\n   */function SyntheticBaseEvent(reactName,reactEventType,targetInst,nativeEvent,nativeEventTarget){this._reactName=reactName;this._targetInst=targetInst;this.type=reactEventType;this.nativeEvent=nativeEvent;this.target=nativeEventTarget;this.currentTarget=null;for(var _propName in Interface){if(!Interface.hasOwnProperty(_propName)){continue;}var normalize=Interface[_propName];if(normalize){this[_propName]=normalize(nativeEvent);}else{this[_propName]=nativeEvent[_propName];}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=functionThatReturnsTrue;}else{this.isDefaultPrevented=functionThatReturnsFalse;}this.isPropagationStopped=functionThatReturnsFalse;return this;}assign(SyntheticBaseEvent.prototype,{preventDefault:function preventDefault(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();// $FlowFixMe - flow is not aware of `unknown` in IE\n}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=functionThatReturnsTrue;},stopPropagation:function stopPropagation(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();// $FlowFixMe - flow is not aware of `unknown` in IE\n}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a \"propertychange\" event for\n// IE. This event does not support bubbling or cancelling, and\n// any references to cancelBubble throw \"Member not found\".  A\n// typeof check of \"unknown\" circumvents this issue (and is also\n// IE specific).\nevent.cancelBubble=true;}this.isPropagationStopped=functionThatReturnsTrue;},/**\n     * We release all dispatched `SyntheticEvent`s after each event loop, adding\n     * them back into the pool. This allows a way to hold onto a reference that\n     * won't be added back into the pool.\n     */persist:function persist(){// Modern event system doesn't use pooling.\n},/**\n     * Checks if this event should be released back into the pool.\n     *\n     * @return {boolean} True if this should not be released, false otherwise.\n     */isPersistent:functionThatReturnsTrue});return SyntheticBaseEvent;}/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var EventInterface={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function timeStamp(event){return event.timeStamp||Date.now();},defaultPrevented:0,isTrusted:0};var SyntheticEvent=createSyntheticEvent(EventInterface);var UIEventInterface=assign({},EventInterface,{view:0,detail:0});var SyntheticUIEvent=createSyntheticEvent(UIEventInterface);var lastMovementX;var lastMovementY;var lastMouseEvent;function updateMouseMovementPolyfillState(event){if(event!==lastMouseEvent){if(lastMouseEvent&&event.type==='mousemove'){lastMovementX=event.screenX-lastMouseEvent.screenX;lastMovementY=event.screenY-lastMouseEvent.screenY;}else{lastMovementX=0;lastMovementY=0;}lastMouseEvent=event;}}/**\n * @interface MouseEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var MouseEventInterface=assign({},UIEventInterface,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:getEventModifierState,button:0,buttons:0,relatedTarget:function relatedTarget(event){if(event.relatedTarget===undefined)return event.fromElement===event.srcElement?event.toElement:event.fromElement;return event.relatedTarget;},movementX:function movementX(event){if('movementX'in event){return event.movementX;}updateMouseMovementPolyfillState(event);return lastMovementX;},movementY:function movementY(event){if('movementY'in event){return event.movementY;}// Don't need to call updateMouseMovementPolyfillState() here\n// because it's guaranteed to have already run when movementX\n// was copied.\nreturn lastMovementY;}});var SyntheticMouseEvent=createSyntheticEvent(MouseEventInterface);/**\n * @interface DragEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var DragEventInterface=assign({},MouseEventInterface,{dataTransfer:0});var SyntheticDragEvent=createSyntheticEvent(DragEventInterface);/**\n * @interface FocusEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var FocusEventInterface=assign({},UIEventInterface,{relatedTarget:0});var SyntheticFocusEvent=createSyntheticEvent(FocusEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n */var AnimationEventInterface=assign({},EventInterface,{animationName:0,elapsedTime:0,pseudoElement:0});var SyntheticAnimationEvent=createSyntheticEvent(AnimationEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/clipboard-apis/\n */var ClipboardEventInterface=assign({},EventInterface,{clipboardData:function clipboardData(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}});var SyntheticClipboardEvent=createSyntheticEvent(ClipboardEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n */var CompositionEventInterface=assign({},EventInterface,{data:0});var SyntheticCompositionEvent=createSyntheticEvent(CompositionEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n *      /#events-inputevents\n */ // Happens to share the same list for now.\nvar SyntheticInputEvent=SyntheticCompositionEvent;/**\n * Normalization of deprecated HTML5 `key` values\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**\n * Translation from legacy `keyCode` to HTML5 `key`\n * Only special keys supported, all others depend on keyboard layout or browser\n * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**\n * @param {object} nativeEvent Native browser event.\n * @return {string} Normalized `key` property.\n */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to\n// implementations of a working draft specification.\n// FireFox implements `key` but returns `MozPrintableKey` for all\n// printable characters (normalized to `Unidentified`), ignore it.\nvar key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.\nif(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can\n// thus be captured by `keypress`, no other non-printable key should.\nreturn charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each\n// `keyCode` value, almost all function keys have a universal value.\nreturn translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**\n * Translation from modifier key to the associated property in the event.\n * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support\n// getModifierState. If getModifierState is not supported, we map it to a set of\n// modifier keys exposed by the event. In this case, Lock-keys are not supported.\nfunction modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**\n * @interface KeyboardEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var KeyboardEventInterface=assign({},UIEventInterface,{key:getEventKey,code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:getEventModifierState,// Legacy Interface\ncharCode:function charCode(event){// `charCode` is the result of a KeyPress event and represents the value of\n// the actual printable character.\n// KeyPress is deprecated, but its replacement is not yet final and not\n// implemented in any major browser. Only KeyPress has charCode.\nif(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function keyCode(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of\n// physical keyboard key.\n// The actual meaning of the value depends on the users' keyboard layout\n// which cannot be detected. Assuming that it is a US keyboard layout\n// provides a surprisingly accurate mapping for US and European users.\n// Due to this, it is left to the user to implement at this time.\nif(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function which(event){// `which` is an alias for either `keyCode` or `charCode` depending on the\n// type of the event.\nif(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}});var SyntheticKeyboardEvent=createSyntheticEvent(KeyboardEventInterface);/**\n * @interface PointerEvent\n * @see http://www.w3.org/TR/pointerevents/\n */var PointerEventInterface=assign({},MouseEventInterface,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0});var SyntheticPointerEvent=createSyntheticEvent(PointerEventInterface);/**\n * @interface TouchEvent\n * @see http://www.w3.org/TR/touch-events/\n */var TouchEventInterface=assign({},UIEventInterface,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:getEventModifierState});var SyntheticTouchEvent=createSyntheticEvent(TouchEventInterface);/**\n * @interface Event\n * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n */var TransitionEventInterface=assign({},EventInterface,{propertyName:0,elapsedTime:0,pseudoElement:0});var SyntheticTransitionEvent=createSyntheticEvent(TransitionEventInterface);/**\n * @interface WheelEvent\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */var WheelEventInterface=assign({},MouseEventInterface,{deltaX:function deltaX(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function deltaY(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:0,// Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n// notch on the scroll is always +/- 120, roughly equivalent to pixels.\n// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\ndeltaMode:0});var SyntheticWheelEvent=createSyntheticEvent(WheelEventInterface);var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space\nvar START_KEYCODE=229;var canUseCompositionEvent=canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to\n// directly represent `beforeInput`. The IE `textinput` event is not as\n// useful, so we don't use it.\nvar canUseTextInputEvent=canUseDOM&&'TextEvent'in window&&!documentMode;// In IE9+, we have access to composition events, but the data supplied\n// by the native compositionend event may be incorrect. Japanese ideographic\n// spaces, for instance (\\u3000) are not recorded correctly.\nvar useFallbackCompositionData=canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);function registerEvents(){registerTwoPhaseEvent('onBeforeInput',['compositionend','keypress','textInput','paste']);registerTwoPhaseEvent('onCompositionEnd',['compositionend','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionStart',['compositionstart','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionUpdate',['compositionupdate','focusout','keydown','keypress','keyup','mousedown']);}// Track whether we've ever handled a keypress on the space key.\nvar hasSpaceKeypress=false;/**\n * Return whether a native keypress event is assumed to be a command.\n * This is required because Firefox fires `keypress` events for key commands\n * (cut, copy, select-all, etc.) even though no character is inserted.\n */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.\n!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**\n * Translate native top level events into event types.\n */function getCompositionEventType(domEventName){switch(domEventName){case'compositionstart':return'onCompositionStart';case'compositionend':return'onCompositionEnd';case'compositionupdate':return'onCompositionUpdate';}}/**\n * Does our fallback best-guess model think this event signifies that\n * composition has begun?\n */function isFallbackCompositionStart(domEventName,nativeEvent){return domEventName==='keydown'&&nativeEvent.keyCode===START_KEYCODE;}/**\n * Does our fallback mode think that this event is the end of composition?\n */function isFallbackCompositionEnd(domEventName,nativeEvent){switch(domEventName){case'keyup':// Command keys insert or clear IME input.\nreturn END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case'keydown':// Expect IME keyCode on each keydown. If we get any other\n// code we must have exited earlier.\nreturn nativeEvent.keyCode!==START_KEYCODE;case'keypress':case'mousedown':case'focusout':// Events are not possible without cancelling IME.\nreturn true;default:return false;}}/**\n * Google Input Tools provides composition data via a CustomEvent,\n * with the `data` property populated in the `detail` object. If this\n * is available on the event object, use it. If not, this is a plain\n * composition event and we have nothing special to extract.\n *\n * @param {object} nativeEvent\n * @return {?string}\n */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if(_typeof(detail)==='object'&&'data'in detail){return detail.data;}return null;}/**\n * Check if a composition event was triggered by Korean IME.\n * Our fallback mode does not work well with IE's Korean IME,\n * so just use native composition events when Korean IME is used.\n * Although CompositionEvent.locale property is deprecated,\n * it is available in IE, where our fallback mode is enabled.\n *\n * @param {object} nativeEvent\n * @return {boolean}\n */function isUsingKoreanIME(nativeEvent){return nativeEvent.locale==='ko';}// Track the current IME composition status, if any.\nvar isComposing=false;/**\n * @return {?object} A SyntheticCompositionEvent.\n */function extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(domEventName);}else if(!isComposing){if(isFallbackCompositionStart(domEventName,nativeEvent)){eventType='onCompositionStart';}}else if(isFallbackCompositionEnd(domEventName,nativeEvent)){eventType='onCompositionEnd';}if(!eventType){return null;}if(useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)){// The current composition is stored statically and must not be\n// overwritten while composition continues.\nif(!isComposing&&eventType==='onCompositionStart'){isComposing=initialize(nativeEventTarget);}else if(eventType==='onCompositionEnd'){if(isComposing){fallbackData=getData();}}}var listeners=accumulateTwoPhaseListeners(targetInst,eventType);if(listeners.length>0){var event=new SyntheticCompositionEvent(eventType,domEventName,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});if(fallbackData){// Inject data generated from fallback path into the synthetic event.\n// This matches the property of native CompositionEventInterface.\nevent.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}}}function getNativeBeforeInputChars(domEventName,nativeEvent){switch(domEventName){case'compositionend':return getDataFromCustomEvent(nativeEvent);case'keypress':/**\n       * If native `textInput` events are available, our goal is to make\n       * use of them. However, there is a special case: the spacebar key.\n       * In Webkit, preventing default on a spacebar `textInput` event\n       * cancels character insertion, but it *also* causes the browser\n       * to fall back to its default spacebar behavior of scrolling the\n       * page.\n       *\n       * Tracking at:\n       * https://code.google.com/p/chromium/issues/detail?id=355103\n       *\n       * To avoid this issue, use the keypress event as if no `textInput`\n       * event is available.\n       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case'textInput':// Record the characters to be added to the DOM.\nvar chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled\n// it at the keypress level and bail immediately. Android Chrome\n// doesn't give us keycodes, so we need to ignore it.\nif(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.\nreturn null;}}/**\n * For browsers that do not provide the `textInput` event, extract the\n * appropriate string to use for SyntheticInputEvent.\n */function getFallbackBeforeInputChars(domEventName,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,\n// try to extract the composed characters from the fallback object.\n// If composition event is available, we extract a string only at\n// compositionevent, otherwise extract it at fallback events.\nif(isComposing){if(domEventName==='compositionend'||!canUseCompositionEvent&&isFallbackCompositionEnd(domEventName,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(domEventName){case'paste':// If a paste event occurs after a keypress, throw out the input\n// chars. Paste events should not lead to BeforeInput events.\nreturn null;case'keypress':/**\n       * As of v27, Firefox may fire keypress events even when no character\n       * will be inserted. A few possibilities:\n       *\n       * - `which` is `0`. Arrow keys, Esc key, etc.\n       *\n       * - `which` is the pressed key code, but no char is available.\n       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n       *   this key combination and no character is inserted into the\n       *   document, but FF fires the keypress for char code `100` anyway.\n       *   No `input` event will occur.\n       *\n       * - `which` is the pressed key code, but a command combination is\n       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n       *   `input` event will occur.\n       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via\n// Touch keyboard of Windows.  In such a case, the `char` property\n// holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n// is 2, the property `which` does not represent an emoji correctly.\n// In such a case, we directly return the `char` property instead of\n// using `which`.\nif(nativeEvent[\"char\"]&&nativeEvent[\"char\"].length>1){return nativeEvent[\"char\"];}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case'compositionend':return useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)?null:nativeEvent.data;default:return null;}}/**\n * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n * `textInput` or fallback behavior.\n *\n * @return {?object} A SyntheticInputEvent.\n */function extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(domEventName,nativeEvent);}else{chars=getFallbackBeforeInputChars(domEventName,nativeEvent);}// If no characters are being inserted, no BeforeInput event should\n// be fired.\nif(!chars){return null;}var listeners=accumulateTwoPhaseListeners(targetInst,'onBeforeInput');if(listeners.length>0){var event=new SyntheticInputEvent('onBeforeInput','beforeinput',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.data=chars;}}/**\n * Create an `onBeforeInput` event to match\n * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n *\n * This event plugin is based on the native `textInput` event\n * available in Chrome, Safari, Opera, and IE. This event fires after\n * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n *\n * `beforeInput` is spec'd but not implemented in any browsers, and\n * the `input` event does not provide any useful information about what has\n * actually been added, contrary to the spec. Thus, `textInput` is the best\n * available event to identify the characters that have actually been inserted\n * into the target node.\n *\n * This plugin is also responsible for emitting `composition` events, thus\n * allowing us to share composition fallback code for both `beforeInput` and\n * `composition` event types.\n */function extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}/**\n * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**\n * Checks if an event is supported in the current execution environment.\n *\n * NOTE: This will not work correctly for non-generic events such as `change`,\n * `reset`, `load`, `error`, and `select`.\n *\n * Borrows from Modernizr.\n *\n * @param {string} eventNameSuffix Event name, e.g. \"click\".\n * @return {boolean} True if the event is supported.\n * @internal\n * @license Modernizr 3.0.0pre (Custom Build) | MIT\n */function isEventSupported(eventNameSuffix){if(!canUseDOM){return false;}var eventName='on'+eventNameSuffix;var isSupported=(eventName in document);if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}return isSupported;}function registerEvents$1(){registerTwoPhaseEvent('onChange',['change','click','focusin','focusout','input','keydown','keyup','selectionchange']);}function createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,target){// Flag this event loop as needing state restore.\nenqueueStateRestore(target);var listeners=accumulateTwoPhaseListeners(inst,'onChange');if(listeners.length>0){var event=new SyntheticEvent('onChange','change',null,nativeEvent,target);dispatchQueue.push({event:event,listeners:listeners});}}/**\n * For IE shims\n */var activeElement=null;var activeElementInst=null;/**\n * SECTION: handle `change` event\n */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var dispatchQueue=[];createAndAccumulateChangeEvent(dispatchQueue,activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the\n// other events and have it go through ReactBrowserEventEmitter. Since it\n// doesn't, we manually listen for the events and so we have to enqueue and\n// process the abstract event manually.\n//\n// Batching is necessary here in order to ensure that all event handlers run\n// before the next rerender (including event handlers attached to ancestor\n// elements instead of directly on the input). Without this, controlled\n// components don't work properly in conjunction with event bubbling because\n// the component is rerendered and the value reverted before all the event\n// handlers can run. See https://github.com/facebook/react/issues/708.\nbatchedUpdates(runEventInBatch,dispatchQueue);}function runEventInBatch(dispatchQueue){processDispatchQueue(dispatchQueue,0);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(domEventName,targetInst){if(domEventName==='change'){return targetInst;}}/**\n * SECTION: handle `input` event\n */var isInputEventSupported=false;if(canUseDOM){// IE9 claims to support the input event but fails to trigger it when\n// deleting text, so we ignore its input events.\nisInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**\n * (For IE <=9) Starts tracking propertychange events on the passed-in element\n * and override the value property so that we can distinguish user events from\n * value changes in JS.\n */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**\n * (For IE <=9) Removes the event listeners from the currently-tracked element,\n * if any exists.\n */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**\n * (For IE <=9) Handles a propertychange event, sending a `change` event if\n * the value of the active element has changed.\n */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(domEventName,target,targetInst){if(domEventName==='focusin'){// In IE9, propertychange fires for most input events but is buggy and\n// doesn't fire when text is deleted, but conveniently, selectionchange\n// appears to fire in all of the remaining cases so we catch those and\n// forward the event if the value has changed\n// In either case, we don't want to call the event handler if the value\n// is changed from JS so we redefine a setter for `.value` that updates\n// our activeElementValue variable, allowing us to ignore those changes\n//\n// stopWatching() should be a noop here but we call it just in case we\n// missed a blur event somehow.\nstopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(domEventName==='focusout'){stopWatchingForValueChange();}}// For IE8 and IE9.\nfunction getTargetInstForInputEventPolyfill(domEventName,targetInst){if(domEventName==='selectionchange'||domEventName==='keyup'||domEventName==='keydown'){// On the selectionchange event, the target is just document which isn't\n// helpful for us so just check activeElement instead.\n//\n// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n// propertychange on the first input event after setting `value` from a\n// script and fires only keydown, keypress, keyup. Catching keyup usually\n// gets it and catching keydown lets us fire an event for the first\n// keystroke if user does a key repeat (it'll be a little delayed: right\n// before the second keystroke). Other input methods (e.g., paste) seem to\n// fire selectionchange normally.\nreturn getInstIfValueChanged(activeElementInst);}}/**\n * SECTION: handle `click` event\n */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.\n// This approach works across all browsers, whereas `change` does not fire\n// until `blur` in IE8.\nvar nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(domEventName,targetInst){if(domEventName==='click'){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(domEventName,targetInst){if(domEventName==='input'||domEventName==='change'){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(node){var state=node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}{// If controlled, assign the value attribute to the current value on blur\nsetDefaultValue(node,'number',node.value);}}/**\n * This plugin creates an `onChange` event that normalizes change events\n * across form elements. This event fires at a time when it's possible to\n * change the element's value without seeing a flicker.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - select\n */function extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(domEventName,targetInst);if(inst){createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,nativeEventTarget);return;}}if(handleEventFunc){handleEventFunc(domEventName,targetNode,targetInst);}// When blurring, set the value attribute for number inputs\nif(domEventName==='focusout'){handleControlledInputBlur(targetNode);}}function registerEvents$2(){registerDirectEvent('onMouseEnter',['mouseout','mouseover']);registerDirectEvent('onMouseLeave',['mouseout','mouseover']);registerDirectEvent('onPointerEnter',['pointerout','pointerover']);registerDirectEvent('onPointerLeave',['pointerout','pointerover']);}/**\n * For almost every interaction we care about, there will be both a top-level\n * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n * we do not extract duplicate events. However, moving the mouse into the\n * browser from outside will not fire a `mouseout` event. In this case, we use\n * the `mouseover` top-level event.\n */function extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var isOverEvent=domEventName==='mouseover'||domEventName==='pointerover';var isOutEvent=domEventName==='mouseout'||domEventName==='pointerout';if(isOverEvent&&!isReplayingEvent(nativeEvent)){// If this is an over event with a target, we might have already dispatched\n// the event in the out event of the other target. If this is replayed,\n// then it's because we couldn't dispatch against this target previously\n// so we have to do it now instead.\nvar related=nativeEvent.relatedTarget||nativeEvent.fromElement;if(related){// If the related node is managed by React, we can assume that we have\n// already dispatched the corresponding events during its mouseout.\nif(getClosestInstanceFromNode(related)||isContainerMarkedAsRoot(related)){return;}}}if(!isOutEvent&&!isOverEvent){// Must not be a mouse or pointer in or out - ignoring.\nreturn;}var win;// TODO: why is this nullable in the types but we read from it?\nif(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.\nwin=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\nvar doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from;var to;if(isOutEvent){var _related=nativeEvent.relatedTarget||nativeEvent.toElement;from=targetInst;to=_related?getClosestInstanceFromNode(_related):null;if(to!==null){var nearestMounted=getNearestMountedFiber(to);if(to!==nearestMounted||to.tag!==HostComponent&&to.tag!==HostText){to=null;}}}else{// Moving to a node from outside the window.\nfrom=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.\nreturn;}var SyntheticEventCtor=SyntheticMouseEvent;var leaveEventType='onMouseLeave';var enterEventType='onMouseEnter';var eventTypePrefix='mouse';if(domEventName==='pointerout'||domEventName==='pointerover'){SyntheticEventCtor=SyntheticPointerEvent;leaveEventType='onPointerLeave';enterEventType='onPointerEnter';eventTypePrefix='pointer';}var fromNode=from==null?win:getNodeFromInstance(from);var toNode=to==null?win:getNodeFromInstance(to);var leave=new SyntheticEventCtor(leaveEventType,eventTypePrefix+'leave',from,nativeEvent,nativeEventTarget);leave.target=fromNode;leave.relatedTarget=toNode;var enter=null;// We should only process this nativeEvent if we are processing\n// the first ancestor. Next time, we will ignore the event.\nvar nativeTargetInst=getClosestInstanceFromNode(nativeEventTarget);if(nativeTargetInst===targetInst){var enterEvent=new SyntheticEventCtor(enterEventType,eventTypePrefix+'enter',to,nativeEvent,nativeEventTarget);enterEvent.target=toNode;enterEvent.relatedTarget=fromNode;enter=enterEvent;}accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leave,enter,from,to);}/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */function is(x,y){return x===y&&(x!==0||1/x===1/y)||x!==x&&y!==y// eslint-disable-line no-self-compare\n;}var objectIs=typeof Object.is==='function'?Object.is:is;/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */function shallowEqual(objA,objB){if(objectIs(objA,objB)){return true;}if(_typeof(objA)!=='object'||objA===null||_typeof(objB)!=='object'||objB===null){return false;}var keysA=Object.keys(objA);var keysB=Object.keys(objB);if(keysA.length!==keysB.length){return false;}// Test for A's keys different from B.\nfor(var i=0;i<keysA.length;i++){var currentKey=keysA[i];if(!hasOwnProperty.call(objB,currentKey)||!objectIs(objA[currentKey],objB[currentKey])){return false;}}return true;}/**\n * Given any node return the first leaf node without children.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {DOMElement|DOMTextNode}\n */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**\n * Get the next sibling within a container. This will walk up the\n * DOM if a node's siblings have been exhausted.\n *\n * @param {DOMElement|DOMTextNode} node\n * @return {?DOMElement|DOMTextNode}\n */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**\n * Get object describing the nodes which contain characters at offset.\n *\n * @param {DOMElement|DOMTextNode} root\n * @param {number} offset\n * @return {?object}\n */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**\n * @param {DOMElement} outerNode\n * @return {?object}\n */function getOffsets(outerNode){var ownerDocument=outerNode.ownerDocument;var win=ownerDocument&&ownerDocument.defaultView||window;var selection=win.getSelection&&win.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n// up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n// expose properties, triggering a \"Permission denied error\" if any of its\n// properties are accessed. The only seemingly possible way to avoid erroring\n// is to access a property that typically works for non-anonymous divs and\n// catch any error that may otherwise arise. See\n// https://bugzilla.mozilla.org/show_bug.cgi?id=208427\ntry{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset);}/**\n * Returns {start, end} where `start` is the character/codepoint index of\n * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n * `end` is the index of (focusNode, focusOffset).\n *\n * Returns null if you pass in garbage input but we should probably just crash.\n *\n * Exported only for testing.\n */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.\nparentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting\n// it. If it has no children, this is still the first loop, and the only\n// valid selection is anchorNode and focusNode both equal to this node\n// and both offsets 0, in which case we will have handled above.\nbreak outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.\nnode=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't\n// actually inside the passed-in node.)\nreturn null;}return{start:start,end:end};}/**\n * In modern non-IE browsers, we can support both forward and backward\n * selections.\n *\n * Note: IE10+ supports the Selection object, but it does not support\n * the `extend` method, which means that even in modern IE, it's not possible\n * to programmatically create a backward selection. Thus, for all IE\n * versions, we use the old IE API to create our selections.\n *\n * @param {DOMElement|DOMTextNode} node\n * @param {object} offsets\n */function setOffsets(node,offsets){var doc=node.ownerDocument||document;var win=doc&&doc.defaultView||window;// Edge fails with \"Object expected\" in some scenarios.\n// (For instance: TinyMCE editor used in a list component that supports pasting to add more,\n// fails when pasting 100+ items)\nif(!win.getSelection){return;}var selection=win.getSelection();var length=node.textContent.length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.\n// Flip backward selections, so we can set with a single range.\nif(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=doc.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isTextNode(node){return node&&node.nodeType===TEXT_NODE;}function containsNode(outerNode,innerNode){if(!outerNode||!innerNode){return false;}else if(outerNode===innerNode){return true;}else if(isTextNode(outerNode)){return false;}else if(isTextNode(innerNode)){return containsNode(outerNode,innerNode.parentNode);}else if('contains'in outerNode){return outerNode.contains(innerNode);}else if(outerNode.compareDocumentPosition){return!!(outerNode.compareDocumentPosition(innerNode)&16);}else{return false;}}function isInDocument(node){return node&&node.ownerDocument&&containsNode(node.ownerDocument.documentElement,node);}function isSameOriginFrame(iframe){try{// Accessing the contentDocument of a HTMLIframeElement can cause the browser\n// to throw, e.g. if it has a cross-origin src attribute.\n// Safari will show an error in the console when the access results in \"Blocked a frame with origin\". e.g:\n// iframe.contentDocument.defaultView;\n// A safety way is to access one of the cross origin properties: Window or Location\n// Which might result in \"SecurityError\" DOM Exception and it is compatible to Safari.\n// https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl\nreturn typeof iframe.contentWindow.location.href==='string';}catch(err){return false;}}function getActiveElementDeep(){var win=window;var element=getActiveElement();while(element instanceof win.HTMLIFrameElement){if(isSameOriginFrame(element)){win=element.contentWindow;}else{return element;}element=getActiveElement(win.document);}return element;}/**\n * @ReactInputSelection: React input selection module. Based on Selection.js,\n * but modified to be suitable for react and has a couple of bug fixes (doesn't\n * assume buttons have range selections allowed).\n * Input selection module for React.\n */ /**\n * @hasSelectionCapabilities: we get the element types that support selection\n * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`\n * and `selectionEnd` rows.\n */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&(elem.type==='text'||elem.type==='search'||elem.type==='tel'||elem.type==='url'||elem.type==='password')||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElementDeep();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection(focusedElem):null};}/**\n * @restoreSelection: If any selection information was potentially lost,\n * restore it. This is useful when performing operations that could remove dom\n * nodes and place them back in, resulting in focus being lost.\n */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElementDeep();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(priorSelectionRange!==null&&hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable\nvar ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}if(typeof priorFocusedElem.focus==='function'){priorFocusedElem.focus();}for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**\n * @getSelection: Gets the selection bounds of a focused textarea, input or\n * contentEditable node.\n * -@input: Look up selection bounds of this input\n * -@return {start: selectionStart, end: selectionEnd}\n */function getSelection(input){var selection;if('selectionStart'in input){// Modern browser with input or textarea.\nselection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.\nselection=getOffsets(input);}return selection||{start:0,end:0};}/**\n * @setSelection: Sets the selection bounds of a textarea or input and focuses\n * the input.\n * -@input     Set selection bounds of this input or textarea\n * -@offsets   Object of same form that is returned from get*\n */function setSelection(input,offsets){var start=offsets.start;var end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=canUseDOM&&'documentMode'in document&&document.documentMode<=11;function registerEvents$3(){registerTwoPhaseEvent('onSelect',['focusout','contextmenu','dragend','focusin','keydown','keyup','mousedown','mouseup','selectionchange']);}var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**\n * Get an object which is a unique representation of the current selection.\n *\n * The return value will not be consistent across nodes or browsers, but\n * two identical selections on the same node will return identical objects.\n */function getSelection$1(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else{var win=node.ownerDocument&&node.ownerDocument.defaultView||window;var selection=win.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**\n * Get document associated with the event target.\n */function getEventTargetDocument(eventTarget){return eventTarget.window===eventTarget?eventTarget.document:eventTarget.nodeType===DOCUMENT_NODE?eventTarget:eventTarget.ownerDocument;}/**\n * Poll selection to see whether it's changed.\n *\n * @param {object} nativeEvent\n * @param {object} nativeEventTarget\n * @return {?SyntheticEvent}\n */function constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a\n// selection (this matches native `select` event behavior). In HTML5, select\n// fires only on input and textarea thus if there's no focused element we\n// won't dispatch.\nvar doc=getEventTargetDocument(nativeEventTarget);if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement(doc)){return;}// Only fire when selection has actually changed.\nvar currentSelection=getSelection$1(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var listeners=accumulateTwoPhaseListeners(activeElementInst$1,'onSelect');if(listeners.length>0){var event=new SyntheticEvent('onSelect','select',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.target=activeElement$1;}}}/**\n * This plugin creates an `onSelect` event that normalizes select events\n * across form elements.\n *\n * Supported elements are:\n * - input (see `isTextInputElement`)\n * - textarea\n * - contentEditable\n *\n * This differs from native browser implementations in the following ways:\n * - Fires on contentEditable fields as well as inputs.\n * - Fires for collapsed selection.\n * - Fires after user input.\n */function extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;switch(domEventName){// Track the input node that has focus.\ncase'focusin':if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case'focusout':activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the\n// semantics of the native select event.\ncase'mousedown':mouseDown=true;break;case'contextmenu':case'mouseup':case'dragend':mouseDown=false;constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);break;// Chrome and IE fire non-standard event when selection is changed (and\n// sometimes when it hasn't). IE's event fires out of order with respect\n// to key and input events on deletion, so we discard it.\n//\n// Firefox doesn't support selectionchange, so check selection status\n// after each key entry. The selection changes after keydown and before\n// keyup, but we check on keydown as well in the case of holding down a\n// key, when multiple keydown events are fired but only one keyup is.\n// This is also our approach for IE handling, for the reason above.\ncase'selectionchange':if(skipSelectionChangeEvent){break;}// falls through\ncase'keydown':case'keyup':constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);}}/**\n * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n *\n * @param {string} styleProp\n * @param {string} eventName\n * @returns {object}\n */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;return prefixes;}/**\n * A list of event names to a configurable list of vendor prefixes.\n */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**\n * Event names that have already been detected and prefixed (if applicable).\n */var prefixedEventNames={};/**\n * Element to check for prefixes on.\n */var style={};/**\n * Bootstrap if a DOM exists.\n */if(canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,\n// the un-prefixed \"animation\" and \"transition\" properties are defined on the\n// style object but the events that fire will still be prefixed, so we need\n// to check if the un-prefixed events are usable, and if not remove them from the map.\nif(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above\nif(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**\n * Attempts to determine the correct vendor prefixed event name.\n *\n * @param {string} eventName\n * @returns {string}\n */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return eventName;}var ANIMATION_END=getVendorPrefixedEventName('animationend');var ANIMATION_ITERATION=getVendorPrefixedEventName('animationiteration');var ANIMATION_START=getVendorPrefixedEventName('animationstart');var TRANSITION_END=getVendorPrefixedEventName('transitionend');var topLevelEventsToReactNames=new Map();// NOTE: Capitalization is important in this list!\n//\n// E.g. it needs \"pointerDown\", not \"pointerdown\".\n// This is because we derive both React name (\"onPointerDown\")\n// and DOM name (\"pointerdown\") from the same list.\n//\n// Exceptions that don't match this convention are listed separately.\n//\n// prettier-ignore\nvar simpleEventPluginEvents=['abort','auxClick','cancel','canPlay','canPlayThrough','click','close','contextMenu','copy','cut','drag','dragEnd','dragEnter','dragExit','dragLeave','dragOver','dragStart','drop','durationChange','emptied','encrypted','ended','error','gotPointerCapture','input','invalid','keyDown','keyPress','keyUp','load','loadedData','loadedMetadata','loadStart','lostPointerCapture','mouseDown','mouseMove','mouseOut','mouseOver','mouseUp','paste','pause','play','playing','pointerCancel','pointerDown','pointerMove','pointerOut','pointerOver','pointerUp','progress','rateChange','reset','resize','seeked','seeking','stalled','submit','suspend','timeUpdate','touchCancel','touchEnd','touchStart','volumeChange','scroll','toggle','touchMove','waiting','wheel'];function registerSimpleEvent(domEventName,reactName){topLevelEventsToReactNames.set(domEventName,reactName);registerTwoPhaseEvent(reactName,[domEventName]);}function registerSimpleEvents(){for(var i=0;i<simpleEventPluginEvents.length;i++){var eventName=simpleEventPluginEvents[i];var domEventName=eventName.toLowerCase();var capitalizedEvent=eventName[0].toUpperCase()+eventName.slice(1);registerSimpleEvent(domEventName,'on'+capitalizedEvent);}// Special cases where event names don't match.\nregisterSimpleEvent(ANIMATION_END,'onAnimationEnd');registerSimpleEvent(ANIMATION_ITERATION,'onAnimationIteration');registerSimpleEvent(ANIMATION_START,'onAnimationStart');registerSimpleEvent('dblclick','onDoubleClick');registerSimpleEvent('focusin','onFocus');registerSimpleEvent('focusout','onBlur');registerSimpleEvent(TRANSITION_END,'onTransitionEnd');}function extractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var reactName=topLevelEventsToReactNames.get(domEventName);if(reactName===undefined){return;}var SyntheticEventCtor=SyntheticEvent;var reactEventType=domEventName;switch(domEventName){case'keypress':// Firefox creates a keypress event for function keys too. This removes\n// the unwanted keypress events. Enter is however both printable and\n// non-printable. One would expect Tab to be as well (but it isn't).\nif(getEventCharCode(nativeEvent)===0){return;}/* falls through */case'keydown':case'keyup':SyntheticEventCtor=SyntheticKeyboardEvent;break;case'focusin':reactEventType='focus';SyntheticEventCtor=SyntheticFocusEvent;break;case'focusout':reactEventType='blur';SyntheticEventCtor=SyntheticFocusEvent;break;case'beforeblur':case'afterblur':SyntheticEventCtor=SyntheticFocusEvent;break;case'click':// Firefox creates a click event on right mouse clicks. This removes the\n// unwanted click events.\nif(nativeEvent.button===2){return;}/* falls through */case'auxclick':case'dblclick':case'mousedown':case'mousemove':case'mouseup':// TODO: Disabled elements should not respond to mouse events\n/* falls through */case'mouseout':case'mouseover':case'contextmenu':SyntheticEventCtor=SyntheticMouseEvent;break;case'drag':case'dragend':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'dragstart':case'drop':SyntheticEventCtor=SyntheticDragEvent;break;case'touchcancel':case'touchend':case'touchmove':case'touchstart':SyntheticEventCtor=SyntheticTouchEvent;break;case ANIMATION_END:case ANIMATION_ITERATION:case ANIMATION_START:SyntheticEventCtor=SyntheticAnimationEvent;break;case TRANSITION_END:SyntheticEventCtor=SyntheticTransitionEvent;break;case'scroll':SyntheticEventCtor=SyntheticUIEvent;break;case'wheel':SyntheticEventCtor=SyntheticWheelEvent;break;case'copy':case'cut':case'paste':SyntheticEventCtor=SyntheticClipboardEvent;break;case'gotpointercapture':case'lostpointercapture':case'pointercancel':case'pointerdown':case'pointermove':case'pointerout':case'pointerover':case'pointerup':SyntheticEventCtor=SyntheticPointerEvent;break;}var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;{// Some events don't bubble in the browser.\n// In the past, React has always bubbled them, but this can be surprising.\n// We're going to try aligning closer to the browser behavior by not bubbling\n// them in React either. We'll start by not bubbling onScroll, and then expand.\nvar accumulateTargetOnly=!inCapturePhase&&// TODO: ideally, we'd eventually add all events from\n// nonDelegatedEvents list in DOMPluginEventSystem.\n// Then we can remove this special list.\n// This is a breaking change that can wait until React 18.\ndomEventName==='scroll';var _listeners=accumulateSinglePhaseListeners(targetInst,reactName,nativeEvent.type,inCapturePhase,accumulateTargetOnly);if(_listeners.length>0){// Intentionally create event lazily.\nvar _event=new SyntheticEventCtor(reactName,reactEventType,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:_event,listeners:_listeners});}}}// TODO: remove top-level side effect.\nregisterSimpleEvents();registerEvents$2();registerEvents$1();registerEvents$3();registerEvents();function extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){// TODO: we should remove the concept of a \"SimpleEventPlugin\".\n// This is the basic functionality of the event system. All\n// the other plugins are essentially polyfills. So the plugin\n// should probably be inlined somewhere and have its logic\n// be core the to event system. This would potentially allow\n// us to ship builds of React without the polyfilled plugins below.\nextractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);var shouldProcessPolyfillPlugins=(eventSystemFlags&SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS)===0;// We don't process these events unless we are in the\n// event's native \"bubble\" phase, which means that we're\n// not in the capture phase. That's because we emulate\n// the capture phase here still. This is a trade-off,\n// because in an ideal world we would not emulate and use\n// the phases properly, like we do with the SimpleEvent\n// plugin. However, the plugins below either expect\n// emulation (EnterLeave) or use state localized to that\n// plugin (BeforeInput, Change, Select). The state in\n// these modules complicates things, as you'll essentially\n// get the case where the capture phase event might change\n// state, only for the following bubble event to come in\n// later and not trigger anything as the state now\n// invalidates the heuristics of the event plugin. We\n// could alter all these plugins to work in such ways, but\n// that might cause other unknown side-effects that we\n// can't foresee right now.\nif(shouldProcessPolyfillPlugins){extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}}// List of events that need to be individually attached to media elements.\nvar mediaEventTypes=['abort','canplay','canplaythrough','durationchange','emptied','encrypted','ended','error','loadeddata','loadedmetadata','loadstart','pause','play','playing','progress','ratechange','resize','seeked','seeking','stalled','suspend','timeupdate','volumechange','waiting'];// We should not delegate these events to the container, but rather\n// set them on the actual target element itself. This is primarily\n// because these events do not consistently bubble in the DOM.\nvar nonDelegatedEvents=new Set(['cancel','close','invalid','load','scroll','toggle'].concat(mediaEventTypes));function executeDispatch(event,listener,currentTarget){var type=event.type||'unknown-event';event.currentTarget=currentTarget;invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}function processDispatchQueueItemsInOrder(event,dispatchListeners,inCapturePhase){var previousInstance;if(inCapturePhase){for(var i=dispatchListeners.length-1;i>=0;i--){var _dispatchListeners$i=dispatchListeners[i],instance=_dispatchListeners$i.instance,currentTarget=_dispatchListeners$i.currentTarget,listener=_dispatchListeners$i.listener;if(instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,listener,currentTarget);previousInstance=instance;}}else{for(var _i=0;_i<dispatchListeners.length;_i++){var _dispatchListeners$_i=dispatchListeners[_i],_instance=_dispatchListeners$_i.instance,_currentTarget=_dispatchListeners$_i.currentTarget,_listener=_dispatchListeners$_i.listener;if(_instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,_listener,_currentTarget);previousInstance=_instance;}}}function processDispatchQueue(dispatchQueue,eventSystemFlags){var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;for(var i=0;i<dispatchQueue.length;i++){var _dispatchQueue$i=dispatchQueue[i],event=_dispatchQueue$i.event,listeners=_dispatchQueue$i.listeners;processDispatchQueueItemsInOrder(event,listeners,inCapturePhase);//  event system doesn't use pooling.\n}// This would be a good time to rethrow if any of the event handlers threw.\nrethrowCaughtError();}function dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var nativeEventTarget=getEventTarget(nativeEvent);var dispatchQueue=[];extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);processDispatchQueue(dispatchQueue,eventSystemFlags);}function listenToNonDelegatedEvent(domEventName,targetElement){{if(!nonDelegatedEvents.has(domEventName)){error('Did not expect a listenToNonDelegatedEvent() call for \"%s\". '+'This is a bug in React. Please file an issue.',domEventName);}}var isCapturePhaseListener=false;var listenerSet=getEventListenerSet(targetElement);var listenerSetKey=getListenerSetKey(domEventName,isCapturePhaseListener);if(!listenerSet.has(listenerSetKey)){addTrappedEventListener(targetElement,domEventName,IS_NON_DELEGATED,isCapturePhaseListener);listenerSet.add(listenerSetKey);}}function listenToNativeEvent(domEventName,isCapturePhaseListener,target){{if(nonDelegatedEvents.has(domEventName)&&!isCapturePhaseListener){error('Did not expect a listenToNativeEvent() call for \"%s\" in the bubble phase. '+'This is a bug in React. Please file an issue.',domEventName);}}var eventSystemFlags=0;if(isCapturePhaseListener){eventSystemFlags|=IS_CAPTURE_PHASE;}addTrappedEventListener(target,domEventName,eventSystemFlags,isCapturePhaseListener);}// This is only used by createEventHandle when the\nvar listeningMarker='_reactListening'+Math.random().toString(36).slice(2);function listenToAllSupportedEvents(rootContainerElement){if(!rootContainerElement[listeningMarker]){rootContainerElement[listeningMarker]=true;allNativeEvents.forEach(function(domEventName){// We handle selectionchange separately because it\n// doesn't bubble and needs to be on the document.\nif(domEventName!=='selectionchange'){if(!nonDelegatedEvents.has(domEventName)){listenToNativeEvent(domEventName,false,rootContainerElement);}listenToNativeEvent(domEventName,true,rootContainerElement);}});var ownerDocument=rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;if(ownerDocument!==null){// The selectionchange event also needs deduplication\n// but it is attached to the document.\nif(!ownerDocument[listeningMarker]){ownerDocument[listeningMarker]=true;listenToNativeEvent('selectionchange',false,ownerDocument);}}}}function addTrappedEventListener(targetContainer,domEventName,eventSystemFlags,isCapturePhaseListener,isDeferredListenerForLegacyFBSupport){var listener=createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags);// If passive option is not supported, then the event will be\n// active and not passive.\nvar isPassiveListener=undefined;if(passiveBrowserEventsSupported){// Browsers introduced an intervention, making these events\n// passive by default on document. React doesn't bind them\n// to document anymore, but changing this now would undo\n// the performance wins from the change. So we emulate\n// the existing behavior manually on the roots now.\n// https://github.com/facebook/react/issues/19651\nif(domEventName==='touchstart'||domEventName==='touchmove'||domEventName==='wheel'){isPassiveListener=true;}}targetContainer=targetContainer;var unsubscribeListener;// When legacyFBSupport is enabled, it's for when we\nif(isCapturePhaseListener){if(isPassiveListener!==undefined){unsubscribeListener=addEventCaptureListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else{unsubscribeListener=addEventCaptureListener(targetContainer,domEventName,listener);}}else{if(isPassiveListener!==undefined){unsubscribeListener=addEventBubbleListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else{unsubscribeListener=addEventBubbleListener(targetContainer,domEventName,listener);}}}function isMatchingRootContainer(grandContainer,targetContainer){return grandContainer===targetContainer||grandContainer.nodeType===COMMENT_NODE&&grandContainer.parentNode===targetContainer;}function dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var ancestorInst=targetInst;if((eventSystemFlags&IS_EVENT_HANDLE_NON_MANAGED_NODE)===0&&(eventSystemFlags&IS_NON_DELEGATED)===0){var targetContainerNode=targetContainer;// If we are using the legacy FB support flag, we\nif(targetInst!==null){// The below logic attempts to work out if we need to change\n// the target fiber to a different ancestor. We had similar logic\n// in the legacy event system, except the big difference between\n// systems is that the modern event system now has an event listener\n// attached to each React Root and React Portal Root. Together,\n// the DOM nodes representing these roots are the \"rootContainer\".\n// To figure out which ancestor instance we should use, we traverse\n// up the fiber tree from the target instance and attempt to find\n// root boundaries that match that of our current \"rootContainer\".\n// If we find that \"rootContainer\", we find the parent fiber\n// sub-tree for that root and make that our ancestor instance.\nvar node=targetInst;mainLoop:while(true){if(node===null){return;}var nodeTag=node.tag;if(nodeTag===HostRoot||nodeTag===HostPortal){var container=node.stateNode.containerInfo;if(isMatchingRootContainer(container,targetContainerNode)){break;}if(nodeTag===HostPortal){// The target is a portal, but it's not the rootContainer we're looking for.\n// Normally portals handle their own events all the way down to the root.\n// So we should be able to stop now. However, we don't know if this portal\n// was part of *our* root.\nvar grandNode=node[\"return\"];while(grandNode!==null){var grandTag=grandNode.tag;if(grandTag===HostRoot||grandTag===HostPortal){var grandContainer=grandNode.stateNode.containerInfo;if(isMatchingRootContainer(grandContainer,targetContainerNode)){// This is the rootContainer we're looking for and we found it as\n// a parent of the Portal. That means we can ignore it because the\n// Portal will bubble through to us.\nreturn;}}grandNode=grandNode[\"return\"];}}// Now we need to find it's corresponding host fiber in the other\n// tree. To do this we can use getClosestInstanceFromNode, but we\n// need to validate that the fiber is a host instance, otherwise\n// we need to traverse up through the DOM till we find the correct\n// node that is from the other tree.\nwhile(container!==null){var parentNode=getClosestInstanceFromNode(container);if(parentNode===null){return;}var parentTag=parentNode.tag;if(parentTag===HostComponent||parentTag===HostText){node=ancestorInst=parentNode;continue mainLoop;}container=container.parentNode;}}node=node[\"return\"];}}}batchedUpdates(function(){return dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,ancestorInst);});}function createDispatchListener(instance,listener,currentTarget){return{instance:instance,listener:listener,currentTarget:currentTarget};}function accumulateSinglePhaseListeners(targetFiber,reactName,nativeEventType,inCapturePhase,accumulateTargetOnly,nativeEvent){var captureName=reactName!==null?reactName+'Capture':null;var reactEventName=inCapturePhase?captureName:reactName;var listeners=[];var instance=targetFiber;var lastHostComponent=null;// Accumulate all instances and listeners via the target -> root path.\nwhile(instance!==null){var _instance2=instance,stateNode=_instance2.stateNode,tag=_instance2.tag;// Handle listeners that are on HostComponents (i.e. <div>)\nif(tag===HostComponent&&stateNode!==null){lastHostComponent=stateNode;// createEventHandle listeners\nif(reactEventName!==null){var listener=getListener(instance,reactEventName);if(listener!=null){listeners.push(createDispatchListener(instance,listener,lastHostComponent));}}}// If we are only accumulating events for the target, then we don't\n// continue to propagate through the React fiber tree to find other\n// listeners.\nif(accumulateTargetOnly){break;}// If we are processing the onBeforeBlur event, then we need to take\ninstance=instance[\"return\"];}return listeners;}// We should only use this function for:\n// - BeforeInputEventPlugin\n// - ChangeEventPlugin\n// - SelectEventPlugin\n// This is because we only process these plugins\n// in the bubble phase, so we need to accumulate two\n// phase event listeners (via emulation).\nfunction accumulateTwoPhaseListeners(targetFiber,reactName){var captureName=reactName+'Capture';var listeners=[];var instance=targetFiber;// Accumulate all instances and listeners via the target -> root path.\nwhile(instance!==null){var _instance3=instance,stateNode=_instance3.stateNode,tag=_instance3.tag;// Handle listeners that are on HostComponents (i.e. <div>)\nif(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;var captureListener=getListener(instance,captureName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}var bubbleListener=getListener(instance,reactName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}instance=instance[\"return\"];}return listeners;}function getParent(inst){if(inst===null){return null;}do{inst=inst[\"return\"];// TODO: If this is a HostRoot we might want to bail out.\n// That is depending on if we want nested subtrees (layers) to bubble\n// events to their parent. We could also go through parentNode on the\n// host node but that wouldn't work for React Native and doesn't let us\n// do the portal feature.\n}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */function getLowestCommonAncestor(instA,instB){var nodeA=instA;var nodeB=instB;var depthA=0;for(var tempA=nodeA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=nodeB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.\nwhile(depthA-depthB>0){nodeA=getParent(nodeA);depthA--;}// If B is deeper, crawl up.\nwhile(depthB-depthA>0){nodeB=getParent(nodeB);depthB--;}// Walk in lockstep until we find a match.\nvar depth=depthA;while(depth--){if(nodeA===nodeB||nodeB!==null&&nodeA===nodeB.alternate){return nodeA;}nodeA=getParent(nodeA);nodeB=getParent(nodeB);}return null;}function accumulateEnterLeaveListenersForEvent(dispatchQueue,event,target,common,inCapturePhase){var registrationName=event._reactName;var listeners=[];var instance=target;while(instance!==null){if(instance===common){break;}var _instance4=instance,alternate=_instance4.alternate,stateNode=_instance4.stateNode,tag=_instance4.tag;if(alternate!==null&&alternate===common){break;}if(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;if(inCapturePhase){var captureListener=getListener(instance,registrationName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}}else if(!inCapturePhase){var bubbleListener=getListener(instance,registrationName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}}instance=instance[\"return\"];}if(listeners.length!==0){dispatchQueue.push({event:event,listeners:listeners});}}// We should only use this function for:\n// - EnterLeaveEventPlugin\n// This is because we only process this plugin\n// in the bubble phase, so we need to accumulate two\n// phase event listeners.\nfunction accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leaveEvent,enterEvent,from,to){var common=from&&to?getLowestCommonAncestor(from,to):null;if(from!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,leaveEvent,from,common,false);}if(to!==null&&enterEvent!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,enterEvent,to,common,true);}}function getListenerSetKey(domEventName,capture){return domEventName+\"__\"+(capture?'capture':'bubble');}var didWarnInvalidHydration=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML$1='__html';var warnedUnknownTags;var suppressHydrationWarning;var validatePropertiesInDevelopment;var warnForPropDifference;var warnForExtraAttributes;var warnForInvalidEventListener;var canDiffStyleForHydrationWarning;var normalizeHTML;{warnedUnknownTags={// There are working polyfills for <dialog>. Let people use it.\ndialog:true,// Electron ships a custom <webview> tag to display external web content in\n// an isolated frame and process.\n// This tag is not present in non Electron environments such as JSDom which\n// is often used for testing purposes.\n// @see https://electronjs.org/docs/api/webview-tag\nwebview:true};validatePropertiesInDevelopment=function validatePropertiesInDevelopment(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,{registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames});};// IE 11 parses & normalizes the style attribute as opposed to other\n// browsers. It adds spaces and sorts the properties in some\n// non-alphabetical order. Handling that would require sorting CSS\n// properties in the client & server versions or applying\n// `expectedStyle` to a temporary DOM node to read its `style` attribute\n// normalized. Since it only affects IE, we're skipping style warnings\n// in that browser completely in favor of doing all that work.\n// See https://github.com/facebook/react/issues/11807\ncanDiffStyleForHydrationWarning=canUseDOM&&!document.documentMode;warnForPropDifference=function warnForPropDifference(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;error('Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};warnForExtraAttributes=function warnForExtraAttributes(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});error('Extra attributes from the server: %s',names);};warnForInvalidEventListener=function warnForInvalidEventListener(registrationName,listener){if(listener===false){error('Expected `%s` listener to be a function, instead got `false`.\\n\\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',registrationName,registrationName,registrationName);}else{error('Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,_typeof(listener));}};// Parse the HTML and read it back to normalize the HTML string so that it\n// can be used for comparison.\nnormalizeHTML=function normalizeHTML(parent,html){// We could have created a separate document here to avoid\n// re-initializing custom elements if they exist. But this breaks\n// how <noscript> is being handled. So we use the same document.\n// See the discussion in https://github.com/facebook/react/pull/11157.\nvar testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}// HTML parsing normalizes CR and CRLF to LF.\n// It also can turn \\u0000 into \\uFFFD inside attributes.\n// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\n// If we have a mismatch, it might be caused by that.\n// We will still patch up in this case but not fire the warning.\nvar NORMALIZE_NEWLINES_REGEX=/\\r\\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\\u0000|\\uFFFD/g;function normalizeMarkupForTextOrAttribute(markup){{checkHtmlStringCoercion(markup);}var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');}function checkForUnmatchedText(serverText,clientText,isConcurrentMode,shouldWarnDev){var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}if(shouldWarnDev){{if(!didWarnInvalidHydration){didWarnInvalidHydration=true;error('Text content did not match. Server: \"%s\" Client: \"%s\"',normalizedServerText,normalizedClientText);}}}if(isConcurrentMode&&enableClientRenderFallbackOnTextMismatch){// In concurrent roots, we throw when there's a text mismatch and revert to\n// client rendering, up to the nearest Suspense boundary.\nthrow new Error('Text content does not match server-rendered HTML.');}}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}function noop(){}function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on\n// non-interactive elements, which means delegated click listeners do not\n// fire. The workaround for this bug involves attaching an empty click\n// listener on the target node.\n// https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n// Just set it using the onclick property so that we don't have to manage any\n// bookkeeping for it. Not sure if we need to clear it when the listener is\n// removed.\n// TODO: Only do this for the relevant Safaris maybe?\nnode.onclick=noop;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be\n// mutated. We have already warned for this in the past.\nObject.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.\nsetValueForStyles(domElement,nextProp);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting\n// textContent on a <textarea> will cause the placeholder to not\n// show within the <textarea> until it has been focused and blurred again.\n// https://github.com/facebook/react/issues/6731#issuecomment-254874553\nvar canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(nextProp!=null){setValueForProperty(domElement,propKey,nextProp,isCustomComponentTag);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag\nfor(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else{setValueForProperty(domElement,propKey,propValue,isCustomComponentTag);}}}function createElement(type,props,rootContainerElement,parentNamespace){var isCustomComponentTag;// We create tags in the namespace of their parent container, except HTML\n// tags get no namespace.\nvar ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to\n// allow <SVG> or <mATH>.\nif(!isCustomComponentTag&&type!==type.toLowerCase()){error('<%s /> is using incorrect casing. '+'Use PascalCase for React components, '+'or lowercase for HTML elements.',type);}}if(type==='script'){// Create the script via .innerHTML so its \"parser-inserted\" flag is\n// set to true and it does not execute\nvar div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line\n// This is guaranteed to yield a script element.\nvar firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components\ndomElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n// See discussion in https://github.com/facebook/react/pull/6896\n// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\ndomElement=ownerDocument.createElement(type);// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`\n// attributes on `select`s needs to be added before `option`s are inserted.\n// This prevents:\n// - a bug where the `select` does not scroll to the correct option because singular\n//  `select` elements automatically pick the first item #13222\n// - a bug where the `select` set the first item as selected despite the `size` attribute #14239\n// See https://github.com/facebook/react/issues/13222\n// and https://github.com/facebook/react/issues/14239\nif(type==='select'){var node=domElement;if(props.multiple){node.multiple=true;}else if(props.size){// Setting a size greater than 1 causes a select to behave like `multiple=true`, where\n// it is possible that no option is selected.\n//\n// This is only necessary when a select in \"single selection mode\".\nnode.size=props.size;}}}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;error('The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.\nvar props;switch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);props=rawProps;break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the load event.\nlistenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for all the media events.\nfor(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}props=rawProps;break;case'source':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the error event.\nlistenToNonDelegatedEvent('error',domElement);props=rawProps;break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for error and load events.\nlistenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'details':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the toggle event.\nlistenToNonDelegatedEvent('toggle',domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);props=rawProps;break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;default:props=rawProps;}assertValidProps(tag,props);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper(domElement,rawProps,false);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper$3(domElement);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.\nfunction diffProperties(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure\n// that the \"current\" fiber pointer gets updated so we need a commit\n// to update this element.\nif(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use\n// the allowed property list in the commit phase instead.\n(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be\n// mutated. We have already warned for this in the past.\nObject.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.\nfor(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.\nfor(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.\nif(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;var lastHtml=lastProp?lastProp[HTML$1]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,nextHtml);}}}else if(propKey===CHILDREN){if(typeof nextProp==='string'||typeof nextProp==='number'){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.\nif(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure\n// that the \"current\" props pointer gets updated so we need a commit\n// to update this element.\nupdatePayload=[];}}else{// For any other property we always add it to the queue and then we\n// filter it out using the allowed property list during the commit.\n(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){{validateShorthandPropertyCollisionInDev(styleUpdates,nextProps[STYLE]);}(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.\nfunction updateProperties(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.\n// In the middle of an update, it is possible to have multiple checked.\n// When a checked radio tries to change name, browser makes another radio's checked false.\nif(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.\nupdateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props\n// changed.\nswitch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to\n// happen after `updateDOMProperties`. Otherwise HTML5 input validations\n// raise warnings and prevent the new value from being assigned.\nupdateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children\n// reconciliation\npostUpdateWrapper(domElement,nextRawProps);break;}}function getPossibleStandardName(propName){{var lowerCasedName=propName.toLowerCase();if(!possibleStandardNames.hasOwnProperty(lowerCasedName)){return null;}return possibleStandardNames[lowerCasedName]||null;}}function diffHydratedProperties(domElement,tag,rawProps,parentNamespace,rootContainerElement,isConcurrentMode,shouldWarnDev){var isCustomComponentTag;var extraAttributeNames;{suppressHydrationWarning=rawProps[SUPPRESS_HYDRATION_WARNING]===true;isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.\nswitch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the load event.\nlistenToNonDelegatedEvent('load',domElement);break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for all the media events.\nfor(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}break;case'source':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the error event.\nlistenToNonDelegatedEvent('error',domElement);break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble\n// listeners still fire for error and load events.\nlistenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);break;case'details':// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the toggle event.\nlistenToNonDelegatedEvent('toggle',domElement);break;case'input':initWrapperState(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n// listeners still fire for the invalid event.\nlistenToNonDelegatedEvent('invalid',domElement);break;}assertValidProps(tag,rawProps);{extraAttributeNames=new Set();var attributes=domElement.attributes;for(var _i=0;_i<attributes.length;_i++){var name=attributes[_i].name.toLowerCase();switch(name){// Controlled attributes are not validated\n// TODO: Only ignore them on controlled tags.\ncase'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.\n// See discussion in https://github.com/facebook/react/pull/10676.\nextraAttributeNames.add(attributes[_i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This\n// might match additional HTML that is hidden when we read it using\n// textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n// satisfies our requirement. Our requirement is not to produce perfect\n// HTML and attributes. Ideally we should preserve structure but it's\n// ok not to if the visible content is still enough to indicate what\n// even listeners these nodes might be wired up to.\n// TODO: Warn if there is more than a single textNode as a child.\n// TODO: Should we use domElement.firstChild.nodeValue to compare?\nif(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(!suppressHydrationWarning){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(!suppressHydrationWarning){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(shouldWarnDev&&true&&// Convince Flow we've calculated it (it's DEV-only in this method.)\ntypeof isCustomComponentTag==='boolean'){// Validate that the properties correspond to their expected values.\nvar serverValue=void 0;var propertyInfo=isCustomComponentTag&&enableCustomElementPropertySupport?null:getPropertyInfo(propKey);if(suppressHydrationWarning);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING||// Controlled attributes are not validated\n// TODO: Only ignore them on controlled tags.\npropKey==='value'||propKey==='checked'||propKey==='selected');else if(propKey===DANGEROUSLY_SET_INNER_HTML){var serverHTML=domElement.innerHTML;var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){var expectedHTML=normalizeHTML(domElement,nextHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propKey);if(canDiffStyleForHydrationWarning){var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}}else if(isCustomComponentTag&&!enableCustomElementPropertySupport){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(!shouldIgnoreAttribute(propKey,propertyInfo,isCustomComponentTag)&&!shouldRemoveAttribute(propKey,nextProp,propertyInfo,isCustomComponentTag)){var isMismatchDueToBadCasing=false;if(propertyInfo!==null){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp,propertyInfo);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propKey.toLowerCase());}else{var standardName=getPossibleStandardName(propKey);if(standardName!==null&&standardName!==propKey){// If an SVG prop is supplied with bad casing, it will\n// be successfully parsed from HTML, but will produce a mismatch\n// (and would be incorrectly rendered on the client).\n// However, we already warn about bad casing elsewhere.\n// So we'll skip the misleading extra mismatch warning in this case.\nisMismatchDueToBadCasing=true;// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](standardName);}// $FlowFixMe - Should be inferred as not undefined.\nextraAttributeNames[\"delete\"](propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}var dontWarnCustomElement=enableCustomElementPropertySupport;if(!dontWarnCustomElement&&nextProp!==serverValue&&!isMismatchDueToBadCasing){warnForPropDifference(propKey,serverValue,nextProp);}}}}{if(shouldWarnDev){// $FlowFixMe - Should be inferred as not undefined.\nif(extraAttributeNames.size>0&&!suppressHydrationWarning){// $FlowFixMe - Should be inferred as not undefined.\nwarnForExtraAttributes(extraAttributeNames);}}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper(domElement,rawProps,true);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean\n// up necessary since we never stop tracking anymore.\ntrack(domElement);postMountWrapper$3(domElement);break;case'select':case'option':// For input and textarea we current always set the value property at\n// post mount to force it to diverge from attributes. However, for\n// option and select we don't quite do the same thing and select\n// is not resilient to the DOM state changing so we don't do that here.\n// TODO: Consider not doing this for input and textarea.\nbreak;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText(textNode,text,isConcurrentMode){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForDeletedHydratableElement(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain the text node \"%s\" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in\n// the HTML.\n// TODO: Remove this special case if we can just avoid inserting empty\n// text nodes.\nreturn;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching text node for \"%s\" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState$3(domElement,tag,props){switch(tag){case'input':restoreControlledState(domElement,props);return;case'textarea':restoreControlledState$2(domElement,props);return;case'select':restoreControlledState$1(domElement,props);return;}}var validateDOMNesting=function validateDOMNesting(){};var updatedAncestorInfo=function updatedAncestorInfo(){};{// This validation code was written based on the HTML5 parsing spec:\n// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n//\n// Note: this does not catch all invalid nesting, nor does it try to (as it's\n// not clear what practical benefit doing so provides); instead, we warn only\n// for cases where the parser will give a parse tree differing from what React\n// intended. For example, <b><div></div></b> is invalid but we don't warn\n// because it still parses correctly; we do warn for other cases like nested\n// <p> tags where the beginning of the second element implicitly closes the\n// first, causing a confusing mess.\n// https://html.spec.whatwg.org/multipage/syntax.html#special\nvar specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\nvar inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n// TODO: Distinguish by namespace here -- for <title>, including it here\n// errs on the side of fewer warnings\n'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\nvar buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\nvar impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};updatedAncestorInfo=function updatedAncestorInfo(oldInfo,tag){var ancestorInfo=assign({},oldInfo||emptyAncestorInfo);var info={tag:tag};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\nif(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**\n   * Returns whether\n   */var isTagValidWithParent=function isTagValidWithParent(tag,parentTag){// First, let's check if we're in an unusual parsing mode...\nswitch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\ncase'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n// but\ncase'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n// No special behavior since these rules fall back to \"in body\" mode for\n// all except special table nodes which cause bad parsing behavior anyway.\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\ncase'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\ncase'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\ncase'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\ncase'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\ncase'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\ncase'html':return tag==='head'||tag==='body'||tag==='frameset';case'frameset':return tag==='frame';case'#document':return tag==='html';}// Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n// where the parsing rules cause implicit opens or closes to be added.\n// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\nswitch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frameset':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child\n// parsing rules -- if we're down here, then none of those matched and\n// so we allow it only if we don't know what the parent is, as all other\n// cases are invalid.\nreturn parentTag==null;}return true;};/**\n   * Returns whether\n   */var findInvalidAncestorForTag=function findInvalidAncestorForTag(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds\n// equivalent to this check.\nreturn ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn$1={};validateDOMNesting=function validateDOMNesting(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){if(childTag!=null){error('validateDOMNesting: when childText is passed, childTag should be null');}childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag;if(didWarn$1[warnKey]){return;}didWarn$1[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=\" Make sure you don't have any extra whitespace between tags on \"+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by '+'the browser.';}error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info);}else{error('validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.',tagDisplayName,ancestorTag);}};}var SUPPRESS_HYDRATION_WARNING$1;{SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';}var SUSPENSE_START_DATA='$';var SUSPENSE_END_DATA='/$';var SUSPENSE_PENDING_START_DATA='$?';var SUSPENSE_FALLBACK_START_DATA='$!';var STYLE$1='style';var selectionInformation=null;function getRootHostContext(rootContainerInstance){var type;var namespace;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var ancestorInfo=updatedAncestorInfo(null,validatedTag);return{namespace:namespace,ancestorInfo:ancestorInfo};}}function getChildHostContext(parentHostContext,type,rootContainerInstance){{var parentHostContextDev=parentHostContext;var namespace=getChildNamespace(parentHostContextDev.namespace,type);var ancestorInfo=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type);return{namespace:namespace,ancestorInfo:ancestorInfo};}}function getPublicInstance(instance){return instance;}function prepareForCommit(containerInfo){selectionInformation=getSelectionInformation();var activeInstance=null;return activeInstance;}function resetAfterCommit(containerInfo){restoreSelection(selectionInformation);selectionInformation=null;}function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace;{// TODO: take namespace into account when validating.\nvar hostContextDev=hostContext;validateDOMNesting(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;}function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);}function finalizeInitialChildren(domElement,type,props,rootContainerInstance,hostContext){setInitialProperties(domElement,type,props,rootContainerInstance);switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;case'img':return true;default:return false;}}function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(_typeof(newProps.children)!==_typeof(oldProps.children)&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps);}function shouldSetTextContent(type,props){return type==='textarea'||type==='noscript'||typeof props.children==='string'||typeof props.children==='number'||_typeof(props.dangerouslySetInnerHTML)==='object'&&props.dangerouslySetInnerHTML!==null&&props.dangerouslySetInnerHTML.__html!=null;}function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;}function getCurrentEventPriority(){var currentEvent=window.event;if(currentEvent===undefined){return DefaultEventPriority;}return getEventPriority(currentEvent.type);}// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\nvar scheduleTimeout=typeof setTimeout==='function'?setTimeout:undefined;var cancelTimeout=typeof clearTimeout==='function'?clearTimeout:undefined;var noTimeout=-1;var localPromise=typeof Promise==='function'?Promise:undefined;// -------------------\nvar scheduleMicrotask=typeof queueMicrotask==='function'?queueMicrotask:typeof localPromise!=='undefined'?function(callback){return localPromise.resolve(null).then(callback)[\"catch\"](handleErrorInNextTick);}:scheduleTimeout;// TODO: Determine the best fallback here.\nfunction handleErrorInNextTick(error){setTimeout(function(){throw error;});}// -------------------\nfunction commitMount(domElement,type,newProps,internalInstanceHandle){// Despite the naming that might imply otherwise, this method only\n// fires if there is an `Update` effect scheduled during mounting.\n// This happens if `finalizeInitialChildren` returns `true` (which it\n// does to implement the `autoFocus` attribute on the client). But\n// there are also other cases when this might happen (such as patching\n// up text content during hydration mismatch). So we'll check this again.\nswitch(type){case'button':case'input':case'select':case'textarea':if(newProps.autoFocus){domElement.focus();}return;case'img':{if(newProps.src){domElement.src=newProps.src;}return;}}}function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Apply the diff to the DOM node.\nupdateProperties(domElement,updatePayload,type,oldProps,newProps);// Update the props handle so that we know which props are the ones with\n// with current event handlers.\nupdateFiberProps(domElement,newProps);}function resetTextContent(domElement){setTextContent(domElement,'');}function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;}function appendChild(parentInstance,child){parentInstance.appendChild(child);}function appendChildToContainer(container,child){var parentNode;if(container.nodeType===COMMENT_NODE){parentNode=container.parentNode;parentNode.insertBefore(child,container);}else{parentNode=container;parentNode.appendChild(child);}// This container might be used for a portal.\n// If something inside a portal is clicked, that click should bubble\n// through the React tree. However, on Mobile Safari the click would\n// never bubble through the *DOM* tree unless an ancestor with onclick\n// event exists. So we wouldn't see it and dispatch it.\n// This is why we ensure that non React root containers have inline onclick\n// defined.\n// https://github.com/facebook/react/issues/11918\nvar reactRootContainer=container._reactRootContainer;if((reactRootContainer===null||reactRootContainer===undefined)&&parentNode.onclick===null){// TODO: This cast may not be sound for SVG, MathML or custom elements.\ntrapClickOnNonInteractiveElement(parentNode);}}function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);}function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}}function removeChild(parentInstance,child){parentInstance.removeChild(child);}function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}function clearSuspenseBoundary(parentInstance,suspenseInstance){var node=suspenseInstance;// Delete all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;do{var nextNode=node.nextSibling;parentInstance.removeChild(node);if(nextNode&&nextNode.nodeType===COMMENT_NODE){var data=nextNode.data;if(data===SUSPENSE_END_DATA){if(depth===0){parentInstance.removeChild(nextNode);// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);return;}else{depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_PENDING_START_DATA||data===SUSPENSE_FALLBACK_START_DATA){depth++;}}node=nextNode;}while(node);// TODO: Warn, we didn't find the end comment boundary.\n// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);}function clearSuspenseBoundaryFromContainer(container,suspenseInstance){if(container.nodeType===COMMENT_NODE){clearSuspenseBoundary(container.parentNode,suspenseInstance);}else if(container.nodeType===ELEMENT_NODE){clearSuspenseBoundary(container,suspenseInstance);}// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(container);}function hideInstance(instance){// TODO: Does this work for all element types? What about MathML? Should we\n// pass host context to this method?\ninstance=instance;var style=instance.style;if(typeof style.setProperty==='function'){style.setProperty('display','none','important');}else{style.display='none';}}function hideTextInstance(textInstance){textInstance.nodeValue='';}function unhideInstance(instance,props){instance=instance;var styleProp=props[STYLE$1];var display=styleProp!==undefined&&styleProp!==null&&styleProp.hasOwnProperty('display')?styleProp.display:null;instance.style.display=dangerousStyleValue('display',display);}function unhideTextInstance(textInstance,text){textInstance.nodeValue=text;}function clearContainer(container){if(container.nodeType===ELEMENT_NODE){container.textContent='';}else if(container.nodeType===DOCUMENT_NODE){var body=container.body;if(body!=null){body.textContent='';}}}// -------------------\nfunction canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.\nreturn instance;}function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.\nreturn null;}// This has now been refined to a text node.\nreturn instance;}function canHydrateSuspenseInstance(instance){if(instance.nodeType!==COMMENT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.\nreturn null;}// This has now been refined to a suspense node.\nreturn instance;}function isSuspenseInstancePending(instance){return instance.data===SUSPENSE_PENDING_START_DATA;}function isSuspenseInstanceFallback(instance){return instance.data===SUSPENSE_FALLBACK_START_DATA;}function registerSuspenseInstanceRetry(instance,callback){instance._reactRetry=callback;}function getNextHydratable(node){// Skip non-hydratable nodes.\nfor(;node!=null;node=node.nextSibling){var nodeType=node.nodeType;if(nodeType===ELEMENT_NODE||nodeType===TEXT_NODE){break;}{if(nodeType===COMMENT_NODE){var nodeData=node.data;if(nodeData===SUSPENSE_START_DATA||nodeData===SUSPENSE_FALLBACK_START_DATA||nodeData===SUSPENSE_PENDING_START_DATA){break;}if(nodeData===SUSPENSE_END_DATA){return null;}}}}return node;}function getNextHydratableSibling(instance){return getNextHydratable(instance.nextSibling);}function getFirstHydratableChild(parentInstance){return getNextHydratable(parentInstance.firstChild);}function getFirstHydratableChildWithinContainer(parentContainer){return getNextHydratable(parentContainer.firstChild);}function getFirstHydratableChildWithinSuspenseInstance(parentInstance){return getNextHydratable(parentInstance.nextSibling);}function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events\n// get attached.\nupdateFiberProps(instance,props);var parentNamespace;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}// TODO: Temporary hack to check if we're in a concurrent root. We can delete\n// when the legacy root API is removed.\nvar isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance,isConcurrentMode,shouldWarnDev);}function hydrateTextInstance(textInstance,text,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,textInstance);// TODO: Temporary hack to check if we're in a concurrent root. We can delete\n// when the legacy root API is removed.\nvar isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedText(textInstance,text);}function hydrateSuspenseInstance(suspenseInstance,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,suspenseInstance);}function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance){var node=suspenseInstance.nextSibling;// Skip past all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_END_DATA){if(depth===0){return getNextHydratableSibling(node);}else{depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){depth++;}}node=node.nextSibling;}// TODO: Warn, we didn't find the end comment boundary.\nreturn null;}// Returns the SuspenseInstance if this node is a direct child of a\n// SuspenseInstance. I.e. if its previous sibling is a Comment with\n// SUSPENSE_x_START_DATA. Otherwise, null.\nfunction getParentSuspenseInstance(targetInstance){var node=targetInstance.previousSibling;// Skip past all nodes within this suspense boundary.\n// There might be nested nodes so we need to keep track of how\n// deep we are and only break out when we're back on top.\nvar depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){if(depth===0){return node;}else{depth--;}}else if(data===SUSPENSE_END_DATA){depth++;}}node=node.previousSibling;}return null;}function commitHydratedContainer(container){// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(container);}function commitHydratedSuspenseInstance(suspenseInstance){// Retry if any event replaying was blocked on this.\nretryIfBlockedOn(suspenseInstance);}function shouldDeleteUnhydratedTailInstances(parentType){return parentType!=='head'&&parentType!=='body';}function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text,isConcurrentMode){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text,isConcurrentMode){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}}function didNotHydrateInstanceWithinContainer(parentContainer,instance){{if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentContainer,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentContainer,instance);}}}function didNotHydrateInstanceWithinSuspenseInstance(parentInstance,instance){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentNode,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentNode,instance);}}}}function didNotHydrateInstance(parentType,parentProps,parentInstance,instance){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentInstance,instance);}else if(instance.nodeType===COMMENT_NODE);else{warnForDeletedHydratableText(parentInstance,instance);}}}function didNotFindHydratableInstanceWithinContainer(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type);}}function didNotFindHydratableTextInstanceWithinContainer(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}}function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance,type,props){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedElement(parentNode,type);}}function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance,text){{// $FlowFixMe: Only Element or Document can be parent nodes.\nvar parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedText(parentNode,text);}}function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedElement(parentInstance,type);}}function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedText(parentInstance,text);}}function didNotFindHydratableSuspenseInstance(parentType,parentProps,parentInstance){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true);}function errorHydratingContainer(parentContainer){{// TODO: This gets logged by onRecoverableError, too, so we should be\n// able to remove it.\nerror('An error occurred during hydration. The server HTML was replaced with client content in <%s>.',parentContainer.nodeName.toLowerCase());}}function preparePortalMount(portalInstance){listenToAllSupportedEvents(portalInstance);}var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactFiber$'+randomKey;var internalPropsKey='__reactProps$'+randomKey;var internalContainerInstanceKey='__reactContainer$'+randomKey;var internalEventHandlersKey='__reactEvents$'+randomKey;var internalEventHandlerListenersKey='__reactListeners$'+randomKey;var internalEventHandlesSetKey='__reactHandles$'+randomKey;function detachDeletedInstance(node){// TODO: This function is only called on host components. I don't think all of\n// these fields are relevant.\ndelete node[internalInstanceKey];delete node[internalPropsKey];delete node[internalEventHandlersKey];delete node[internalEventHandlerListenersKey];delete node[internalEventHandlesSetKey];}function precacheFiberNode(hostInst,node){node[internalInstanceKey]=hostInst;}function markContainerAsRoot(hostRoot,node){node[internalContainerInstanceKey]=hostRoot;}function unmarkContainerAsRoot(node){node[internalContainerInstanceKey]=null;}function isContainerMarkedAsRoot(node){return!!node[internalContainerInstanceKey];}// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.\n// If the target node is part of a hydrated or not yet rendered subtree, then\n// this may also return a SuspenseComponent or HostRoot to indicate that.\n// Conceptually the HostRoot fiber is a child of the Container node. So if you\n// pass the Container node as the targetNode, you will not actually get the\n// HostRoot back. To get to the HostRoot, you need to pass a child of it.\n// The same thing applies to Suspense boundaries.\nfunction getClosestInstanceFromNode(targetNode){var targetInst=targetNode[internalInstanceKey];if(targetInst){// Don't return HostRoot or SuspenseComponent here.\nreturn targetInst;}// If the direct event target isn't a React owned DOM node, we need to look\n// to see if one of its parents is a React owned DOM node.\nvar parentNode=targetNode.parentNode;while(parentNode){// We'll check if this is a container root that could include\n// React nodes in the future. We need to check this first because\n// if we're a child of a dehydrated container, we need to first\n// find that inner container before moving on to finding the parent\n// instance. Note that we don't check this field on  the targetNode\n// itself because the fibers are conceptually between the container\n// node and the first child. It isn't surrounding the container node.\n// If it's not a container, we check if it's an instance.\ntargetInst=parentNode[internalContainerInstanceKey]||parentNode[internalInstanceKey];if(targetInst){// Since this wasn't the direct target of the event, we might have\n// stepped past dehydrated DOM nodes to get here. However they could\n// also have been non-React nodes. We need to answer which one.\n// If we the instance doesn't have any children, then there can't be\n// a nested suspense boundary within it. So we can use this as a fast\n// bailout. Most of the time, when people add non-React children to\n// the tree, it is using a ref to a child-less DOM node.\n// Normally we'd only need to check one of the fibers because if it\n// has ever gone from having children to deleting them or vice versa\n// it would have deleted the dehydrated boundary nested inside already.\n// However, since the HostRoot starts out with an alternate it might\n// have one on the alternate so we need to check in case this was a\n// root.\nvar alternate=targetInst.alternate;if(targetInst.child!==null||alternate!==null&&alternate.child!==null){// Next we need to figure out if the node that skipped past is\n// nested within a dehydrated boundary and if so, which one.\nvar suspenseInstance=getParentSuspenseInstance(targetNode);while(suspenseInstance!==null){// We found a suspense instance. That means that we haven't\n// hydrated it yet. Even though we leave the comments in the\n// DOM after hydrating, and there are boundaries in the DOM\n// that could already be hydrated, we wouldn't have found them\n// through this pass since if the target is hydrated it would\n// have had an internalInstanceKey on it.\n// Let's get the fiber associated with the SuspenseComponent\n// as the deepest instance.\nvar targetSuspenseInst=suspenseInstance[internalInstanceKey];if(targetSuspenseInst){return targetSuspenseInst;}// If we don't find a Fiber on the comment, it might be because\n// we haven't gotten to hydrate it yet. There might still be a\n// parent boundary that hasn't above this one so we need to find\n// the outer most that is known.\nsuspenseInstance=getParentSuspenseInstance(suspenseInstance);// If we don't find one, then that should mean that the parent\n// host component also hasn't hydrated yet. We can return it\n// below since it will bail out on the isMounted check later.\n}}return targetInst;}targetNode=parentNode;parentNode=targetNode.parentNode;}return null;}/**\n * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n * instance, or null if the node was not rendered by this React.\n */function getInstanceFromNode(node){var inst=node[internalInstanceKey]||node[internalContainerInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText||inst.tag===SuspenseComponent||inst.tag===HostRoot){return inst;}else{return null;}}return null;}/**\n * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n * DOM node.\n */function getNodeFromInstance(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be\n// a host component or host text.\nreturn inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next\n// invariant for a missing parent, which is super confusing.\nthrow new Error('getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode(node){return node[internalPropsKey]||null;}function updateFiberProps(node,props){node[internalPropsKey]=props;}function getEventListenerSet(node){var elementListenerSet=node[internalEventHandlersKey];if(elementListenerSet===undefined){elementListenerSet=node[internalEventHandlersKey]=new Set();}return elementListenerSet;}var loggedTypeFailures={};var ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame;function setCurrentlyValidatingElement(element){{if(element){var owner=element._owner;var stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame$1.setExtraStackFrame(stack);}else{ReactDebugCurrentFrame$1.setExtraStackFrame(null);}}}function checkPropTypes(typeSpecs,values,location,componentName,element){{// $FlowFixMe This is okay but Flow doesn't know it.\nvar has=Function.call.bind(hasOwnProperty);for(var typeSpecName in typeSpecs){if(has(typeSpecs,typeSpecName)){var error$1=void 0;// Prop type validation may throw. In case they do, we don't want to\n// fail the render phase where it didn't fail before. So we log it.\n// After these have been cleaned up, we'll let them throw.\ntry{// This is intentionally an invariant that gets caught. It's the same\n// behavior as without this statement except with a better message.\nif(typeof typeSpecs[typeSpecName]!=='function'){// eslint-disable-next-line react-internal/prod-error-codes\nvar err=Error((componentName||'React class')+': '+location+' type `'+typeSpecName+'` is invalid; '+'it must be a function, usually from the `prop-types` package, but received `'+_typeof(typeSpecs[typeSpecName])+'`.'+'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');err.name='Invariant Violation';throw err;}error$1=typeSpecs[typeSpecName](values,typeSpecName,componentName,location,null,'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');}catch(ex){error$1=ex;}if(error$1&&!(error$1 instanceof Error)){setCurrentlyValidatingElement(element);error('%s: type specification of %s'+' `%s` is invalid; the type checker '+'function must return `null` or an `Error` but returned a %s. '+'You may have forgotten to pass an argument to the type checker '+'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and '+'shape all require an argument).',componentName||'React class',location,typeSpecName,_typeof(error$1));setCurrentlyValidatingElement(null);}if(error$1 instanceof Error&&!(error$1.message in loggedTypeFailures)){// Only monitor this failure once because there tends to be a lot of the\n// same error.\nloggedTypeFailures[error$1.message]=true;setCurrentlyValidatingElement(element);error('Failed %s type: %s',location,error$1.message);setCurrentlyValidatingElement(null);}}}}}var valueStack=[];var fiberStack;{fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{error('Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){error('Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}var warnedAboutMissingGetChildContext;{warnedAboutMissingGetChildContext={};}var emptyContextObject={};{Object.freeze(emptyContextObject);}// A cursor to the current merged context object on the stack.\nvar contextStackCursor=createCursor(emptyContextObject);// A cursor to a boolean indicating whether the context has changed.\nvar didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\nvar previousContext=emptyContextObject;function getUnmaskedContext(workInProgress,Component,didPushOwnContextIfProvider){{if(didPushOwnContextIfProvider&&isContextProvider(Component)){// If the fiber is a context provider itself, when we read its context\n// we may have already pushed its own child context on the stack. A context\n// provider should not \"see\" its own child context. Therefore we read the\n// previous (parent) context instead for a context provider.\nreturn previousContext;}return contextStackCursor.current;}}function cacheContext(workInProgress,unmaskedContext,maskedContext){{var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}}function getMaskedContext(workInProgress,unmaskedContext){{var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyContextObject;}// Avoid recreating masked context unless unmasked context has changed.\n// Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n// This may trigger infinite loops if componentWillReceiveProps calls setState.\nvar instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentNameFromFiber(workInProgress)||'Unknown';checkPropTypes(contextTypes,context,'context',name);}// Cache unmasked context so we can avoid recreating masked context unless necessary.\n// Context is created before the class component is instantiated so check for instance.\nif(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}}function hasContextChanged(){{return didPerformWorkStackCursor.current;}}function isContextProvider(type){{var childContextTypes=type.childContextTypes;return childContextTypes!==null&&childContextTypes!==undefined;}}function popContext(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function popTopLevelContextObject(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function pushTopLevelContextObject(fiber,context,didChange){{if(contextStackCursor.current!==emptyContextObject){throw new Error('Unexpected context found on stack. '+'This error is likely caused by a bug in React. Please file an issue.');}push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}}function processChildContext(fiber,type,parentContext){{var instance=fiber.stateNode;var childContextTypes=type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.\n// It has only been added in Fiber to match the (unintentional) behavior in Stack.\nif(typeof instance.getChildContext!=='function'){{var componentName=getComponentNameFromFiber(fiber)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;error('%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=instance.getChildContext();for(var contextKey in childContext){if(!(contextKey in childContextTypes)){throw new Error((getComponentNameFromFiber(fiber)||'Unknown')+\".getChildContext(): key \\\"\"+contextKey+\"\\\" is not defined in childContextTypes.\");}}{var name=getComponentNameFromFiber(fiber)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name);}return assign({},parentContext,childContext);}}function pushContextProvider(workInProgress){{var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.\n// If the instance does not exist yet, we will push null at first,\n// and replace it on the stack later when invalidating the context.\nvar memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyContextObject;// Remember the parent context so we can merge with it later.\n// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\npreviousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}}function invalidateContextProvider(workInProgress,type,didChange){{var instance=workInProgress.stateNode;if(!instance){throw new Error('Expected to have an instance by this point. '+'This error is likely caused by a bug in React. Please file an issue.');}if(didChange){// Merge parent and own context.\n// Skip this if we're not updating due to sCU.\n// This avoids unnecessarily recomputing memoized values.\nvar mergedContext=processChildContext(workInProgress,type,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.\n// It is important to unwind the context in the reverse order.\npop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.\npush(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}}function findCurrentUnmaskedContext(fiber){{// Currently this is only used with renderSubtreeIntoContainer; not sure if it\n// makes sense elsewhere\nif(!isFiberMounted(fiber)||fiber.tag!==ClassComponent){throw new Error('Expected subtree parent to be a mounted class component. '+'This error is likely caused by a bug in React. Please file an issue.');}var node=fiber;do{switch(node.tag){case HostRoot:return node.stateNode.context;case ClassComponent:{var Component=node.type;if(isContextProvider(Component)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}break;}}node=node[\"return\"];}while(node!==null);throw new Error('Found unexpected detached subtree parent. '+'This error is likely caused by a bug in React. Please file an issue.');}}var LegacyRoot=0;var ConcurrentRoot=1;var syncQueue=null;var includesLegacySyncCallbacks=false;var isFlushingSyncQueue=false;function scheduleSyncCallback(callback){// Push this callback into an internal queue. We'll flush these either in\n// the next tick, or earlier if something calls `flushSyncCallbackQueue`.\nif(syncQueue===null){syncQueue=[callback];}else{// Push onto existing queue. Don't need to schedule a callback because\n// we already scheduled one when we created the queue.\nsyncQueue.push(callback);}}function scheduleLegacySyncCallback(callback){includesLegacySyncCallbacks=true;scheduleSyncCallback(callback);}function flushSyncCallbacksOnlyInLegacyMode(){// Only flushes the queue if there's a legacy sync callback scheduled.\n// TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\n// it might make more sense for the queue to be a list of roots instead of a\n// list of generic callbacks. Then we can have two: one for legacy roots, one\n// for concurrent roots. And this method would only flush the legacy ones.\nif(includesLegacySyncCallbacks){flushSyncCallbacks();}}function flushSyncCallbacks(){if(!isFlushingSyncQueue&&syncQueue!==null){// Prevent re-entrance.\nisFlushingSyncQueue=true;var i=0;var previousUpdatePriority=getCurrentUpdatePriority();try{var isSync=true;var queue=syncQueue;// TODO: Is this necessary anymore? The only user code that runs in this\n// queue is in the render or commit phases.\nsetCurrentUpdatePriority(DiscreteEventPriority);for(;i<queue.length;i++){var callback=queue[i];do{callback=callback(isSync);}while(callback!==null);}syncQueue=null;includesLegacySyncCallbacks=false;}catch(error){// If something throws, leave the remaining callbacks on the queue.\nif(syncQueue!==null){syncQueue=syncQueue.slice(i+1);}// Resume flushing in the next tick\nscheduleCallback(ImmediatePriority,flushSyncCallbacks);throw error;}finally{setCurrentUpdatePriority(previousUpdatePriority);isFlushingSyncQueue=false;}}return null;}var ReactCurrentBatchConfig$1=ReactSharedInternals.ReactCurrentBatchConfig;var NoTransition=null;function requestCurrentTransition(){return ReactCurrentBatchConfig$1.transition;}var ReactStrictModeWarnings={recordUnsafeLifecycleWarnings:function recordUnsafeLifecycleWarnings(fiber,instance){},flushPendingUnsafeLifecycleWarnings:function flushPendingUnsafeLifecycleWarnings(){},recordLegacyContextWarning:function recordLegacyContextWarning(fiber,instance){},flushLegacyContextWarning:function flushLegacyContextWarning(){},discardPendingWarnings:function discardPendingWarnings(){}};{var findStrictRoot=function findStrictRoot(fiber){var maybeStrictRoot=null;var node=fiber;while(node!==null){if(node.mode&StrictLegacyMode){maybeStrictRoot=node;}node=node[\"return\"];}return maybeStrictRoot;};var setToSortedString=function setToSortedString(set){var array=[];set.forEach(function(value){array.push(value);});return array.sort().join(', ');};var pendingComponentWillMountWarnings=[];var pendingUNSAFE_ComponentWillMountWarnings=[];var pendingComponentWillReceivePropsWarnings=[];var pendingUNSAFE_ComponentWillReceivePropsWarnings=[];var pendingComponentWillUpdateWarnings=[];var pendingUNSAFE_ComponentWillUpdateWarnings=[];// Tracks components we have already warned about.\nvar didWarnAboutUnsafeLifecycles=new Set();ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance){// Dedupe strategy: Warn once per component.\nif(didWarnAboutUnsafeLifecycles.has(fiber.type)){return;}if(typeof instance.componentWillMount==='function'&&// Don't warn about react-lifecycles-compat polyfilled components.\ninstance.componentWillMount.__suppressDeprecationWarning!==true){pendingComponentWillMountWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillMount==='function'){pendingUNSAFE_ComponentWillMountWarnings.push(fiber);}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){pendingComponentWillReceivePropsWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillReceiveProps==='function'){pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){pendingComponentWillUpdateWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillUpdate==='function'){pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);}};ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function(){// We do an initial pass to gather component names\nvar componentWillMountUniqueNames=new Set();if(pendingComponentWillMountWarnings.length>0){pendingComponentWillMountWarnings.forEach(function(fiber){componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillMountWarnings=[];}var UNSAFE_componentWillMountUniqueNames=new Set();if(pendingUNSAFE_ComponentWillMountWarnings.length>0){pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber){UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillMountWarnings=[];}var componentWillReceivePropsUniqueNames=new Set();if(pendingComponentWillReceivePropsWarnings.length>0){pendingComponentWillReceivePropsWarnings.forEach(function(fiber){componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillReceivePropsWarnings=[];}var UNSAFE_componentWillReceivePropsUniqueNames=new Set();if(pendingUNSAFE_ComponentWillReceivePropsWarnings.length>0){pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber){UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillReceivePropsWarnings=[];}var componentWillUpdateUniqueNames=new Set();if(pendingComponentWillUpdateWarnings.length>0){pendingComponentWillUpdateWarnings.forEach(function(fiber){componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillUpdateWarnings=[];}var UNSAFE_componentWillUpdateUniqueNames=new Set();if(pendingUNSAFE_ComponentWillUpdateWarnings.length>0){pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber){UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillUpdateWarnings=[];}// Finally, we flush all the warnings\n// UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\nif(UNSAFE_componentWillMountUniqueNames.size>0){var sortedNames=setToSortedString(UNSAFE_componentWillMountUniqueNames);error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n'+'\\nPlease update the following components: %s',sortedNames);}if(UNSAFE_componentWillReceivePropsUniqueNames.size>0){var _sortedNames=setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+\"* If you're updating state whenever props change, \"+'refactor your code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n'+'\\nPlease update the following components: %s',_sortedNames);}if(UNSAFE_componentWillUpdateUniqueNames.size>0){var _sortedNames2=setToSortedString(UNSAFE_componentWillUpdateUniqueNames);error('Using UNSAFE_componentWillUpdate in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+'\\nPlease update the following components: %s',_sortedNames2);}if(componentWillMountUniqueNames.size>0){var _sortedNames3=setToSortedString(componentWillMountUniqueNames);warn('componentWillMount has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n'+'* Rename componentWillMount to UNSAFE_componentWillMount to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames3);}if(componentWillReceivePropsUniqueNames.size>0){var _sortedNames4=setToSortedString(componentWillReceivePropsUniqueNames);warn('componentWillReceiveProps has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+\"* If you're updating state whenever props change, refactor your \"+'code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n'+'* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames4);}if(componentWillUpdateUniqueNames.size>0){var _sortedNames5=setToSortedString(componentWillUpdateUniqueNames);warn('componentWillUpdate has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+'* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames5);}};var pendingLegacyContextWarning=new Map();// Tracks components we have already warned about.\nvar didWarnAboutLegacyContext=new Set();ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){error('Expected to find a StrictMode component in a strict mode tree. '+'This error is likely caused by a bug in React. Please file an issue.');return;}// Dedup strategy: Warn once per component.\nif(didWarnAboutLegacyContext.has(fiber.type)){return;}var warningsForRoot=pendingLegacyContextWarning.get(strictRoot);if(fiber.type.contextTypes!=null||fiber.type.childContextTypes!=null||instance!==null&&typeof instance.getChildContext==='function'){if(warningsForRoot===undefined){warningsForRoot=[];pendingLegacyContextWarning.set(strictRoot,warningsForRoot);}warningsForRoot.push(fiber);}};ReactStrictModeWarnings.flushLegacyContextWarning=function(){pendingLegacyContextWarning.forEach(function(fiberArray,strictRoot){if(fiberArray.length===0){return;}var firstFiber=fiberArray[0];var uniqueNames=new Set();fiberArray.forEach(function(fiber){uniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutLegacyContext.add(fiber.type);});var sortedNames=setToSortedString(uniqueNames);try{setCurrentFiber(firstFiber);error('Legacy context API has been detected within a strict-mode tree.'+'\\n\\nThe old API will be supported in all 16.x releases, but applications '+'using it should migrate to the new version.'+'\\n\\nPlease update the following components: %s'+'\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context',sortedNames);}finally{resetCurrentFiber();}});};ReactStrictModeWarnings.discardPendingWarnings=function(){pendingComponentWillMountWarnings=[];pendingUNSAFE_ComponentWillMountWarnings=[];pendingComponentWillReceivePropsWarnings=[];pendingUNSAFE_ComponentWillReceivePropsWarnings=[];pendingComponentWillUpdateWarnings=[];pendingUNSAFE_ComponentWillUpdateWarnings=[];pendingLegacyContextWarning=new Map();};}function resolveDefaultProps(Component,baseProps){if(Component&&Component.defaultProps){// Resolve default props. Taken from ReactElement\nvar props=assign({},baseProps);var defaultProps=Component.defaultProps;for(var propName in defaultProps){if(props[propName]===undefined){props[propName]=defaultProps[propName];}}return props;}return baseProps;}var valueCursor=createCursor(null);var rendererSigil;{// Use this to detect multiple renderers using the same context\nrendererSigil={};}var currentlyRenderingFiber=null;var lastContextDependency=null;var lastFullyObservedContext=null;var isDisallowedContextReadInDEV=false;function resetContextDependencies(){// This is called right before React yields execution, to ensure `readContext`\n// cannot be called outside the render phase.\ncurrentlyRenderingFiber=null;lastContextDependency=null;lastFullyObservedContext=null;{isDisallowedContextReadInDEV=false;}}function enterDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=true;}}function exitDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=false;}}function pushProvider(providerFiber,context,nextValue){{push(valueCursor,context._currentValue,providerFiber);context._currentValue=nextValue;{if(context._currentRenderer!==undefined&&context._currentRenderer!==null&&context._currentRenderer!==rendererSigil){error('Detected multiple renderers concurrently rendering the '+'same context provider. This is currently unsupported.');}context._currentRenderer=rendererSigil;}}}function popProvider(context,providerFiber){var currentValue=valueCursor.current;pop(valueCursor,providerFiber);{{context._currentValue=currentValue;}}}function scheduleContextWorkOnParentPath(parent,renderLanes,propagationRoot){// Update the child lanes of all the ancestors, including the alternates.\nvar node=parent;while(node!==null){var alternate=node.alternate;if(!isSubsetOfLanes(node.childLanes,renderLanes)){node.childLanes=mergeLanes(node.childLanes,renderLanes);if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}}else if(alternate!==null&&!isSubsetOfLanes(alternate.childLanes,renderLanes)){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}if(node===propagationRoot){break;}node=node[\"return\"];}{if(node!==propagationRoot){error('Expected to find the propagation root when scheduling context work. '+'This error is likely caused by a bug in React. Please file an issue.');}}}function propagateContextChange(workInProgress,context,renderLanes){{propagateContextChange_eager(workInProgress,context,renderLanes);}}function propagateContextChange_eager(workInProgress,context,renderLanes){var fiber=workInProgress.child;if(fiber!==null){// Set the return pointer of the child to the work-in-progress fiber.\nfiber[\"return\"]=workInProgress;}while(fiber!==null){var nextFiber=void 0;// Visit this fiber.\nvar list=fiber.dependencies;if(list!==null){nextFiber=fiber.child;var dependency=list.firstContext;while(dependency!==null){// Check if the context matches.\nif(dependency.context===context){// Match! Schedule an update on this fiber.\nif(fiber.tag===ClassComponent){// Schedule a force update on the work-in-progress.\nvar lane=pickArbitraryLane(renderLanes);var update=createUpdate(NoTimestamp,lane);update.tag=ForceUpdate;// TODO: Because we don't have a work-in-progress, this will add the\n// update to the current fiber, too, which means it will persist even if\n// this render is thrown away. Since it's a race condition, not sure it's\n// worth fixing.\n// Inlined `enqueueUpdate` to remove interleaved update check\nvar updateQueue=fiber.updateQueue;if(updateQueue===null);else{var sharedQueue=updateQueue.shared;var pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}sharedQueue.pending=update;}}fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber[\"return\"],renderLanes,workInProgress);// Mark the updated lanes on the list, too.\nlist.lanes=mergeLanes(list.lanes,renderLanes);// Since we already found a match, we can stop traversing the\n// dependency list.\nbreak;}dependency=dependency.next;}}else if(fiber.tag===ContextProvider){// Don't scan deeper if this is a matching provider\nnextFiber=fiber.type===workInProgress.type?null:fiber.child;}else if(fiber.tag===DehydratedFragment){// If a dehydrated suspense boundary is in this subtree, we don't know\n// if it will have any context consumers in it. The best we can do is\n// mark it as having updates.\nvar parentSuspense=fiber[\"return\"];if(parentSuspense===null){throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');}parentSuspense.lanes=mergeLanes(parentSuspense.lanes,renderLanes);var _alternate=parentSuspense.alternate;if(_alternate!==null){_alternate.lanes=mergeLanes(_alternate.lanes,renderLanes);}// This is intentionally passing this fiber as the parent\n// because we want to schedule this fiber as having work\n// on its children. We'll use the childLanes on\n// this fiber to indicate that a context has changed.\nscheduleContextWorkOnParentPath(parentSuspense,renderLanes,workInProgress);nextFiber=fiber.sibling;}else{// Traverse down.\nnextFiber=fiber.child;}if(nextFiber!==null){// Set the return pointer of the child to the work-in-progress fiber.\nnextFiber[\"return\"]=fiber;}else{// No child. Traverse to next sibling.\nnextFiber=fiber;while(nextFiber!==null){if(nextFiber===workInProgress){// We're back to the root of this subtree. Exit.\nnextFiber=null;break;}var sibling=nextFiber.sibling;if(sibling!==null){// Set the return pointer of the sibling to the work-in-progress fiber.\nsibling[\"return\"]=nextFiber[\"return\"];nextFiber=sibling;break;}// No more siblings. Traverse up.\nnextFiber=nextFiber[\"return\"];}}fiber=nextFiber;}}function prepareToReadContext(workInProgress,renderLanes){currentlyRenderingFiber=workInProgress;lastContextDependency=null;lastFullyObservedContext=null;var dependencies=workInProgress.dependencies;if(dependencies!==null){{var firstContext=dependencies.firstContext;if(firstContext!==null){if(includesSomeLane(dependencies.lanes,renderLanes)){// Context list has a pending update. Mark that this fiber performed work.\nmarkWorkInProgressReceivedUpdate();}// Reset the work-in-progress list\ndependencies.firstContext=null;}}}}function _readContext(context){{// This warning would fire if you read context inside a Hook like useMemo.\n// Unlike the class check below, it's not enforced in production for perf.\nif(isDisallowedContextReadInDEV){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}}var value=context._currentValue;if(lastFullyObservedContext===context);else{var contextItem={context:context,memoizedValue:value,next:null};if(lastContextDependency===null){if(currentlyRenderingFiber===null){throw new Error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}// This is the first dependency for this component. Create a new list.\nlastContextDependency=contextItem;currentlyRenderingFiber.dependencies={lanes:NoLanes,firstContext:contextItem};}else{// Append a new context item.\nlastContextDependency=lastContextDependency.next=contextItem;}}return value;}// An array of all update queues that received updates during the current\n// render. When this render exits, either because it finishes or because it is\n// interrupted, the interleaved updates will be transferred onto the main part\n// of the queue.\nvar interleavedQueues=null;function pushInterleavedQueue(queue){if(interleavedQueues===null){interleavedQueues=[queue];}else{interleavedQueues.push(queue);}}function enqueueInterleavedUpdates(){// Transfer the interleaved updates onto the main queue. Each queue has a\n// `pending` field and an `interleaved` field. When they are not null, they\n// point to the last node in a circular linked list. We need to append the\n// interleaved list to the end of the pending list by joining them into a\n// single, circular list.\nif(interleavedQueues!==null){for(var i=0;i<interleavedQueues.length;i++){var queue=interleavedQueues[i];var lastInterleavedUpdate=queue.interleaved;if(lastInterleavedUpdate!==null){queue.interleaved=null;var firstInterleavedUpdate=lastInterleavedUpdate.next;var lastPendingUpdate=queue.pending;if(lastPendingUpdate!==null){var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=firstInterleavedUpdate;lastInterleavedUpdate.next=firstPendingUpdate;}queue.pending=lastInterleavedUpdate;}}interleavedQueues=null;}}var UpdateState=0;var ReplaceState=1;var ForceUpdate=2;var CaptureUpdate=3;// Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\nvar hasForceUpdate=false;var didWarnUpdateInsideUpdate;var currentlyProcessingQueue;{didWarnUpdateInsideUpdate=false;currentlyProcessingQueue=null;}function initializeUpdateQueue(fiber){var queue={baseState:fiber.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:NoLanes},effects:null};fiber.updateQueue=queue;}function cloneUpdateQueue(current,workInProgress){// Clone the update queue from current. Unless it's already a clone.\nvar queue=workInProgress.updateQueue;var currentQueue=current.updateQueue;if(queue===currentQueue){var clone={baseState:currentQueue.baseState,firstBaseUpdate:currentQueue.firstBaseUpdate,lastBaseUpdate:currentQueue.lastBaseUpdate,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=clone;}}function createUpdate(eventTime,lane){var update={eventTime:eventTime,lane:lane,tag:UpdateState,payload:null,callback:null,next:null};return update;}function enqueueUpdate(fiber,update,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.\nreturn;}var sharedQueue=updateQueue.shared;if(isInterleavedUpdate(fiber)){var interleaved=sharedQueue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushInterleavedQueue(sharedQueue);}else{update.next=interleaved.next;interleaved.next=update;}sharedQueue.interleaved=update;}else{var pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}sharedQueue.pending=update;}{if(currentlyProcessingQueue===sharedQueue&&!didWarnUpdateInsideUpdate){error('An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}}function entangleTransitions(root,fiber,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.\nreturn;}var sharedQueue=updateQueue.shared;if(isTransitionLane(lane)){var queueLanes=sharedQueue.lanes;// If any entangled lanes are no longer pending on the root, then they must\n// have finished. We can remove them from the shared queue, which represents\n// a superset of the actually pending lanes. In some cases we may entangle\n// more than we need to, but that's OK. In fact it's worse if we *don't*\n// entangle when we should.\nqueueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.\nvar newQueueLanes=mergeLanes(queueLanes,lane);sharedQueue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if\n// the lane finished since the last time we entangled it. So we need to\n// entangle it again, just to be sure.\nmarkRootEntangled(root,newQueueLanes);}}function enqueueCapturedUpdate(workInProgress,capturedUpdate){// Captured updates are updates that are thrown by a child during the render\n// phase. They should be discarded if the render is aborted. Therefore,\n// we should only put them on the work-in-progress queue, not the current one.\nvar queue=workInProgress.updateQueue;// Check if the work-in-progress queue is a clone.\nvar current=workInProgress.alternate;if(current!==null){var currentQueue=current.updateQueue;if(queue===currentQueue){// The work-in-progress queue is the same as current. This happens when\n// we bail out on a parent fiber that then captures an error thrown by\n// a child. Since we want to append the update only to the work-in\n// -progress queue, we need to clone the updates. We usually clone during\n// processUpdateQueue, but that didn't happen in this case because we\n// skipped over the parent when we bailed out.\nvar newFirst=null;var newLast=null;var firstBaseUpdate=queue.firstBaseUpdate;if(firstBaseUpdate!==null){// Loop through the updates and clone them.\nvar update=firstBaseUpdate;do{var clone={eventTime:update.eventTime,lane:update.lane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLast===null){newFirst=newLast=clone;}else{newLast.next=clone;newLast=clone;}update=update.next;}while(update!==null);// Append the captured update the end of the cloned list.\nif(newLast===null){newFirst=newLast=capturedUpdate;}else{newLast.next=capturedUpdate;newLast=capturedUpdate;}}else{// There are no base updates.\nnewFirst=newLast=capturedUpdate;}queue={baseState:currentQueue.baseState,firstBaseUpdate:newFirst,lastBaseUpdate:newLast,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=queue;return;}}// Append the update to the end of the list.\nvar lastBaseUpdate=queue.lastBaseUpdate;if(lastBaseUpdate===null){queue.firstBaseUpdate=capturedUpdate;}else{lastBaseUpdate.next=capturedUpdate;}queue.lastBaseUpdate=capturedUpdate;}function getStateFromUpdate(workInProgress,queue,update,prevState,nextProps,instance){switch(update.tag){case ReplaceState:{var payload=update.payload;if(typeof payload==='function'){// Updater function\n{enterDisallowedContextReadInDEV();}var nextState=payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}return nextState;}// State object\nreturn payload;}case CaptureUpdate:{workInProgress.flags=workInProgress.flags&~ShouldCapture|DidCapture;}// Intentional fallthrough\ncase UpdateState:{var _payload=update.payload;var partialState;if(typeof _payload==='function'){// Updater function\n{enterDisallowedContextReadInDEV();}partialState=_payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{_payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}}else{// Partial state object\npartialState=_payload;}if(partialState===null||partialState===undefined){// Null and undefined are treated as no-ops.\nreturn prevState;}// Merge the partial state and the previous state.\nreturn assign({},prevState,partialState);}case ForceUpdate:{hasForceUpdate=true;return prevState;}}return prevState;}function processUpdateQueue(workInProgress,props,instance,renderLanes){// This is always non-null on a ClassComponent or HostRoot\nvar queue=workInProgress.updateQueue;hasForceUpdate=false;{currentlyProcessingQueue=queue.shared;}var firstBaseUpdate=queue.firstBaseUpdate;var lastBaseUpdate=queue.lastBaseUpdate;// Check if there are pending updates. If so, transfer them to the base queue.\nvar pendingQueue=queue.shared.pending;if(pendingQueue!==null){queue.shared.pending=null;// The pending queue is circular. Disconnect the pointer between first\n// and last so that it's non-circular.\nvar lastPendingUpdate=pendingQueue;var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=null;// Append pending updates to base queue\nif(lastBaseUpdate===null){firstBaseUpdate=firstPendingUpdate;}else{lastBaseUpdate.next=firstPendingUpdate;}lastBaseUpdate=lastPendingUpdate;// If there's a current queue, and it's different from the base queue, then\n// we need to transfer the updates to that queue, too. Because the base\n// queue is a singly-linked list with no cycles, we can append to both\n// lists and take advantage of structural sharing.\n// TODO: Pass `current` as argument\nvar current=workInProgress.alternate;if(current!==null){// This is always non-null on a ClassComponent or HostRoot\nvar currentQueue=current.updateQueue;var currentLastBaseUpdate=currentQueue.lastBaseUpdate;if(currentLastBaseUpdate!==lastBaseUpdate){if(currentLastBaseUpdate===null){currentQueue.firstBaseUpdate=firstPendingUpdate;}else{currentLastBaseUpdate.next=firstPendingUpdate;}currentQueue.lastBaseUpdate=lastPendingUpdate;}}}// These values may change as we process the queue.\nif(firstBaseUpdate!==null){// Iterate through the list of updates to compute the result.\nvar newState=queue.baseState;// TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n// from the original lanes.\nvar newLanes=NoLanes;var newBaseState=null;var newFirstBaseUpdate=null;var newLastBaseUpdate=null;var update=firstBaseUpdate;do{var updateLane=update.lane;var updateEventTime=update.eventTime;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first\n// skipped update, the previous update/state is the new base\n// update/state.\nvar clone={eventTime:updateEventTime,lane:updateLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLastBaseUpdate===null){newFirstBaseUpdate=newLastBaseUpdate=clone;newBaseState=newState;}else{newLastBaseUpdate=newLastBaseUpdate.next=clone;}// Update the remaining priority in the queue.\nnewLanes=mergeLanes(newLanes,updateLane);}else{// This update does have sufficient priority.\nif(newLastBaseUpdate!==null){var _clone={eventTime:updateEventTime,// This update is going to be committed so we never want uncommit\n// it. Using NoLane works because 0 is a subset of all bitmasks, so\n// this will never be skipped by the check above.\nlane:NoLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};newLastBaseUpdate=newLastBaseUpdate.next=_clone;}// Process this update.\nnewState=getStateFromUpdate(workInProgress,queue,update,newState,props,instance);var callback=update.callback;if(callback!==null&&// If the update was already committed, we should not queue its\n// callback again.\nupdate.lane!==NoLane){workInProgress.flags|=Callback;var effects=queue.effects;if(effects===null){queue.effects=[update];}else{effects.push(update);}}}update=update.next;if(update===null){pendingQueue=queue.shared.pending;if(pendingQueue===null){break;}else{// An update was scheduled from inside a reducer. Add the new\n// pending updates to the end of the list and keep processing.\nvar _lastPendingUpdate=pendingQueue;// Intentionally unsound. Pending updates form a circular list, but we\n// unravel them when transferring them to the base queue.\nvar _firstPendingUpdate=_lastPendingUpdate.next;_lastPendingUpdate.next=null;update=_firstPendingUpdate;queue.lastBaseUpdate=_lastPendingUpdate;queue.shared.pending=null;}}}while(true);if(newLastBaseUpdate===null){newBaseState=newState;}queue.baseState=newBaseState;queue.firstBaseUpdate=newFirstBaseUpdate;queue.lastBaseUpdate=newLastBaseUpdate;// Interleaved updates are stored on a separate queue. We aren't going to\n// process them during this render, but we do need to track which lanes\n// are remaining.\nvar lastInterleaved=queue.shared.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{newLanes=mergeLanes(newLanes,interleaved.lane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(firstBaseUpdate===null){// `queue.lanes` is used for entangling transitions. We can set it back to\n// zero once the queue is empty.\nqueue.shared.lanes=NoLanes;}// Set the remaining expiration time to be whatever is remaining in the queue.\n// This should be fine because the only two other things that contribute to\n// expiration time are props and context. We're already in the middle of the\n// begin phase by the time we start processing the queue, so we've already\n// dealt with the props. Context in components that specify\n// shouldComponentUpdate is tricky; but we'll have to account for\n// that regardless.\nmarkSkippedUpdateLanes(newLanes);workInProgress.lanes=newLanes;workInProgress.memoizedState=newState;}{currentlyProcessingQueue=null;}}function callCallback(callback,context){if(typeof callback!=='function'){throw new Error('Invalid argument passed as callback. Expected a function. Instead '+(\"received: \"+callback));}callback.call(context);}function resetHasForceUpdateBeforeProcessing(){hasForceUpdate=false;}function checkHasForceUpdateAfterProcessing(){return hasForceUpdate;}function commitUpdateQueue(finishedWork,finishedQueue,instance){// Commit the effects\nvar effects=finishedQueue.effects;finishedQueue.effects=null;if(effects!==null){for(var i=0;i<effects.length;i++){var effect=effects[i];var callback=effect.callback;if(callback!==null){effect.callback=null;callCallback(callback,instance);}}}}var fakeInternalInstance={};// React.Component uses a shared frozen object by default.\n// We'll use it to determine whether we need to initialize legacy refs.\nvar emptyRefsObject=new React.Component().refs;var didWarnAboutStateAssignmentForComponent;var didWarnAboutUninitializedState;var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;var didWarnAboutLegacyLifecyclesAndDerivedState;var didWarnAboutUndefinedDerivedState;var warnOnUndefinedDerivedState;var warnOnInvalidCallback;var didWarnAboutDirectlyAssigningPropsToState;var didWarnAboutContextTypeAndContextTypes;var didWarnAboutInvalidateContextType;{didWarnAboutStateAssignmentForComponent=new Set();didWarnAboutUninitializedState=new Set();didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=new Set();didWarnAboutLegacyLifecyclesAndDerivedState=new Set();didWarnAboutDirectlyAssigningPropsToState=new Set();didWarnAboutUndefinedDerivedState=new Set();didWarnAboutContextTypeAndContextTypes=new Set();didWarnAboutInvalidateContextType=new Set();var didWarnOnInvalidCallback=new Set();warnOnInvalidCallback=function warnOnInvalidCallback(callback,callerName){if(callback===null||typeof callback==='function'){return;}var key=callerName+'_'+callback;if(!didWarnOnInvalidCallback.has(key)){didWarnOnInvalidCallback.add(key);error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}};warnOnUndefinedDerivedState=function warnOnUndefinedDerivedState(type,partialState){if(partialState===undefined){var componentName=getComponentNameFromType(type)||'Component';if(!didWarnAboutUndefinedDerivedState.has(componentName)){didWarnAboutUndefinedDerivedState.add(componentName);error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. '+'You have returned undefined.',componentName);}}};// This is so gross but it's at least non-critical and can be removed if\n// it causes problems. This is meant to give a nicer error message for\n// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n// ...)) which otherwise throws a \"_processChildContext is not a function\"\n// exception.\nObject.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function value(){throw new Error('_processChildContext is not available in React 16+. This likely '+'means you have multiple copies of React and are attempting to nest '+'a React 15 tree inside a React 16 tree using '+\"unstable_renderSubtreeIntoContainer, which isn't supported. Try \"+'to make sure you have only one copy of React (and ideally, switch '+'to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}function applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,nextProps){var prevState=workInProgress.memoizedState;var partialState=getDerivedStateFromProps(nextProps,prevState);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.\npartialState=getDerivedStateFromProps(nextProps,prevState);}finally{setIsStrictModeForDevtools(false);}}warnOnUndefinedDerivedState(ctor,partialState);}// Merge the partial state and the previous state.\nvar memoizedState=partialState===null||partialState===undefined?prevState:assign({},prevState,partialState);workInProgress.memoizedState=memoizedState;// Once the update queue is empty, persist the derived state onto the\n// base state.\nif(workInProgress.lanes===NoLanes){// Queue is always non-null for classes\nvar updateQueue=workInProgress.updateQueue;updateQueue.baseState=memoizedState;}}var classComponentUpdater={isMounted:isMounted,enqueueSetState:function enqueueSetState(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'setState');}update.callback=callback;}enqueueUpdate(fiber,update);var root=scheduleUpdateOnFiber(fiber,lane,eventTime);if(root!==null){entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueReplaceState:function enqueueReplaceState(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ReplaceState;update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'replaceState');}update.callback=callback;}enqueueUpdate(fiber,update);var root=scheduleUpdateOnFiber(fiber,lane,eventTime);if(root!==null){entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueForceUpdate:function enqueueForceUpdate(inst,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ForceUpdate;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'forceUpdate');}update.callback=callback;}enqueueUpdate(fiber,update);var root=scheduleUpdateOnFiber(fiber,lane,eventTime);if(root!==null){entangleTransitions(root,fiber,lane);}{markForceUpdateScheduled(fiber,lane);}}};function checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext){var instance=workInProgress.stateNode;if(typeof instance.shouldComponentUpdate==='function'){var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.\nshouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);}finally{setIsStrictModeForDevtools(false);}}if(shouldUpdate===undefined){error('%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentNameFromType(ctor)||'Component');}}return shouldUpdate;}if(ctor.prototype&&ctor.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress,ctor,newProps){var instance=workInProgress.stateNode;{var name=getComponentNameFromType(ctor)||'Component';var renderPresent=instance.render;if(!renderPresent){if(ctor.prototype&&typeof ctor.prototype.render==='function'){error('%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{error('%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}if(instance.getInitialState&&!instance.getInitialState.isReactClassApproved&&!instance.state){error('getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);}if(instance.getDefaultProps&&!instance.getDefaultProps.isReactClassApproved){error('getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);}if(instance.propTypes){error('propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);}if(instance.contextType){error('contextType was defined as an instance property on %s. Use a static '+'property to define contextType instead.',name);}{if(instance.contextTypes){error('contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);}if(ctor.contextType&&ctor.contextTypes&&!didWarnAboutContextTypeAndContextTypes.has(ctor)){didWarnAboutContextTypeAndContextTypes.add(ctor);error('%s declares both contextTypes and contextType static properties. '+'The legacy contextTypes property will be ignored.',name);}}if(typeof instance.componentShouldUpdate==='function'){error('%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);}if(ctor.prototype&&ctor.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){error('%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentNameFromType(ctor)||'A pure component');}if(typeof instance.componentDidUnmount==='function'){error('%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);}if(typeof instance.componentDidReceiveProps==='function'){error('%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);}if(typeof instance.componentWillRecieveProps==='function'){error('%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);}if(typeof instance.UNSAFE_componentWillRecieveProps==='function'){error('%s has a method called '+'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',name);}var hasMutatedProps=instance.props!==newProps;if(instance.props!==undefined&&hasMutatedProps){error('%s(...): When calling super() in `%s`, make sure to pass '+\"up the same props that your component's constructor was passed.\",name,name);}if(instance.defaultProps){error('Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}if(typeof instance.getSnapshotBeforeUpdate==='function'&&typeof instance.componentDidUpdate!=='function'&&!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)){didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). '+'This component defines getSnapshotBeforeUpdate() only.',getComponentNameFromType(ctor));}if(typeof instance.getDerivedStateFromProps==='function'){error('%s: getDerivedStateFromProps() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof instance.getDerivedStateFromError==='function'){error('%s: getDerivedStateFromError() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof ctor.getSnapshotBeforeUpdate==='function'){error('%s: getSnapshotBeforeUpdate() is defined as a static method '+'and will be ignored. Instead, declare it as an instance method.',name);}var _state=instance.state;if(_state&&(_typeof(_state)!=='object'||isArray(_state))){error('%s.state: must be set to an object or null',name);}if(typeof instance.getChildContext==='function'&&_typeof(ctor.childContextTypes)!=='object'){error('%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',name);}}}function adoptClassInstance(workInProgress,instance){instance.updater=classComponentUpdater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates\nset(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,ctor,props){var isLegacyContextConsumer=false;var unmaskedContext=emptyContextObject;var context=emptyContextObject;var contextType=ctor.contextType;{if('contextType'in ctor){var isValid=// Allow null for conditional declaration\ncontextType===null||contextType!==undefined&&contextType.$$typeof===REACT_CONTEXT_TYPE&&contextType._context===undefined;// Not a <Context.Consumer>\nif(!isValid&&!didWarnAboutInvalidateContextType.has(ctor)){didWarnAboutInvalidateContextType.add(ctor);var addendum='';if(contextType===undefined){addendum=' However, it is set to undefined. '+'This can be caused by a typo or by mixing up named and default imports. '+'This can also happen due to a circular dependency, so '+'try moving the createContext() call to a separate file.';}else if(_typeof(contextType)!=='object'){addendum=' However, it is set to a '+_typeof(contextType)+'.';}else if(contextType.$$typeof===REACT_PROVIDER_TYPE){addendum=' Did you accidentally pass the Context.Provider instead?';}else if(contextType._context!==undefined){// <Context.Consumer>\naddendum=' Did you accidentally pass the Context.Consumer instead?';}else{addendum=' However, it is set to an object with keys {'+Object.keys(contextType).join(', ')+'}.';}error('%s defines an invalid contextType. '+'contextType should point to the Context object returned by React.createContext().%s',getComponentNameFromType(ctor)||'Component',addendum);}}}if(_typeof(contextType)==='object'&&contextType!==null){context=_readContext(contextType);}else{unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);var contextTypes=ctor.contextTypes;isLegacyContextConsumer=contextTypes!==null&&contextTypes!==undefined;context=isLegacyContextConsumer?getMaskedContext(workInProgress,unmaskedContext):emptyContextObject;}var instance=new ctor(props,context);// Instantiate twice to help detect side-effects.\n{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance=new ctor(props,context);// eslint-disable-line no-new\n}finally{setIsStrictModeForDevtools(false);}}}var state=workInProgress.memoizedState=instance.state!==null&&instance.state!==undefined?instance.state:null;adoptClassInstance(workInProgress,instance);{if(typeof ctor.getDerivedStateFromProps==='function'&&state===null){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutUninitializedState.has(componentName)){didWarnAboutUninitializedState.add(componentName);error('`%s` uses `getDerivedStateFromProps` but its initial state is '+'%s. This is not recommended. Instead, define the initial state by '+'assigning an object to `this.state` in the constructor of `%s`. '+'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',componentName,instance.state===null?'null':'undefined',componentName);}}// If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n// Warn about these lifecycles if they are present.\n// Don't warn about react-lifecycles-compat polyfilled methods though.\nif(typeof ctor.getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function'){var foundWillMountName=null;var foundWillReceivePropsName=null;var foundWillUpdateName=null;if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true){foundWillMountName='componentWillMount';}else if(typeof instance.UNSAFE_componentWillMount==='function'){foundWillMountName='UNSAFE_componentWillMount';}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){foundWillReceivePropsName='componentWillReceiveProps';}else if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){foundWillReceivePropsName='UNSAFE_componentWillReceiveProps';}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){foundWillUpdateName='componentWillUpdate';}else if(typeof instance.UNSAFE_componentWillUpdate==='function'){foundWillUpdateName='UNSAFE_componentWillUpdate';}if(foundWillMountName!==null||foundWillReceivePropsName!==null||foundWillUpdateName!==null){var _componentName=getComponentNameFromType(ctor)||'Component';var newApiName=typeof ctor.getDerivedStateFromProps==='function'?'getDerivedStateFromProps()':'getSnapshotBeforeUpdate()';if(!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)){didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n'+'%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n'+'The above lifecycles should be removed. Learn more about this warning here:\\n'+'https://reactjs.org/link/unsafe-component-lifecycles',_componentName,newApiName,foundWillMountName!==null?\"\\n  \"+foundWillMountName:'',foundWillReceivePropsName!==null?\"\\n  \"+foundWillReceivePropsName:'',foundWillUpdateName!==null?\"\\n  \"+foundWillUpdateName:'');}}}}// Cache unmasked context so we can avoid recreating masked context unless necessary.\n// ReactFiberContext usually updates this cache but can't for newly-created instances.\nif(isLegacyContextConsumer){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){var oldState=instance.state;if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}if(oldState!==instance.state){{error('%s.componentWillMount(): Assigning directly to this.state is '+\"deprecated (except inside a component's \"+'constructor). Use setState instead.',getComponentNameFromFiber(workInProgress)||'Component');}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext){var oldState=instance.state;if(typeof instance.componentWillReceiveProps==='function'){instance.componentWillReceiveProps(newProps,nextContext);}if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){instance.UNSAFE_componentWillReceiveProps(newProps,nextContext);}if(instance.state!==oldState){{var componentName=getComponentNameFromFiber(workInProgress)||'Component';if(!didWarnAboutStateAssignmentForComponent.has(componentName)){didWarnAboutStateAssignmentForComponent.add(componentName);error('%s.componentWillReceiveProps(): Assigning directly to '+\"this.state is deprecated (except inside a component's \"+'constructor). Use setState instead.',componentName);}}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.\nfunction mountClassInstance(workInProgress,ctor,newProps,renderLanes){{checkClassInstance(workInProgress,ctor,newProps);}var instance=workInProgress.stateNode;instance.props=newProps;instance.state=workInProgress.memoizedState;instance.refs=emptyRefsObject;initializeUpdateQueue(workInProgress);var contextType=ctor.contextType;if(_typeof(contextType)==='object'&&contextType!==null){instance.context=_readContext(contextType);}else{var unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);instance.context=getMaskedContext(workInProgress,unmaskedContext);}{if(instance.state===newProps){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutDirectlyAssigningPropsToState.has(componentName)){didWarnAboutDirectlyAssigningPropsToState.add(componentName);error('%s: It is not recommended to assign props directly to state '+\"because updates to props won't be reflected in state. \"+'In most cases, it is better to use props directly.',componentName);}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,instance);}{ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress,instance);}}instance.state=workInProgress.memoizedState;var getDerivedStateFromProps=ctor.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);instance.state=workInProgress.memoizedState;}// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(typeof ctor.getDerivedStateFromProps!=='function'&&typeof instance.getSnapshotBeforeUpdate!=='function'&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's\n// process them now.\nprocessUpdateQueue(workInProgress,newProps,instance,renderLanes);instance.state=workInProgress.memoizedState;}if(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}}function resumeMountClassInstance(workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;instance.props=oldProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(_typeof(contextType)==='object'&&contextType!==null){nextContext=_readContext(contextType);}else{var nextLegacyUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextLegacyUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what\n// ever the previously attempted to render - not the \"current\". However,\n// during componentDidUpdate we pass the \"current\" props.\n// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}}if(typeof instance.componentDidMount==='function'){var _fiberFlags=Update;{_fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags|=MountLayoutDev;}workInProgress.flags|=_fiberFlags;}}else{// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidMount==='function'){var _fiberFlags2=Update;{_fiberFlags2|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags2|=MountLayoutDev;}workInProgress.flags|=_fiberFlags2;}// If shouldComponentUpdate returned false, we should still update the\n// memoized state to indicate that this work can be reused.\nworkInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even\n// if shouldComponentUpdate returns false.\ninstance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}// Invokes the update life-cycles and returns false if it shouldn't rerender.\nfunction updateClassInstance(current,workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;cloneUpdateQueue(current,workInProgress);var unresolvedOldProps=workInProgress.memoizedProps;var oldProps=workInProgress.type===workInProgress.elementType?unresolvedOldProps:resolveDefaultProps(workInProgress.type,unresolvedOldProps);instance.props=oldProps;var unresolvedNewProps=workInProgress.pendingProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(_typeof(contextType)==='object'&&contextType!==null){nextContext=_readContext(contextType);}else{var nextUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what\n// ever the previously attempted to render - not the \"current\". However,\n// during componentDidUpdate we pass the \"current\" props.\n// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(unresolvedOldProps!==unresolvedNewProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(unresolvedOldProps===unresolvedNewProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()&&!enableLazyContextPropagation){// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext)||// TODO: In some cases, we'll end up checking if context has changed twice,\n// both before and after `shouldComponentUpdate` has been called. Not ideal,\n// but I'm loath to refactor this function. This only happens for memoized\n// components so it's not that common.\nenableLazyContextPropagation;if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,\n// Unsafe lifecycles should not be invoked for components using the new APIs.\nif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillUpdate==='function'||typeof instance.componentWillUpdate==='function')){if(typeof instance.componentWillUpdate==='function'){instance.componentWillUpdate(newProps,newState,nextContext);}if(typeof instance.UNSAFE_componentWillUpdate==='function'){instance.UNSAFE_componentWillUpdate(newProps,newState,nextContext);}}if(typeof instance.componentDidUpdate==='function'){workInProgress.flags|=Update;}if(typeof instance.getSnapshotBeforeUpdate==='function'){workInProgress.flags|=Snapshot;}}else{// If an update was already in progress, we should schedule an Update\n// effect even though we're bailing out, so that cWU/cDU are called.\nif(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}// If shouldComponentUpdate returned false, we should still update the\n// memoized props/state to indicate that this work can be reused.\nworkInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even\n// if shouldComponentUpdate returns false.\ninstance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}// TODO: Use the unified fiber stack module instead of this local one?\n// Intentionally not using it yet to derisk the initial implementation, because\n// the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n// rather the ids be wrong than crash the whole reconciler.\nvar forkStack=[];var forkStackIndex=0;var treeForkProvider=null;var treeForkCount=0;var idStack=[];var idStackIndex=0;var treeContextProvider=null;var treeContextId=1;var treeContextOverflow='';function isForkedChild(workInProgress){warnIfNotHydrating();return(workInProgress.flags&Forked)!==NoFlags;}function getForksAtLevel(workInProgress){warnIfNotHydrating();return treeForkCount;}function getTreeId(){var overflow=treeContextOverflow;var idWithLeadingBit=treeContextId;var id=idWithLeadingBit&~getLeadingBit(idWithLeadingBit);return id.toString(32)+overflow;}function pushTreeFork(workInProgress,totalChildren){// This is called right after we reconcile an array (or iterator) of child\n// fibers, because that's the only place where we know how many children in\n// the whole set without doing extra work later, or storing addtional\n// information on the fiber.\n//\n// That's why this function is separate from pushTreeId — it's called during\n// the render phase of the fork parent, not the child, which is where we push\n// the other context values.\n//\n// In the Fizz implementation this is much simpler because the child is\n// rendered in the same callstack as the parent.\n//\n// It might be better to just add a `forks` field to the Fiber type. It would\n// make this module simpler.\nwarnIfNotHydrating();forkStack[forkStackIndex++]=treeForkCount;forkStack[forkStackIndex++]=treeForkProvider;treeForkProvider=workInProgress;treeForkCount=totalChildren;}function pushTreeId(workInProgress,totalChildren,index){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextProvider=workInProgress;var baseIdWithLeadingBit=treeContextId;var baseOverflow=treeContextOverflow;// The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n// of the id; we use it to account for leading 0s.\nvar baseLength=getBitLength(baseIdWithLeadingBit)-1;var baseId=baseIdWithLeadingBit&~(1<<baseLength);var slot=index+1;var length=getBitLength(totalChildren)+baseLength;// 30 is the max length we can store without overflowing, taking into\n// consideration the leading 1 we use to mark the end of the sequence.\nif(length>30){// We overflowed the bitwise-safe range. Fall back to slower algorithm.\n// This branch assumes the length of the base id is greater than 5; it won't\n// work for smaller ids, because you need 5 bits per character.\n//\n// We encode the id in multiple steps: first the base id, then the\n// remaining digits.\n//\n// Each 5 bit sequence corresponds to a single base 32 character. So for\n// example, if the current id is 23 bits long, we can convert 20 of those\n// bits into a string of 4 characters, with 3 bits left over.\n//\n// First calculate how many bits in the base id represent a complete\n// sequence of characters.\nvar numberOfOverflowBits=baseLength-baseLength%5;// Then create a bitmask that selects only those bits.\nvar newOverflowBits=(1<<numberOfOverflowBits)-1;// Select the bits, and convert them to a base 32 string.\nvar newOverflow=(baseId&newOverflowBits).toString(32);// Now we can remove those bits from the base id.\nvar restOfBaseId=baseId>>numberOfOverflowBits;var restOfBaseLength=baseLength-numberOfOverflowBits;// Finally, encode the rest of the bits using the normal algorithm. Because\n// we made more room, this time it won't overflow.\nvar restOfLength=getBitLength(totalChildren)+restOfBaseLength;var restOfNewBits=slot<<restOfBaseLength;var id=restOfNewBits|restOfBaseId;var overflow=newOverflow+baseOverflow;treeContextId=1<<restOfLength|id;treeContextOverflow=overflow;}else{// Normal path\nvar newBits=slot<<baseLength;var _id=newBits|baseId;var _overflow=baseOverflow;treeContextId=1<<length|_id;treeContextOverflow=_overflow;}}function pushMaterializedTreeId(workInProgress){warnIfNotHydrating();// This component materialized an id. This will affect any ids that appear\n// in its children.\nvar returnFiber=workInProgress[\"return\"];if(returnFiber!==null){var numberOfForks=1;var slotIndex=0;pushTreeFork(workInProgress,numberOfForks);pushTreeId(workInProgress,numberOfForks,slotIndex);}}function getBitLength(number){return 32-clz32(number);}function getLeadingBit(id){return 1<<getBitLength(id)-1;}function popTreeContext(workInProgress){// Restore the previous values.\n// This is a bit more complicated than other context-like modules in Fiber\n// because the same Fiber may appear on the stack multiple times and for\n// different reasons. We have to keep popping until the work-in-progress is\n// no longer at the top of the stack.\nwhile(workInProgress===treeForkProvider){treeForkProvider=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;treeForkCount=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;}while(workInProgress===treeContextProvider){treeContextProvider=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextOverflow=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextId=idStack[--idStackIndex];idStack[idStackIndex]=null;}}function getSuspendedTreeContext(){warnIfNotHydrating();if(treeContextProvider!==null){return{id:treeContextId,overflow:treeContextOverflow};}else{return null;}}function restoreSuspendedTreeContext(workInProgress,suspendedContext){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextId=suspendedContext.id;treeContextOverflow=suspendedContext.overflow;treeContextProvider=workInProgress;}function warnIfNotHydrating(){{if(!getIsHydrating()){error('Expected to be hydrating. This is a bug in React. Please file '+'an issue.');}}}// This may have been an insertion or a hydration.\nvar hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;var didSuspend=false;// Hydration errors that were thrown inside this boundary\nvar hydrationErrors=null;function warnIfHydrating(){{if(isHydrating){error('We should not be hydrating here. This is a bug in React. Please file a bug.');}}}function markDidSuspendWhileHydratingDEV(){{didSuspend=true;}}function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChildWithinContainer(parentInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspend=false;return true;}function reenterHydrationStateFromDehydratedSuspenseInstance(fiber,suspenseInstance,treeContext){nextHydratableInstance=getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspend=false;if(treeContext!==null){restoreSuspendedTreeContext(fiber,treeContext);}return true;}function warnUnhydratedInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo,instance);break;case HostComponent:didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance);break;case SuspenseComponent:var suspenseState=returnFiber.memoizedState;if(suspenseState.dehydrated!==null)didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated,instance);break;}}}function deleteHydratableInstance(returnFiber,instance){warnUnhydratedInstance(returnFiber,instance);var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete[\"return\"]=returnFiber;var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else{deletions.push(childToDelete);}}function warnNonhydratedInstance(returnFiber,fiber){{if(didSuspend){// Inside a boundary that already suspended. We're currently rendering the\n// siblings of a suspended node. The mismatch may be due to the missing\n// data, so it's probably a false positive.\nreturn;}switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableInstanceWithinContainer(parentContainer,type);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableTextInstanceWithinContainer(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:var _type=fiber.type;var _props=fiber.pendingProps;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type);break;case HostText:var _text=fiber.pendingProps;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text);break;case SuspenseComponent:didNotFindHydratableSuspenseInstance(parentType,parentProps);break;}break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;var _parentInstance=suspenseState.dehydrated;if(_parentInstance!==null)switch(fiber.tag){case HostComponent:var _type2=fiber.type;var _props2=fiber.pendingProps;didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance,_type2);break;case HostText:var _text2=fiber.pendingProps;didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance,_text2);break;}break;}default:return;}}}function insertNonHydratedInstance(returnFiber,fiber){fiber.flags=fiber.flags&~Hydrating|Placement;warnNonhydratedInstance(returnFiber,fiber);}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type);if(instance!==null){fiber.stateNode=instance;hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(instance);return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;hydrationParentFiber=fiber;// Text Instances don't have children so there's nothing to hydrate.\nnextHydratableInstance=null;return true;}return false;}case SuspenseComponent:{{var suspenseInstance=canHydrateSuspenseInstance(nextInstance);if(suspenseInstance!==null){var suspenseState={dehydrated:suspenseInstance,treeContext:getSuspendedTreeContext(),retryLane:OffscreenLane};fiber.memoizedState=suspenseState;// Store the dehydrated fragment as a child fiber.\n// This simplifies the code for getHostSibling and deleting nodes,\n// since it doesn't have to consider all Suspense boundaries and\n// check if they're dehydrated ones or not.\nvar dehydratedFragment=createFiberFromDehydratedFragment(suspenseInstance);dehydratedFragment[\"return\"]=fiber;fiber.child=dehydratedFragment;hydrationParentFiber=fiber;// While a Suspense Instance does have children, we won't step into\n// it during the first pass. Instead, we'll reenter it later.\nnextHydratableInstance=null;return true;}}return false;}default:return false;}}function shouldClientRenderOnMismatch(fiber){return(fiber.mode&ConcurrentMode)!==NoMode&&(fiber.flags&DidCapture)===NoFlags;}function throwOnHydrationMismatch(fiber){throw new Error('Hydration failed because the initial UI does not match what was '+'rendered on the server.');}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// Nothing to hydrate. Make it an insertion.\ninsertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}var firstAttemptedInstance=nextInstance;if(!tryHydrate(fiber,nextInstance)){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// If we can't hydrate this instance let's try the next one.\n// We use this as a heuristic. It's based on intuition and not data so it\n// might be flawed or unnecessary.\nnextInstance=getNextHydratableSibling(firstAttemptedInstance);var prevHydrationParentFiber=hydrationParentFiber;if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.\ninsertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was\n// superfluous and we'll delete it. Since we can't eagerly delete it\n// we'll have to schedule a deletion. To do that, this node needs a dummy\n// fiber associated with it.\ndeleteHydratableInstance(prevHydrationParentFiber,firstAttemptedInstance);}}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var shouldWarnIfMismatchDev=!didSuspend;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber,shouldWarnIfMismatchDev);// TODO: Type this specific to this type of component.\nfiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there\n// is a new ref we mark this as an update.\nif(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the\n// hydration parent is the parent host component of this host text.\nvar returnFiber=hydrationParentFiber;if(returnFiber!==null){var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.\nisConcurrentMode);break;}}}}return shouldUpdate;}function prepareToHydrateHostSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}hydrateSuspenseInstance(suspenseInstance,fiber);}function skipPastDehydratedSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);}function popToNextHostParent(fiber){var parent=fiber[\"return\"];while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot&&parent.tag!==SuspenseComponent){parent=parent[\"return\"];}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted\n// tree.\nreturn false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then\n// we were an insertion and now need to pop up reenter hydration of our\n// siblings.\npopToNextHostParent(fiber);isHydrating=true;return false;}// If we have any remaining hydratable nodes, we need to delete them now.\n// We only do this deeper than head and body since they tend to have random\n// other nodes in them. We also ignore components with pure text content in\n// side of them. We also don't delete anything inside the root container.\nif(fiber.tag!==HostRoot&&(fiber.tag!==HostComponent||shouldDeleteUnhydratedTailInstances(fiber.type)&&!shouldSetTextContent(fiber.type,fiber.memoizedProps))){var nextInstance=nextHydratableInstance;if(nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnIfUnhydratedTailNodes(fiber);throwOnHydrationMismatch();}else{while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}}}popToNextHostParent(fiber);if(fiber.tag===SuspenseComponent){nextHydratableInstance=skipPastDehydratedSuspenseInstance(fiber);}else{nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;}return true;}function hasUnhydratedTailNodes(){return isHydrating&&nextHydratableInstance!==null;}function warnIfUnhydratedTailNodes(fiber){var nextInstance=nextHydratableInstance;while(nextInstance){warnUnhydratedInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;didSuspend=false;}function upgradeHydrationErrorsToRecoverable(){if(hydrationErrors!==null){// Successfully completed a forced client render. The errors that occurred\n// during the hydration attempt are now recovered. We will log them in\n// commit phase, once the entire tree has finished.\nqueueRecoverableErrors(hydrationErrors);hydrationErrors=null;}}function getIsHydrating(){return isHydrating;}function queueHydrationError(error){if(hydrationErrors===null){hydrationErrors=[error];}else{hydrationErrors.push(error);}}var didWarnAboutMaps;var didWarnAboutGenerators;var didWarnAboutStringRefs;var ownerHasKeyUseWarning;var ownerHasFunctionTypeWarning;var warnForMissingKey=function warnForMissingKey(child,returnFiber){};{didWarnAboutMaps=false;didWarnAboutGenerators=false;didWarnAboutStringRefs={};/**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */ownerHasKeyUseWarning={};ownerHasFunctionTypeWarning={};warnForMissingKey=function warnForMissingKey(child,returnFiber){if(child===null||_typeof(child)!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}if(_typeof(child._store)!=='object'){throw new Error('React Component in warnForMissingKey should have a _store. '+'This error is likely caused by a bug in React. Please file an issue.');}child._store.validated=true;var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasKeyUseWarning[componentName]){return;}ownerHasKeyUseWarning[componentName]=true;error('Each child in a list should have a unique '+'\"key\" prop. See https://reactjs.org/link/warning-keys for '+'more information.');};}function coerceRef(returnFiber,current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'&&_typeof(mixedRef)!=='object'){{// TODO: Clean this up once we turn on the string ref warning for\n// everyone, because the strict mode case will no longer be relevant\nif((returnFiber.mode&StrictLegacyMode||warnAboutStringRefs)&&// We warn in ReactElement.js if owner and self are equal for string refs\n// because these cannot be automatically converted to an arrow function\n// using a codemod. Therefore, we don't have to warn about string refs again.\n!(element._owner&&element._self&&element._owner.stateNode!==element._self)){var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(!didWarnAboutStringRefs[componentName]){{error('A string ref, \"%s\", has been found within a strict mode tree. '+'String refs are a source of potential bugs and should be avoided. '+'We recommend using useRef() or createRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref',mixedRef);}didWarnAboutStringRefs[componentName]=true;}}}if(element._owner){var owner=element._owner;var inst;if(owner){var ownerFiber=owner;if(ownerFiber.tag!==ClassComponent){throw new Error('Function components cannot have string refs. '+'We recommend using useRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref');}inst=ownerFiber.stateNode;}if(!inst){throw new Error(\"Missing owner for string ref \"+mixedRef+\". This error is likely caused by a \"+'bug in React. Please file an issue.');}// Assigning this to a const so Flow knows it won't change in the closure\nvar resolvedInst=inst;{checkPropStringCoercion(mixedRef,'ref');}var stringRef=''+mixedRef;// Check if previous string ref matches new string ref\nif(current!==null&&current.ref!==null&&typeof current.ref==='function'&&current.ref._stringRef===stringRef){return current.ref;}var ref=function ref(value){var refs=resolvedInst.refs;if(refs===emptyRefsObject){// This is a lazy pooled frozen object, so we need to initialize.\nrefs=resolvedInst.refs={};}if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{if(typeof mixedRef!=='string'){throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');}if(!element._owner){throw new Error(\"Element ref was specified as a string (\"+mixedRef+\") but no owner was set. This could happen for one of\"+' the following reasons:\\n'+'1. You may be adding a ref to a function component\\n'+\"2. You may be adding a ref to a component that was not created inside a component's render method\\n\"+'3. You have multiple copies of React loaded\\n'+'See https://reactjs.org/link/refs-must-have-owner for more information.');}}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){var childString=Object.prototype.toString.call(newChild);throw new Error(\"Objects are not valid as a React child (found: \"+(childString==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':childString)+\"). \"+'If you meant to render a collection of children, use an array '+'instead.');}function warnOnFunctionType(returnFiber){{var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasFunctionTypeWarning[componentName]){return;}ownerHasFunctionTypeWarning[componentName]=true;error('Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.');}}function resolveLazy(lazyType){var payload=lazyType._payload;var init=lazyType._init;return init(payload);}// This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\nfunction ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.\nreturn;}var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else{deletions.push(childToDelete);}}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.\nreturn null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by\n// assuming that after the first child we've already added everything.\nvar childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by\n// keys quickly. Implicit (null) keys get added to this set with their index\n// instead.\nvar existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps){// We currently set sibling to null and index to 0 here because it is easy\n// to forget to do before returning it. E.g. for the single child case.\nvar clone=createWorkInProgress(fiber,pendingProps);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// During hydration, the useId algorithm needs to know which fibers are\n// part of a list of children (arrays, iterators).\nnewFiber.flags|=Forked;return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.\nnewFiber.flags|=Placement;return lastPlacedIndex;}else{// This item can stay in place.\nreturn oldIndex;}}else{// This is an insertion.\nnewFiber.flags|=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a\n// placement for inserting new children.\nif(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.flags|=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,lanes){if(current===null||current.tag!==HostText){// Insert\nvar created=createFiberFromText(textContent,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,textContent);existing[\"return\"]=returnFiber;return existing;}}function updateElement(returnFiber,current,element,lanes){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,current,element.props.children,lanes,element.key);}if(current!==null){if(current.elementType===elementType||// Keep this check inline so it only runs on the false path:\nisCompatibleFamilyForHotReloading(current,element)||// Lazy types should reconcile their resolved type.\n// We need to do this after the Hot Reloading check above,\n// because hot reloading has different semantics than prod because\n// it doesn't resuspend. So we can't let the call below suspend.\n_typeof(elementType)==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===current.type){// Move based on index\nvar existing=useFiber(current,element.props);existing.ref=coerceRef(returnFiber,current,element);existing[\"return\"]=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}// Insert\nvar created=createFiberFromElement(element,returnFiber.mode,lanes);created.ref=coerceRef(returnFiber,current,element);created[\"return\"]=returnFiber;return created;}function updatePortal(returnFiber,current,portal,lanes){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert\nvar created=createFiberFromPortal(portal,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,portal.children||[]);existing[\"return\"]=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,lanes,key){if(current===null||current.tag!==Fragment){// Insert\nvar created=createFiberFromFragment(fragment,returnFiber.mode,lanes,key);created[\"return\"]=returnFiber;return created;}else{// Update\nvar existing=useFiber(current,fragment);existing[\"return\"]=returnFiber;return existing;}}function createChild(returnFiber,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed\n// we can continue to replace it without aborting even if it is not a text\n// node.\nvar created=createFiberFromText(''+newChild,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}if(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _created=createFiberFromElement(newChild,returnFiber.mode,lanes);_created.ref=coerceRef(returnFiber,null,newChild);_created[\"return\"]=returnFiber;return _created;}case REACT_PORTAL_TYPE:{var _created2=createFiberFromPortal(newChild,returnFiber.mode,lanes);_created2[\"return\"]=returnFiber;return _created2;}case REACT_LAZY_TYPE:{{var payload=newChild._payload;var init=newChild._init;return createChild(returnFiber,init(payload),lanes);}}}if(isArray(newChild)||getIteratorFn(newChild)){var _created3=createFiberFromFragment(newChild,returnFiber.mode,lanes,null);_created3[\"return\"]=returnFiber;return _created3;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateSlot(returnFiber,oldFiber,newChild,lanes){// Update the fiber if the keys match, otherwise return null.\nvar key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed\n// we can continue to replace it without aborting even if it is not a text\n// node.\nif(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,lanes);}if(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){return updateElement(returnFiber,oldFiber,newChild,lanes);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,lanes);}else{return null;}}case REACT_LAZY_TYPE:{{var payload=newChild._payload;var init=newChild._init;return updateSlot(returnFiber,oldFiber,init(payload),lanes);}}}if(isArray(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor\n// new node for the key. If both are text nodes, they match.\nvar matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,lanes);}if(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateElement(returnFiber,_matchedFiber,newChild,lanes);}case REACT_PORTAL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber2,newChild,lanes);}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return updateFromMap(existingChildren,returnFiber,newIdx,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){var _matchedFiber3=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber3,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}/**\n   * Warns if there is a duplicate or missing key\n   */function warnOnInvalidKey(child,knownKeys,returnFiber){{if(_typeof(child)!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child,returnFiber);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}error('Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted — the behavior is unsupported and '+'could change in a future version.',key);break;case REACT_LAZY_TYPE:{var payload=child._payload;var init=child._init;warnOnInvalidKey(init(payload),knownKeys,returnFiber);break;}}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,lanes){// This algorithm can't optimize by searching from both ends since we\n// don't have backpointers on fibers. I'm trying to see how far we can get\n// with that model. If it ends up not being worth the tradeoffs, we can\n// add it later.\n// Even with a two ended optimization, we'd want to optimize for the case\n// where there are few changes and brute force the comparison instead of\n// going for the Map. It'd like to explore hitting that path first in\n// forward-only mode and only go for the Map once we notice that we need\n// lots of look ahead. This doesn't handle reversal as well as two ended\n// search but that's unusual. Besides, for the two ended optimization to\n// work on Iterables, we'd need to copy the whole set.\n// In this first iteration, we'll just live with hitting the bad case\n// (adding everything to a Map) in for every insert/move.\n// If you change this code, also update reconcileChildrenIterator() which\n// uses the same algorithm.\n{// First, validate keys.\nvar knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's\n// unfortunate because it triggers the slow path all the time. We need\n// a better way to communicate whether this was a miss or null,\n// boolean, undefined, etc.\nif(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we\n// need to delete the existing child.\ndeleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.\n// I.e. if we had null values before, then we want to defer this\n// for each null value. However, we also don't want to call updateSlot\n// with the previous one.\npreviousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.\ndeleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path\n// since the rest will all be insertions.\nfor(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],lanes);if(_newFiber===null){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}if(getIsHydrating()){var _numberOfForks=newIdx;pushTreeFork(returnFiber,_numberOfForks);}return resultingFirstChild;}// Add all children to a key map for quick lookups.\nvar existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.\nfor(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],lanes);if(_newFiber2!==null){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a\n// current, that means that we reused the fiber. We need to delete\n// it from the child list so that we don't add it to the deletion\n// list.\nexistingChildren[\"delete\"](_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need\n// to add them to the deletion list.\nexistingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks2=newIdx;pushTreeFork(returnFiber,_numberOfForks2);}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,lanes){// This is the same implementation as reconcileChildrenArray(),\n// but using the iterator instead.\nvar iteratorFn=getIteratorFn(newChildrenIterable);if(typeof iteratorFn!=='function'){throw new Error('An object is not an iterable. This error is likely caused by a bug in '+'React. Please file an issue.');}{// We don't support rendering Generators because it's a mutation.\n// See https://github.com/facebook/react/issues/12995\nif(typeof Symbol==='function'&&// $FlowFixMe Flow doesn't know about toStringTag\nnewChildrenIterable[Symbol.toStringTag]==='Generator'){if(!didWarnAboutGenerators){error('Using Generators as children is unsupported and will likely yield '+'unexpected results because enumerating a generator mutates it. '+'You may convert it to an array with `Array.from()` or the '+'`[...spread]` operator before rendering. Keep in mind '+'you might need to polyfill these features for older browsers.');}didWarnAboutGenerators=true;}// Warn about using Maps as children\nif(newChildrenIterable.entries===iteratorFn){if(!didWarnAboutMaps){error('Using Maps as children is not supported. '+'Use an array of keyed ReactElements instead.');}didWarnAboutMaps=true;}// First, validate keys.\n// We'll get a different iterator later for the main pass.\nvar _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}}var newChildren=iteratorFn.call(newChildrenIterable);if(newChildren==null){throw new Error('An iterable object provided no iterator.');}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's\n// unfortunate because it triggers the slow path all the time. We need\n// a better way to communicate whether this was a miss or null,\n// boolean, undefined, etc.\nif(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we\n// need to delete the existing child.\ndeleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.\n// I.e. if we had null values before, then we want to defer this\n// for each null value. However, we also don't want to call updateSlot\n// with the previous one.\npreviousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.\ndeleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path\n// since the rest will all be insertions.\nfor(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,lanes);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\nresultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}if(getIsHydrating()){var _numberOfForks3=newIdx;pushTreeFork(returnFiber,_numberOfForks3);}return resultingFirstChild;}// Add all children to a key map for quick lookups.\nvar existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.\nfor(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,lanes);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a\n// current, that means that we reused the fiber. We need to delete\n// it from the child list so that we don't add it to the deletion\n// list.\nexistingChildren[\"delete\"](_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need\n// to add them to the deletion list.\nexistingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks4=newIdx;pushTreeFork(returnFiber,_numberOfForks4);}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,lanes){// There's no need to check for keys on text nodes since we don't have a\n// way to define them.\nif(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete\n// the rest.\ndeleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent);existing[\"return\"]=returnFiber;return existing;}// The existing first child is not a text node so we need to create one\n// and delete the existing ones.\ndeleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,lanes){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to\n// the first item in the list.\nif(child.key===key){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){if(child.tag===Fragment){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.props.children);existing[\"return\"]=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}else{if(child.elementType===elementType||// Keep this check inline so it only runs on the false path:\nisCompatibleFamilyForHotReloading(child,element)||// Lazy types should reconcile their resolved type.\n// We need to do this after the Hot Reloading check above,\n// because hot reloading has different semantics than prod because\n// it doesn't resuspend. So we can't let the call below suspend.\n_typeof(elementType)==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===child.type){deleteRemainingChildren(returnFiber,child.sibling);var _existing=useFiber(child,element.props);_existing.ref=coerceRef(returnFiber,child,element);_existing[\"return\"]=returnFiber;{_existing._debugSource=element._source;_existing._debugOwner=element._owner;}return _existing;}}// Didn't match.\ndeleteRemainingChildren(returnFiber,child);break;}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.mode,lanes,element.key);created[\"return\"]=returnFiber;return created;}else{var _created4=createFiberFromElement(element,returnFiber.mode,lanes);_created4.ref=coerceRef(returnFiber,currentFirstChild,element);_created4[\"return\"]=returnFiber;return _created4;}}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,lanes){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to\n// the first item in the list.\nif(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[]);existing[\"return\"]=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.mode,lanes);created[\"return\"]=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation\n// itself. They will be added to the side-effect list as we pass through the\n// children and the parent.\nfunction reconcileChildFibers(returnFiber,currentFirstChild,newChild,lanes){// This function is not recursive.\n// If the top level item is an array, we treat it as a set of children,\n// not as a fragment. Nested arrays on the other hand will be treated as\n// fragment nodes. Recursion happens at the normal flow.\n// Handle top level unkeyed fragments as if they were arrays.\n// This leads to an ambiguity between <>{[...]}</> and <>...</>.\n// We treat the ambiguous cases above the same.\nvar isUnkeyedTopLevelFragment=_typeof(newChild)==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null;if(isUnkeyedTopLevelFragment){newChild=newChild.props.children;}// Handle object types\nif(_typeof(newChild)==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,lanes));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,lanes));case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;// TODO: This function is supposed to be non-recursive.\nreturn reconcileChildFibers(returnFiber,currentFirstChild,init(payload),lanes);}}if(isArray(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,lanes);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,lanes);}throwOnInvalidObjectType(returnFiber,newChild);}if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,lanes));}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}// Remaining cases are all treated as empty.\nreturn deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current,workInProgress){if(current!==null&&workInProgress.child!==current.child){throw new Error('Resuming work not yet implemented.');}if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps);workInProgress.child=newChild;newChild[\"return\"]=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps);newChild[\"return\"]=workInProgress;}newChild.sibling=null;}// Reset a workInProgress child set to prepare it for a second pass.\nfunction resetChildFibers(workInProgress,lanes){var child=workInProgress.child;while(child!==null){resetWorkInProgress(child,lanes);child=child.sibling;}}var NO_CONTEXT={};var contextStackCursor$1=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){if(c===NO_CONTEXT){throw new Error('Expected host context to exist. This error is likely caused by a bug '+'in React. Please file an issue.');}return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;\n// This allows us to reset root when portals are popped.\npush(rootInstanceStackCursor,nextRootInstance,fiber);// Track the context and the Fiber that provided it.\n// This enables us to pop only Fibers that provide unique contexts.\npush(contextFiberStackCursor,fiber,fiber);// Finally, we need to push the host context to the stack.\n// However, we can't just call getRootHostContext() and push it because\n// we'd have a different number of entries on the stack depending on\n// whether getRootHostContext() throws somewhere in renderer code or not.\n// So we push an empty value first. This lets us safely unwind on errors.\npush(contextStackCursor$1,NO_CONTEXT,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Now that we know this function doesn't throw, replace it.\npop(contextStackCursor$1,fiber);push(contextStackCursor$1,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor$1.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor$1.current);var nextContext=getChildHostContext(context,fiber.type);// Don't push this Fiber's context unless it's unique.\nif(context===nextContext){return;}// Track the context and the Fiber that provided it.\n// This enables us to pop only Fibers that provide unique contexts.\npush(contextFiberStackCursor,fiber,fiber);push(contextStackCursor$1,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.\n// pushHostContext() only pushes Fibers that provide unique contexts.\nif(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);}var DefaultSuspenseContext=0;// The Suspense Context is split into two parts. The lower bits is\n// inherited deeply down the subtree. The upper bits only affect\n// this immediate suspense boundary and gets reset each new\n// boundary or suspense list.\nvar SubtreeSuspenseContextMask=1;// Subtree Flags:\n// InvisibleParentSuspenseContext indicates that one of our parent Suspense\n// boundaries is not currently showing visible main content.\n// Either because it is already showing a fallback or is not mounted at all.\n// We can use this to determine if it is desirable to trigger a fallback at\n// the parent. If not, then we might need to trigger undesirable boundaries\n// and/or suspend the commit to avoid hiding the parent content.\nvar InvisibleParentSuspenseContext=1;// Shallow Flags:\n// ForceSuspenseFallback can be used by SuspenseList to force newly added\n// items into their fallback state during one of the render passes.\nvar ForceSuspenseFallback=2;var suspenseStackCursor=createCursor(DefaultSuspenseContext);function hasSuspenseContext(parentContext,flag){return(parentContext&flag)!==0;}function setDefaultShallowSuspenseContext(parentContext){return parentContext&SubtreeSuspenseContextMask;}function setShallowSuspenseContext(parentContext,shallowContext){return parentContext&SubtreeSuspenseContextMask|shallowContext;}function addSubtreeSuspenseContext(parentContext,subtreeContext){return parentContext|subtreeContext;}function pushSuspenseContext(fiber,newContext){push(suspenseStackCursor,newContext,fiber);}function popSuspenseContext(fiber){pop(suspenseStackCursor,fiber);}function shouldCaptureSuspense(workInProgress,hasInvisibleParent){// If it was the primary children that just suspended, capture and render the\n// fallback. Otherwise, don't capture and bubble to the next boundary.\nvar nextState=workInProgress.memoizedState;if(nextState!==null){if(nextState.dehydrated!==null){// A dehydrated boundary always captures.\nreturn true;}return false;}var props=workInProgress.memoizedProps;// Regular boundaries always capture.\n{return true;}// If it's a boundary we should avoid, then we prefer to bubble up to the\n}function findFirstSuspended(row){var node=row;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){var dehydrated=state.dehydrated;if(dehydrated===null||isSuspenseInstancePending(dehydrated)||isSuspenseInstanceFallback(dehydrated)){return node;}}}else if(node.tag===SuspenseListComponent&&// revealOrder undefined can't be trusted because it don't\n// keep track of whether it suspended or not.\nnode.memoizedProps.revealOrder!==undefined){var didSuspend=(node.flags&DidCapture)!==NoFlags;if(didSuspend){return node;}}else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===row){return null;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===row){return null;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}return null;}var NoFlags$1=/*   */0;// Represents whether effect should fire.\nvar HasEffect=/* */1;// Represents the phase in which the effect (not the clean-up) fires.\nvar Insertion=/*  */2;var Layout=/*    */4;var Passive$1=/*   */8;// and should be reset before starting a new render.\n// This tracks which mutable sources need to be reset after a render.\nvar workInProgressSources=[];function resetWorkInProgressVersions(){for(var i=0;i<workInProgressSources.length;i++){var mutableSource=workInProgressSources[i];{mutableSource._workInProgressVersionPrimary=null;}}workInProgressSources.length=0;}// This ensures that the version used for server rendering matches the one\n// that is eventually read during hydration.\n// If they don't match there's a potential tear and a full deopt render is required.\nfunction registerMutableSourceForHydration(root,mutableSource){var getVersion=mutableSource._getVersion;var version=getVersion(mutableSource._source);// TODO Clear this data once all pending hydration work is finished.\n// Retaining it forever may interfere with GC.\nif(root.mutableSourceEagerHydrationData==null){root.mutableSourceEagerHydrationData=[mutableSource,version];}else{root.mutableSourceEagerHydrationData.push(mutableSource,version);}}var ReactCurrentDispatcher$1=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentBatchConfig$2=ReactSharedInternals.ReactCurrentBatchConfig;var didWarnAboutMismatchedHooksForComponent;var didWarnUncachedGetSnapshot;{didWarnAboutMismatchedHooksForComponent=new Set();}// These are set right before calling the component.\nvar renderLanes=NoLanes;// The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\nvar currentlyRenderingFiber$1=null;// Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\nvar currentHook=null;var workInProgressHook=null;// Whether an update was scheduled at any point during the render phase. This\n// does not get reset if we do another render pass; only when we're completely\n// finished evaluating this component. This is an optimization so we know\n// whether we need to clear render phase updates after a throw.\nvar didScheduleRenderPhaseUpdate=false;// Where an update was scheduled only during the current render pass. This\n// gets reset after each attempt.\n// TODO: Maybe there's some way to consolidate this with\n// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\nvar didScheduleRenderPhaseUpdateDuringThisPass=false;// Counts the number of useId hooks in this component.\nvar localIdCounter=0;// Used for ids that are generated completely client-side (i.e. not during\n// hydration). This counter is global, so client ids are not stable across\n// render attempts.\nvar globalClientIdCounter=0;var RE_RENDER_LIMIT=25;// In DEV, this is the name of the currently executing primitive hook\nvar currentHookNameInDev=null;// In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\nvar hookTypesDev=null;var hookTypesUpdateIndexDev=-1;// In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\nvar ignorePreviousDependencies=false;function mountHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev===null){hookTypesDev=[hookName];}else{hookTypesDev.push(hookName);}}}function updateHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev!==null){hookTypesUpdateIndexDev++;if(hookTypesDev[hookTypesUpdateIndexDev]!==hookName){warnOnHookMismatchInDev(hookName);}}}}function checkDepsAreArrayDev(deps){{if(deps!==undefined&&deps!==null&&!isArray(deps)){// Verify deps, but only on mount to avoid extra checks.\n// It's unlikely their type would change as usually you define them inline.\nerror('%s received a final argument that is not an array (instead, received `%s`). When '+'specified, the final argument must be an array.',currentHookNameInDev,_typeof(deps));}}}function warnOnHookMismatchInDev(currentHookName){{var componentName=getComponentNameFromFiber(currentlyRenderingFiber$1);if(!didWarnAboutMismatchedHooksForComponent.has(componentName)){didWarnAboutMismatchedHooksForComponent.add(componentName);if(hookTypesDev!==null){var table='';var secondColumnStart=30;for(var i=0;i<=hookTypesUpdateIndexDev;i++){var oldHookName=hookTypesDev[i];var newHookName=i===hookTypesUpdateIndexDev?currentHookName:oldHookName;var row=i+1+\". \"+oldHookName;// Extra space so second column lines up\n// lol @ IE not supporting String#repeat\nwhile(row.length<secondColumnStart){row+=' ';}row+=newHookName+'\\n';table+=row;}error('React has detected a change in the order of Hooks called by %s. '+'This will lead to bugs and errors if not fixed. '+'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n'+'   Previous render            Next render\\n'+'   ------------------------------------------------------\\n'+'%s'+'   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n',componentName,table);}}}}function throwInvalidHookError(){throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for'+' one of the following reasons:\\n'+'1. You might have mismatching versions of React and the renderer (such as React DOM)\\n'+'2. You might be breaking the Rules of Hooks\\n'+'3. You might have more than one copy of React in the same app\\n'+'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');}function areHookInputsEqual(nextDeps,prevDeps){{if(ignorePreviousDependencies){// Only true when this component is being hot reloaded.\nreturn false;}}if(prevDeps===null){{error('%s received a final argument during this render, but not during '+'the previous render. Even though the final argument is optional, '+'its type cannot change between renders.',currentHookNameInDev);}return false;}{// Don't bother comparing lengths in prod because these arrays should be\n// passed inline.\nif(nextDeps.length!==prevDeps.length){error('The final argument passed to %s changed size between renders. The '+'order and size of this array must remain constant.\\n\\n'+'Previous: %s\\n'+'Incoming: %s',currentHookNameInDev,\"[\"+prevDeps.join(', ')+\"]\",\"[\"+nextDeps.join(', ')+\"]\");}}for(var i=0;i<prevDeps.length&&i<nextDeps.length;i++){if(objectIs(nextDeps[i],prevDeps[i])){continue;}return false;}return true;}function renderWithHooks(current,workInProgress,Component,props,secondArg,nextRenderLanes){renderLanes=nextRenderLanes;currentlyRenderingFiber$1=workInProgress;{hookTypesDev=current!==null?current._debugHookTypes:null;hookTypesUpdateIndexDev=-1;// Used for hot reloading:\nignorePreviousDependencies=current!==null&&current.type!==workInProgress.type;}workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.lanes=NoLanes;// The following should have already been reset\n// currentHook = null;\n// workInProgressHook = null;\n// didScheduleRenderPhaseUpdate = false;\n// localIdCounter = 0;\n// TODO Warn if no hooks are used at all during mount, then some are used during update.\n// Currently we will identify the update render as a mount because memoizedState === null.\n// This is tricky because it's valid for certain types of components (e.g. React.lazy)\n// Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n// Non-stateful hooks (e.g. context) don't get added to memoizedState,\n// so memoizedState would be null during updates and mounts.\n{if(current!==null&&current.memoizedState!==null){ReactCurrentDispatcher$1.current=HooksDispatcherOnUpdateInDEV;}else if(hookTypesDev!==null){// This dispatcher handles an edge case where a component is updating,\n// but no stateful hooks have been used.\n// We want to match the production code behavior (which will use HooksDispatcherOnMount),\n// but with the extra DEV validation to ensure hooks ordering hasn't changed.\n// This dispatcher does that.\nReactCurrentDispatcher$1.current=HooksDispatcherOnMountWithHookTypesInDEV;}else{ReactCurrentDispatcher$1.current=HooksDispatcherOnMountInDEV;}}var children=Component(props,secondArg);// Check if there was a render phase update\nif(didScheduleRenderPhaseUpdateDuringThisPass){// Keep rendering in a loop for as long as render phase updates continue to\n// be scheduled. Use a counter to prevent infinite loops.\nvar numberOfReRenders=0;do{didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;if(numberOfReRenders>=RE_RENDER_LIMIT){throw new Error('Too many re-renders. React limits the number of renders to prevent '+'an infinite loop.');}numberOfReRenders+=1;{// Even when hot reloading, allow dependencies to stabilize\n// after first render to prevent infinite render phase updates.\nignorePreviousDependencies=false;}// Start over from the beginning of the list\ncurrentHook=null;workInProgressHook=null;workInProgress.updateQueue=null;{// Also validate hook order for cascading updates.\nhookTypesUpdateIndexDev=-1;}ReactCurrentDispatcher$1.current=HooksDispatcherOnRerenderInDEV;children=Component(props,secondArg);}while(didScheduleRenderPhaseUpdateDuringThisPass);}// We can assume the previous dispatcher is always this one, since we set it\n// at the beginning of the render phase and there's no re-entrance.\nReactCurrentDispatcher$1.current=ContextOnlyDispatcher;{workInProgress._debugHookTypes=hookTypesDev;}// This check uses currentHook so that it works the same in DEV and prod bundles.\n// hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\nvar didRenderTooFewHooks=currentHook!==null&&currentHook.next!==null;renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{currentHookNameInDev=null;hookTypesDev=null;hookTypesUpdateIndexDev=-1;// Confirm that a static flag was not added or removed since the last\n// render. If this fires, it suggests that we incorrectly reset the static\n// flags in some other part of the codebase. This has happened before, for\n// example, in the SuspenseList implementation.\nif(current!==null&&(current.flags&StaticMask)!==(workInProgress.flags&StaticMask)&&// Disable this warning in legacy mode, because legacy Suspense is weird\n// and creates false positives. To make this work in legacy mode, we'd\n// need to mark fibers that commit in an incomplete state, somehow. For\n// now I'll disable the warning that most of the bugs that would trigger\n// it are either exclusive to concurrent mode or exist in both.\n(current.mode&ConcurrentMode)!==NoMode){error('Internal React error: Expected static flag was missing. Please '+'notify the React team.');}}didScheduleRenderPhaseUpdate=false;// This is reset by checkDidRenderIdHook\n// localIdCounter = 0;\nif(didRenderTooFewHooks){throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental '+'early return statement.');}return children;}function checkDidRenderIdHook(){// This should be called immediately after every renderWithHooks call.\n// Conceptually, it's part of the return value of renderWithHooks; it's only a\n// separate function to avoid using an array tuple.\nvar didRenderIdHook=localIdCounter!==0;localIdCounter=0;return didRenderIdHook;}function bailoutHooks(current,workInProgress,lanes){workInProgress.updateQueue=current.updateQueue;// TODO: Don't need to reset the flags here, because they're reset in the\n// complete phase (bubbleProperties).\nif((workInProgress.mode&StrictEffectsMode)!==NoMode){workInProgress.flags&=~(MountPassiveDev|MountLayoutDev|Passive|Update);}else{workInProgress.flags&=~(Passive|Update);}current.lanes=removeLanes(current.lanes,lanes);}function resetHooksAfterThrow(){// We can assume the previous dispatcher is always this one, since we set it\n// at the beginning of the render phase and there's no re-entrance.\nReactCurrentDispatcher$1.current=ContextOnlyDispatcher;if(didScheduleRenderPhaseUpdate){// There were render phase updates. These are only valid for this render\n// phase, which we are now aborting. Remove the updates from the queues so\n// they do not persist to the next render. Do not remove updates from hooks\n// that weren't processed.\n//\n// Only reset the updates from the queue if it has a clone. If it does\n// not have a clone, that means it wasn't processed, and the updates were\n// scheduled before we entered the render phase.\nvar hook=currentlyRenderingFiber$1.memoizedState;while(hook!==null){var queue=hook.queue;if(queue!==null){queue.pending=null;}hook=hook.next;}didScheduleRenderPhaseUpdate=false;}renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{hookTypesDev=null;hookTypesUpdateIndexDev=-1;currentHookNameInDev=null;isUpdatingOpaqueValueInRenderPhase=false;}didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;}function mountWorkInProgressHook(){var hook={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};if(workInProgressHook===null){// This is the first hook in the list\ncurrentlyRenderingFiber$1.memoizedState=workInProgressHook=hook;}else{// Append to the end of the list\nworkInProgressHook=workInProgressHook.next=hook;}return workInProgressHook;}function updateWorkInProgressHook(){// This function is used both for updates and for re-renders triggered by a\n// render phase update. It assumes there is either a current hook we can\n// clone, or a work-in-progress hook from a previous render pass that we can\n// use as a base. When we reach the end of the base list, we must switch to\n// the dispatcher used for mounts.\nvar nextCurrentHook;if(currentHook===null){var current=currentlyRenderingFiber$1.alternate;if(current!==null){nextCurrentHook=current.memoizedState;}else{nextCurrentHook=null;}}else{nextCurrentHook=currentHook.next;}var nextWorkInProgressHook;if(workInProgressHook===null){nextWorkInProgressHook=currentlyRenderingFiber$1.memoizedState;}else{nextWorkInProgressHook=workInProgressHook.next;}if(nextWorkInProgressHook!==null){// There's already a work-in-progress. Reuse it.\nworkInProgressHook=nextWorkInProgressHook;nextWorkInProgressHook=workInProgressHook.next;currentHook=nextCurrentHook;}else{// Clone from the current hook.\nif(nextCurrentHook===null){throw new Error('Rendered more hooks than during the previous render.');}currentHook=nextCurrentHook;var newHook={memoizedState:currentHook.memoizedState,baseState:currentHook.baseState,baseQueue:currentHook.baseQueue,queue:currentHook.queue,next:null};if(workInProgressHook===null){// This is the first hook in the list.\ncurrentlyRenderingFiber$1.memoizedState=workInProgressHook=newHook;}else{// Append to the end of the list.\nworkInProgressHook=workInProgressHook.next=newHook;}}return workInProgressHook;}function createFunctionComponentUpdateQueue(){return{lastEffect:null,stores:null};}function basicStateReducer(state,action){// $FlowFixMe: Flow doesn't like mixed types\nreturn typeof action==='function'?action(state):action;}function mountReducer(reducer,initialArg,init){var hook=mountWorkInProgressHook();var initialState;if(init!==undefined){initialState=init(initialArg);}else{initialState=initialArg;}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:reducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchReducerAction.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;var current=currentHook;// The last rebase update that is NOT part of the base state.\nvar baseQueue=current.baseQueue;// The last pending update that hasn't been processed yet.\nvar pendingQueue=queue.pending;if(pendingQueue!==null){// We have new updates that haven't been processed yet.\n// We'll add them to the base queue.\nif(baseQueue!==null){// Merge the pending queue and the base queue.\nvar baseFirst=baseQueue.next;var pendingFirst=pendingQueue.next;baseQueue.next=pendingFirst;pendingQueue.next=baseFirst;}{if(current.baseQueue!==baseQueue){// Internal invariant that should never happen, but feasibly could in\n// the future if we implement resuming, or some form of that.\nerror('Internal error: Expected work-in-progress queue to be a clone. '+'This is a bug in React.');}}current.baseQueue=baseQueue=pendingQueue;queue.pending=null;}if(baseQueue!==null){// We have a queue to process.\nvar first=baseQueue.next;var newState=current.baseState;var newBaseState=null;var newBaseQueueFirst=null;var newBaseQueueLast=null;var update=first;do{var updateLane=update.lane;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first\n// skipped update, the previous update/state is the new base\n// update/state.\nvar clone={lane:updateLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};if(newBaseQueueLast===null){newBaseQueueFirst=newBaseQueueLast=clone;newBaseState=newState;}else{newBaseQueueLast=newBaseQueueLast.next=clone;}// Update the remaining priority in the queue.\n// TODO: Don't need to accumulate this. Instead, we can remove\n// renderLanes from the original lanes.\ncurrentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,updateLane);markSkippedUpdateLanes(updateLane);}else{// This update does have sufficient priority.\nif(newBaseQueueLast!==null){var _clone={// This update is going to be committed so we never want uncommit\n// it. Using NoLane works because 0 is a subset of all bitmasks, so\n// this will never be skipped by the check above.\nlane:NoLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};newBaseQueueLast=newBaseQueueLast.next=_clone;}// Process this update.\nif(update.hasEagerState){// If this update is a state update (not a reducer) and was processed eagerly,\n// we can use the eagerly computed state\nnewState=update.eagerState;}else{var action=update.action;newState=reducer(newState,action);}}update=update.next;}while(update!==null&&update!==first);if(newBaseQueueLast===null){newBaseState=newState;}else{newBaseQueueLast.next=newBaseQueueFirst;}// Mark that the fiber performed work, but only if the new state is\n// different from the current state.\nif(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;hook.baseState=newBaseState;hook.baseQueue=newBaseQueueLast;queue.lastRenderedState=newState;}// Interleaved updates are stored on a separate queue. We aren't going to\n// process them during this render, but we do need to track which lanes\n// are remaining.\nvar lastInterleaved=queue.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{var interleavedLane=interleaved.lane;currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,interleavedLane);markSkippedUpdateLanes(interleavedLane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(baseQueue===null){// `queue.lanes` is used for entangling transitions. We can set it back to\n// zero once the queue is empty.\nqueue.lanes=NoLanes;}var dispatch=queue.dispatch;return[hook.memoizedState,dispatch];}function rerenderReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;// This is a re-render. Apply the new render phase updates to the previous\n// work-in-progress hook.\nvar dispatch=queue.dispatch;var lastRenderPhaseUpdate=queue.pending;var newState=hook.memoizedState;if(lastRenderPhaseUpdate!==null){// The queue doesn't persist past this render pass.\nqueue.pending=null;var firstRenderPhaseUpdate=lastRenderPhaseUpdate.next;var update=firstRenderPhaseUpdate;do{// Process this render phase update. We don't have to check the\n// priority because it will always be the same as the current\n// render's.\nvar action=update.action;newState=reducer(newState,action);update=update.next;}while(update!==firstRenderPhaseUpdate);// Mark that the fiber performed work, but only if the new state is\n// different from the current state.\nif(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;// Don't persist the state accumulated from the render phase updates to\n// the base state unless the queue is empty.\n// TODO: Not sure if this is the desired semantics, but it's what we\n// do for gDSFP. I can't remember why.\nif(hook.baseQueue===null){hook.baseState=newState;}queue.lastRenderedState=newState;}return[newState,dispatch];}function mountMutableSource(source,getSnapshot,subscribe){{return undefined;}}function updateMutableSource(source,getSnapshot,subscribe){{return undefined;}}function mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=mountWorkInProgressHook();var nextSnapshot;var isHydrating=getIsHydrating();if(isHydrating){if(getServerSnapshot===undefined){throw new Error('Missing getServerSnapshot, which is required for '+'server-rendered content. Will revert to client rendering.');}nextSnapshot=getServerSnapshot();{if(!didWarnUncachedGetSnapshot){if(nextSnapshot!==getServerSnapshot()){error('The result of getServerSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}}else{nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}// Unless we're rendering a blocking lane, schedule a consistency check.\n// Right before committing, we will walk the tree and check if any of the\n// stores were mutated.\n//\n// We won't do this if we're hydrating server-rendered content, because if\n// the content is stale, it's already visible anyway. Instead we'll patch\n// it up in a passive effect.\nvar root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}// Read the current snapshot from the store on every render. This breaks the\n// normal rules of React, and only works because store updates are\n// always synchronous.\nhook.memoizedState=nextSnapshot;var inst={value:nextSnapshot,getSnapshot:getSnapshot};hook.queue=inst;// Schedule an effect to subscribe to the store.\nmountEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Schedule an effect to update the mutable instance fields. We will update\n// this whenever subscribe, getSnapshot, or value changes. Because there's no\n// clean-up function, and we track the deps correctly, we can call pushEffect\n// directly, without storing any additional state. For the same reason, we\n// don't need to set a static flag, either.\n// TODO: We can move this to the passive phase once we add a pre-commit\n// consistency check. See the next comment.\nfiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);return nextSnapshot;}function updateSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=updateWorkInProgressHook();// Read the current snapshot from the store on every render. This breaks the\n// normal rules of React, and only works because store updates are\n// always synchronous.\nvar nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}var prevSnapshot=hook.memoizedState;var snapshotChanged=!objectIs(prevSnapshot,nextSnapshot);if(snapshotChanged){hook.memoizedState=nextSnapshot;markWorkInProgressReceivedUpdate();}var inst=hook.queue;updateEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Whenever getSnapshot or subscribe changes, we need to check in the\n// commit phase if there was an interleaved mutation. In concurrent mode\n// this can happen all the time, but even in synchronous mode, an earlier\n// effect may have mutated the store.\nif(inst.getSnapshot!==getSnapshot||snapshotChanged||// Check if the susbcribe function changed. We can save some memory by\n// checking whether we scheduled a subscription effect above.\nworkInProgressHook!==null&&workInProgressHook.memoizedState.tag&HasEffect){fiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);// Unless we're rendering a blocking lane, schedule a consistency check.\n// Right before committing, we will walk the tree and check if any of the\n// stores were mutated.\nvar root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}return nextSnapshot;}function pushStoreConsistencyCheck(fiber,getSnapshot,renderedSnapshot){fiber.flags|=StoreConsistency;var check={getSnapshot:getSnapshot,value:renderedSnapshot};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.stores=[check];}else{var stores=componentUpdateQueue.stores;if(stores===null){componentUpdateQueue.stores=[check];}else{stores.push(check);}}}function updateStoreInstance(fiber,inst,nextSnapshot,getSnapshot){// These are updated in the passive phase\ninst.value=nextSnapshot;inst.getSnapshot=getSnapshot;// Something may have been mutated in between render and commit. This could\n// have been in an event that fired before the passive effects, or it could\n// have been in a layout effect. In that case, we would have used the old\n// snapsho and getSnapshot values to bail out. We need to check one more time.\nif(checkIfSnapshotChanged(inst)){// Force a re-render.\nforceStoreRerender(fiber);}}function subscribeToStore(fiber,inst,subscribe){var handleStoreChange=function handleStoreChange(){// The store changed. Check if the snapshot changed since the last time we\n// read from the store.\nif(checkIfSnapshotChanged(inst)){// Force a re-render.\nforceStoreRerender(fiber);}};// Subscribe to the store and return a clean-up function.\nreturn subscribe(handleStoreChange);}function checkIfSnapshotChanged(inst){var latestGetSnapshot=inst.getSnapshot;var prevValue=inst.value;try{var nextValue=latestGetSnapshot();return!objectIs(prevValue,nextValue);}catch(error){return true;}}function forceStoreRerender(fiber){scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);}function mountState(initialState){var hook=mountWorkInProgressHook();if(typeof initialState==='function'){// $FlowFixMe: Flow doesn't like mixed types\ninitialState=initialState();}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchSetState.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateState(initialState){return updateReducer(basicStateReducer);}function rerenderState(initialState){return rerenderReducer(basicStateReducer);}function pushEffect(tag,create,destroy,deps){var effect={tag:tag,create:create,destroy:destroy,deps:deps,// Circular\nnext:null};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.lastEffect=effect.next=effect;}else{var lastEffect=componentUpdateQueue.lastEffect;if(lastEffect===null){componentUpdateQueue.lastEffect=effect.next=effect;}else{var firstEffect=lastEffect.next;lastEffect.next=effect;effect.next=firstEffect;componentUpdateQueue.lastEffect=effect;}}return effect;}function mountRef(initialValue){var hook=mountWorkInProgressHook();{var _ref2={current:initialValue};hook.memoizedState=_ref2;return _ref2;}}function updateRef(initialValue){var hook=updateWorkInProgressHook();return hook.memoizedState;}function mountEffectImpl(fiberFlags,hookFlags,create,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,undefined,nextDeps);}function updateEffectImpl(fiberFlags,hookFlags,create,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var destroy=undefined;if(currentHook!==null){var prevEffect=currentHook.memoizedState;destroy=prevEffect.destroy;if(nextDeps!==null){var prevDeps=prevEffect.deps;if(areHookInputsEqual(nextDeps,prevDeps)){hook.memoizedState=pushEffect(hookFlags,create,destroy,nextDeps);return;}}}currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,destroy,nextDeps);}function mountEffect(create,deps){if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){return mountEffectImpl(MountPassiveDev|Passive|PassiveStatic,Passive$1,create,deps);}else{return mountEffectImpl(Passive|PassiveStatic,Passive$1,create,deps);}}function updateEffect(create,deps){return updateEffectImpl(Passive,Passive$1,create,deps);}function mountInsertionEffect(create,deps){return mountEffectImpl(Update,Insertion,create,deps);}function updateInsertionEffect(create,deps){return updateEffectImpl(Update,Insertion,create,deps);}function mountLayoutEffect(create,deps){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,create,deps);}function updateLayoutEffect(create,deps){return updateEffectImpl(Update,Layout,create,deps);}function imperativeHandleEffect(create,ref){if(typeof ref==='function'){var refCallback=ref;var _inst=create();refCallback(_inst);return function(){refCallback(null);};}else if(ref!==null&&ref!==undefined){var refObject=ref;{if(!refObject.hasOwnProperty('current')){error('Expected useImperativeHandle() first argument to either be a '+'ref callback or React.createRef() object. Instead received: %s.','an object with keys {'+Object.keys(refObject).join(', ')+'}');}}var _inst2=create();refObject.current=_inst2;return function(){refObject.current=null;};}}function mountImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?_typeof(create):'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?\nvar effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function updateImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?_typeof(create):'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?\nvar effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;return updateEffectImpl(Update,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function mountDebugValue(value,formatterFn){// This hook is normally a no-op.\n// The react-debug-hooks package injects its own implementation\n// so that e.g. DevTools can display custom hook values.\n}var updateDebugValue=mountDebugValue;function mountCallback(callback,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;hook.memoizedState=[callback,nextDeps];return callback;}function updateCallback(callback,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){if(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}hook.memoizedState=[callback,nextDeps];return callback;}function mountMemo(nextCreate,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function updateMemo(nextCreate,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){// Assume these are defined. If they're not, areHookInputsEqual will warn.\nif(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function mountDeferredValue(value){var _mountState=mountState(value),prevValue=_mountState[0],setValue=_mountState[1];mountEffect(function(){var prevTransition=ReactCurrentBatchConfig$2.transition;ReactCurrentBatchConfig$2.transition={};try{setValue(value);}finally{ReactCurrentBatchConfig$2.transition=prevTransition;}},[value]);return prevValue;}function updateDeferredValue(value){var _updateState=updateState(),prevValue=_updateState[0],setValue=_updateState[1];updateEffect(function(){var prevTransition=ReactCurrentBatchConfig$2.transition;ReactCurrentBatchConfig$2.transition={};try{setValue(value);}finally{ReactCurrentBatchConfig$2.transition=prevTransition;}},[value]);return prevValue;}function rerenderDeferredValue(value){var _rerenderState=rerenderState(),prevValue=_rerenderState[0],setValue=_rerenderState[1];updateEffect(function(){var prevTransition=ReactCurrentBatchConfig$2.transition;ReactCurrentBatchConfig$2.transition={};try{setValue(value);}finally{ReactCurrentBatchConfig$2.transition=prevTransition;}},[value]);return prevValue;}function startTransition(setPending,callback,options){var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(higherEventPriority(previousPriority,ContinuousEventPriority));setPending(true);var prevTransition=ReactCurrentBatchConfig$2.transition;ReactCurrentBatchConfig$2.transition={};var currentTransition=ReactCurrentBatchConfig$2.transition;{ReactCurrentBatchConfig$2.transition._updatedFibers=new Set();}try{setPending(false);callback();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$2.transition=prevTransition;{if(prevTransition===null&&currentTransition._updatedFibers){var updatedFibersCount=currentTransition._updatedFibers.size;if(updatedFibersCount>10){warn('Detected a large number of updates inside startTransition. '+'If this is due to a subscription please re-write it to use React provided hooks. '+'Otherwise concurrent mode guarantees are off the table.');}currentTransition._updatedFibers.clear();}}}}function mountTransition(){var _mountState2=mountState(false),isPending=_mountState2[0],setPending=_mountState2[1];// The `start` method never changes.\nvar start=startTransition.bind(null,setPending);var hook=mountWorkInProgressHook();hook.memoizedState=start;return[isPending,start];}function updateTransition(){var _updateState2=updateState(),isPending=_updateState2[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return[isPending,start];}function rerenderTransition(){var _rerenderState2=rerenderState(),isPending=_rerenderState2[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return[isPending,start];}var isUpdatingOpaqueValueInRenderPhase=false;function getIsUpdatingOpaqueValueInRenderPhaseInDEV(){{return isUpdatingOpaqueValueInRenderPhase;}}function mountId(){var hook=mountWorkInProgressHook();var root=getWorkInProgressRoot();// TODO: In Fizz, id generation is specific to each server config. Maybe we\n// should do this in Fiber, too? Deferring this decision for now because\n// there's no other place to store the prefix except for an internal field on\n// the public createRoot object, which the fiber tree does not currently have\n// a reference to.\nvar identifierPrefix=root.identifierPrefix;var id;if(getIsHydrating()){var treeId=getTreeId();// Use a captial R prefix for server-generated ids.\nid=':'+identifierPrefix+'R'+treeId;// Unless this is the first id at this level, append a number at the end\n// that represents the position of this useId hook among all the useId\n// hooks for this fiber.\nvar localId=localIdCounter++;if(localId>0){id+='H'+localId.toString(32);}id+=':';}else{// Use a lowercase r prefix for client-generated ids.\nvar globalClientId=globalClientIdCounter++;id=':'+identifierPrefix+'r'+globalClientId.toString(32)+':';}hook.memoizedState=id;return id;}function updateId(){var hook=updateWorkInProgressHook();var id=hook.memoizedState;return id;}function dispatchReducerAction(fiber,queue,action){{if(typeof arguments[3]==='function'){error(\"State updates from the useState() and useReducer() Hooks don't support the \"+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else{enqueueUpdate$1(fiber,queue,update);var eventTime=requestEventTime();var root=scheduleUpdateOnFiber(fiber,lane,eventTime);if(root!==null){entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function dispatchSetState(fiber,queue,action){{if(typeof arguments[3]==='function'){error(\"State updates from the useState() and useReducer() Hooks don't support the \"+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else{enqueueUpdate$1(fiber,queue,update);var alternate=fiber.alternate;if(fiber.lanes===NoLanes&&(alternate===null||alternate.lanes===NoLanes)){// The queue is currently empty, which means we can eagerly compute the\n// next state before entering the render phase. If the new state is the\n// same as the current state, we may be able to bail out entirely.\nvar lastRenderedReducer=queue.lastRenderedReducer;if(lastRenderedReducer!==null){var prevDispatcher;{prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;}try{var currentState=queue.lastRenderedState;var eagerState=lastRenderedReducer(currentState,action);// Stash the eagerly computed state, and the reducer used to compute\n// it, on the update object. If the reducer hasn't changed by the\n// time we enter the render phase, then the eager state can be used\n// without calling the reducer again.\nupdate.hasEagerState=true;update.eagerState=eagerState;if(objectIs(eagerState,currentState)){// Fast path. We can bail out without scheduling React to re-render.\n// It's still possible that we'll need to rebase this update later,\n// if the component re-renders for a different reason and by that\n// time the reducer has changed.\nreturn;}}catch(error){// Suppress the error. It will throw again in the render phase.\n}finally{{ReactCurrentDispatcher$1.current=prevDispatcher;}}}}var eventTime=requestEventTime();var root=scheduleUpdateOnFiber(fiber,lane,eventTime);if(root!==null){entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function isRenderPhaseUpdate(fiber){var alternate=fiber.alternate;return fiber===currentlyRenderingFiber$1||alternate!==null&&alternate===currentlyRenderingFiber$1;}function enqueueRenderPhaseUpdate(queue,update){// This is a render phase update. Stash it in a lazily-created map of\n// queue -> linked list of updates. After this render pass, we'll restart\n// and apply the stashed updates on top of the work-in-progress hook.\ndidScheduleRenderPhaseUpdateDuringThisPass=didScheduleRenderPhaseUpdate=true;var pending=queue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}queue.pending=update;}function enqueueUpdate$1(fiber,queue,update,lane){if(isInterleavedUpdate(fiber)){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\nupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n// be transferred to the pending queue.\npushInterleavedQueue(queue);}else{update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;}else{var pending=queue.pending;if(pending===null){// This is the first update. Create a circular list.\nupdate.next=update;}else{update.next=pending.next;pending.next=update;}queue.pending=update;}}function entangleTransitionUpdate(root,queue,lane){if(isTransitionLane(lane)){var queueLanes=queue.lanes;// If any entangled lanes are no longer pending on the root, then they\n// must have finished. We can remove them from the shared queue, which\n// represents a superset of the actually pending lanes. In some cases we\n// may entangle more than we need to, but that's OK. In fact it's worse if\n// we *don't* entangle when we should.\nqueueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.\nvar newQueueLanes=mergeLanes(queueLanes,lane);queue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if\n// the lane finished since the last time we entangled it. So we need to\n// entangle it again, just to be sure.\nmarkRootEntangled(root,newQueueLanes);}}function markUpdateInDevTools(fiber,lane,action){{markStateUpdateScheduled(fiber,lane);}}var ContextOnlyDispatcher={readContext:_readContext,useCallback:throwInvalidHookError,useContext:throwInvalidHookError,useEffect:throwInvalidHookError,useImperativeHandle:throwInvalidHookError,useInsertionEffect:throwInvalidHookError,useLayoutEffect:throwInvalidHookError,useMemo:throwInvalidHookError,useReducer:throwInvalidHookError,useRef:throwInvalidHookError,useState:throwInvalidHookError,useDebugValue:throwInvalidHookError,useDeferredValue:throwInvalidHookError,useTransition:throwInvalidHookError,useMutableSource:throwInvalidHookError,useSyncExternalStore:throwInvalidHookError,useId:throwInvalidHookError,unstable_isNewReconciler:enableNewReconciler};var HooksDispatcherOnMountInDEV=null;var HooksDispatcherOnMountWithHookTypesInDEV=null;var HooksDispatcherOnUpdateInDEV=null;var HooksDispatcherOnRerenderInDEV=null;var InvalidNestedHooksDispatcherOnMountInDEV=null;var InvalidNestedHooksDispatcherOnUpdateInDEV=null;var InvalidNestedHooksDispatcherOnRerenderInDEV=null;{var warnInvalidContextAccess=function warnInvalidContextAccess(){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');};var warnInvalidHookAccess=function warnInvalidHookAccess(){error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. '+'You can only call Hooks at the top level of your React function. '+'For more information, see '+'https://reactjs.org/link/rules-of-hooks');};HooksDispatcherOnMountInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';mountHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';mountHookTypesDev();checkDepsAreArrayDev(deps);var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';mountHookTypesDev();return mountRef(initialValue);},useState:function useState(initialState){currentHookNameInDev='useState';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';mountHookTypesDev();return mountDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';mountHookTypesDev();return mountDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';mountHookTypesDev();return mountTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function useId(){currentHookNameInDev='useId';mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnMountWithHookTypesInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return mountCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return mountRef(initialValue);},useState:function useState(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return mountDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return mountDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';updateHookTypesDev();return mountTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return mountMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function useId(){currentHookNameInDev='useId';updateHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnUpdateInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return updateDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';updateHookTypesDev();return updateTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnRerenderInDEV={readContext:function readContext(context){return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';updateHookTypesDev();return rerenderTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnMountInDEV={readContext:function readContext(context){warnInvalidContextAccess();return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();mountHookTypesDev();return mountCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';warnInvalidHookAccess();mountHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();mountHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();mountHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();mountHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();mountHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();mountHookTypesDev();return mountRef(initialValue);},useState:function useState(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();mountHookTypesDev();return mountDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();mountHookTypesDev();return mountDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';warnInvalidHookAccess();mountHookTypesDev();return mountTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function useId(){currentHookNameInDev='useId';warnInvalidHookAccess();mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnUpdateInDEV={readContext:function readContext(context){warnInvalidContextAccess();return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return updateDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return updateTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnRerenderInDEV={readContext:function readContext(context){warnInvalidContextAccess();return _readContext(context);},useCallback:function useCallback(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function useContext(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return _readContext(context);},useEffect:function useEffect(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function useImperativeHandle(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function useInsertionEffect(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function useLayoutEffect(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function useMemo(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function useReducer(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function useRef(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function useState(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function useDebugValue(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function useDeferredValue(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function useTransition(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return rerenderTransition();},useMutableSource:function useMutableSource(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function useId(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};}var now$1=Scheduler.unstable_now;var commitTime=0;var layoutEffectStartTime=-1;var profilerStartTime=-1;var passiveEffectStartTime=-1;/**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */var currentUpdateIsNested=false;var nestedUpdateScheduled=false;function isCurrentUpdateNested(){return currentUpdateIsNested;}function markNestedUpdateScheduled(){{nestedUpdateScheduled=true;}}function resetNestedUpdateFlag(){{currentUpdateIsNested=false;nestedUpdateScheduled=false;}}function syncNestedUpdateFlag(){{currentUpdateIsNested=nestedUpdateScheduled;nestedUpdateScheduled=false;}}function getCommitTime(){return commitTime;}function recordCommitTime(){commitTime=now$1();}function startProfilerTimer(fiber){profilerStartTime=now$1();if(fiber.actualStartTime<0){fiber.actualStartTime=now$1();}}function stopProfilerTimerIfRunning(fiber){profilerStartTime=-1;}function stopProfilerTimerIfRunningAndRecordDelta(fiber,overrideBaseTime){if(profilerStartTime>=0){var elapsedTime=now$1()-profilerStartTime;fiber.actualDuration+=elapsedTime;if(overrideBaseTime){fiber.selfBaseDuration=elapsedTime;}profilerStartTime=-1;}}function recordLayoutEffectDuration(fiber){if(layoutEffectStartTime>=0){var elapsedTime=now$1()-layoutEffectStartTime;layoutEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor\n// Or the root (for the DevTools Profiler to read)\nvar parentFiber=fiber[\"return\"];while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=elapsedTime;return;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=elapsedTime;return;}parentFiber=parentFiber[\"return\"];}}}function recordPassiveEffectDuration(fiber){if(passiveEffectStartTime>=0){var elapsedTime=now$1()-passiveEffectStartTime;passiveEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor\n// Or the root (for the DevTools Profiler to read)\nvar parentFiber=fiber[\"return\"];while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;if(root!==null){root.passiveEffectDuration+=elapsedTime;}return;case Profiler:var parentStateNode=parentFiber.stateNode;if(parentStateNode!==null){// Detached fibers have their state node cleared out.\n// In this case, the return pointer is also cleared out,\n// so we won't be able to report the time spent in this Profiler's subtree.\nparentStateNode.passiveEffectDuration+=elapsedTime;}return;}parentFiber=parentFiber[\"return\"];}}}function startLayoutEffectTimer(){layoutEffectStartTime=now$1();}function startPassiveEffectTimer(){passiveEffectStartTime=now$1();}function transferActualDuration(fiber){// Transfer time spent rendering these children so we don't lose it\n// after we rerender. This is used as a helper in special cases\n// where we should count the work of multiple passes.\nvar child=fiber.child;while(child){fiber.actualDuration+=child.actualDuration;child=child.sibling;}}function createCapturedValue(value,source){// If the value is an error, call this function immediately after it is thrown\n// so the stack is accurate.\nreturn{value:value,source:source,stack:getStackByFiberInDevAndProd(source)};}// This module is forked in different environments.\n// By default, return `true` to log errors to the console.\n// Forks can return `false` if this isn't desirable.\nfunction showErrorDialog(boundary,errorInfo){return true;}function logCapturedError(boundary,errorInfo){try{var logError=showErrorDialog(boundary,errorInfo);// Allow injected showErrorDialog() to prevent default console.error logging.\n// This enables renderers like ReactNative to better manage redbox behavior.\nif(logError===false){return;}var error=errorInfo.value;if(true){var source=errorInfo.source;var stack=errorInfo.stack;var componentStack=stack!==null?stack:'';// Browsers support silencing uncaught errors by calling\n// `preventDefault()` in window `error` handler.\n// We record this information as an expando on the error.\nif(error!=null&&error._suppressLogging){if(boundary.tag===ClassComponent){// The error is recoverable and was silenced.\n// Ignore it and don't print the stack addendum.\n// This is handy for testing error boundaries without noise.\nreturn;}// The error is fatal. Since the silencing might have\n// been accidental, we'll surface it anyway.\n// However, the browser would have silenced the original error\n// so we'll print it first, and then print the stack addendum.\nconsole['error'](error);// Don't transform to our wrapper\n// For a more detailed description of this block, see:\n// https://github.com/facebook/react/pull/13384\n}var componentName=source?getComponentNameFromFiber(source):null;var componentNameMessage=componentName?\"The above error occurred in the <\"+componentName+\"> component:\":'The above error occurred in one of your React components:';var errorBoundaryMessage;if(boundary.tag===HostRoot){errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\\n'+'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';}else{var errorBoundaryName=getComponentNameFromFiber(boundary)||'Anonymous';errorBoundaryMessage=\"React will try to recreate this component tree from scratch \"+(\"using the error boundary you provided, \"+errorBoundaryName+\".\");}var combinedMessage=componentNameMessage+\"\\n\"+componentStack+\"\\n\\n\"+(\"\"+errorBoundaryMessage);// In development, we provide our own message with just the component stack.\n// We don't include the original error message and JS stack because the browser\n// has already printed it. Even if the application swallows the error, it is still\n// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\nconsole['error'](combinedMessage);// Don't transform to our wrapper\n}else{}}catch(e){// This method must not throw, or React internal state will get messed up.\n// If console.error is overridden, or logCapturedError() shows a dialog that throws,\n// we want to report this error outside of the normal stack as a last resort.\n// https://github.com/facebook/react/issues/13188\nsetTimeout(function(){throw e;});}}var PossiblyWeakMap$1=typeof WeakMap==='function'?WeakMap:Map;function createRootErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);// Unmount the root by rendering null.\nupdate.tag=CaptureUpdate;// Caution: React DevTools currently depends on this property\n// being called \"element\".\nupdate.payload={element:null};var error=errorInfo.value;update.callback=function(){onUncaughtError(error);logCapturedError(fiber,errorInfo);};return update;}function createClassErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);update.tag=CaptureUpdate;var getDerivedStateFromError=fiber.type.getDerivedStateFromError;if(typeof getDerivedStateFromError==='function'){var error$1=errorInfo.value;update.payload=function(){return getDerivedStateFromError(error$1);};update.callback=function(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);};}var inst=fiber.stateNode;if(inst!==null&&typeof inst.componentDidCatch==='function'){update.callback=function callback(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);if(typeof getDerivedStateFromError!=='function'){// To preserve the preexisting retry behavior of error boundaries,\n// we keep track of which ones already failed during this batch.\n// This gets reset before we yield back to the browser.\n// TODO: Warn in strict mode if getDerivedStateFromError is\n// not defined.\nmarkLegacyErrorBoundaryAsFailed(this);}var error$1=errorInfo.value;var stack=errorInfo.stack;this.componentDidCatch(error$1,{componentStack:stack!==null?stack:''});{if(typeof getDerivedStateFromError!=='function'){// If componentDidCatch is the only error boundary method defined,\n// then it needs to call setState to recover from errors.\n// If no state update is scheduled then the boundary will swallow the error.\nif(!includesSomeLane(fiber.lanes,SyncLane)){error('%s: Error boundaries should implement getDerivedStateFromError(). '+'In that method, return a state update to display an error message or fallback UI.',getComponentNameFromFiber(fiber)||'Unknown');}}}};}return update;}function attachPingListener(root,wakeable,lanes){// Attach a ping listener\n//\n// The data might resolve before we have a chance to commit the fallback. Or,\n// in the case of a refresh, we'll never commit a fallback. So we need to\n// attach a listener now. When it resolves (\"pings\"), we can decide whether to\n// try rendering the tree again.\n//\n// Only attach a listener if one does not already exist for the lanes\n// we're currently rendering (which acts like a \"thread ID\" here).\n//\n// We only need to do this in concurrent mode. Legacy Suspense always\n// commits fallbacks synchronously, so there are no pings.\nvar pingCache=root.pingCache;var threadIDs;if(pingCache===null){pingCache=root.pingCache=new PossiblyWeakMap$1();threadIDs=new Set();pingCache.set(wakeable,threadIDs);}else{threadIDs=pingCache.get(wakeable);if(threadIDs===undefined){threadIDs=new Set();pingCache.set(wakeable,threadIDs);}}if(!threadIDs.has(lanes)){// Memoize using the thread ID to prevent redundant listeners.\nthreadIDs.add(lanes);var ping=pingSuspendedRoot.bind(null,root,wakeable,lanes);{if(isDevToolsPresent){// If we have pending work still, restore the original updaters\nrestorePendingUpdaters(root,lanes);}}wakeable.then(ping,ping);}}function attachRetryListener(suspenseBoundary,root,wakeable,lanes){// Retry listener\n//\n// If the fallback does commit, we need to attach a different type of\n// listener. This one schedules an update on the Suspense boundary to turn\n// the fallback state off.\n//\n// Stash the wakeable on the boundary fiber so we can access it in the\n// commit phase.\n//\n// When the wakeable resolves, we'll attempt to render the boundary\n// again (\"retry\").\nvar wakeables=suspenseBoundary.updateQueue;if(wakeables===null){var updateQueue=new Set();updateQueue.add(wakeable);suspenseBoundary.updateQueue=updateQueue;}else{wakeables.add(wakeable);}}function resetSuspendedComponent(sourceFiber,rootRenderLanes){// A legacy mode Suspense quirk, only relevant to hook components.\nvar tag=sourceFiber.tag;if((sourceFiber.mode&ConcurrentMode)===NoMode&&(tag===FunctionComponent||tag===ForwardRef||tag===SimpleMemoComponent)){var currentSource=sourceFiber.alternate;if(currentSource){sourceFiber.updateQueue=currentSource.updateQueue;sourceFiber.memoizedState=currentSource.memoizedState;sourceFiber.lanes=currentSource.lanes;}else{sourceFiber.updateQueue=null;sourceFiber.memoizedState=null;}}}function getNearestSuspenseBoundaryToCapture(returnFiber){var node=returnFiber;do{if(node.tag===SuspenseComponent&&shouldCaptureSuspense(node)){return node;}// This boundary already captured during this render. Continue to the next\n// boundary.\nnode=node[\"return\"];}while(node!==null);return null;}function markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes){// This marks a Suspense boundary so that when we're unwinding the stack,\n// it captures the suspended \"exception\" and does a second (fallback) pass.\nif((suspenseBoundary.mode&ConcurrentMode)===NoMode){// Legacy Mode Suspense\n//\n// If the boundary is in legacy mode, we should *not*\n// suspend the commit. Pretend as if the suspended component rendered\n// null and keep rendering. When the Suspense boundary completes,\n// we'll do a second pass to render the fallback.\nif(suspenseBoundary===returnFiber){// Special case where we suspended while reconciling the children of\n// a Suspense boundary's inner Offscreen wrapper fiber. This happens\n// when a React.lazy component is a direct child of a\n// Suspense boundary.\n//\n// Suspense boundaries are implemented as multiple fibers, but they\n// are a single conceptual unit. The legacy mode behavior where we\n// pretend the suspended fiber committed as `null` won't work,\n// because in this case the \"suspended\" fiber is the inner\n// Offscreen wrapper.\n//\n// Because the contents of the boundary haven't started rendering\n// yet (i.e. nothing in the tree has partially rendered) we can\n// switch to the regular, concurrent mode behavior: mark the\n// boundary with ShouldCapture and enter the unwind phase.\nsuspenseBoundary.flags|=ShouldCapture;}else{suspenseBoundary.flags|=DidCapture;sourceFiber.flags|=ForceUpdateForLegacySuspense;// We're going to commit this fiber even though it didn't complete.\n// But we shouldn't call any lifecycle methods or callbacks. Remove\n// all lifecycle effect tags.\nsourceFiber.flags&=~(LifecycleEffectMask|Incomplete);if(sourceFiber.tag===ClassComponent){var currentSourceFiber=sourceFiber.alternate;if(currentSourceFiber===null){// This is a new mount. Change the tag so it's not mistaken for a\n// completed class component. For example, we should not call\n// componentWillUnmount if it is deleted.\nsourceFiber.tag=IncompleteClassComponent;}else{// When we try rendering again, we should not reuse the current fiber,\n// since it's known to be in an inconsistent state. Use a force update to\n// prevent a bail out.\nvar update=createUpdate(NoTimestamp,SyncLane);update.tag=ForceUpdate;enqueueUpdate(sourceFiber,update);}}// The source fiber did not complete. Mark it with Sync priority to\n// indicate that it still has pending work.\nsourceFiber.lanes=mergeLanes(sourceFiber.lanes,SyncLane);}return suspenseBoundary;}// Confirmed that the boundary is in a concurrent mode tree. Continue\n// with the normal suspend path.\n//\n// After this we'll use a set of heuristics to determine whether this\n// render pass will run to completion or restart or \"suspend\" the commit.\n// The actual logic for this is spread out in different places.\n//\n// This first principle is that if we're going to suspend when we complete\n// a root, then we should also restart if we get an update or ping that\n// might unsuspend it, and vice versa. The only reason to suspend is\n// because you think you might want to restart before committing. However,\n// it doesn't make sense to restart only while in the period we're suspended.\n//\n// Restarting too aggressively is also not good because it starves out any\n// intermediate loading state. So we use heuristics to determine when.\n// Suspense Heuristics\n//\n// If nothing threw a Promise or all the same fallbacks are already showing,\n// then don't suspend/restart.\n//\n// If this is an initial render of a new tree of Suspense boundaries and\n// those trigger a fallback, then don't suspend/restart. We want to ensure\n// that we can show the initial loading state as quickly as possible.\n//\n// If we hit a \"Delayed\" case, such as when we'd switch from content back into\n// a fallback, then we should always suspend/restart. Transitions apply\n// to this case. If none is defined, JND is used instead.\n//\n// If we're already showing a fallback and it gets \"retried\", allowing us to show\n// another level, but there's still an inner boundary that would show a fallback,\n// then we suspend/restart for 500ms since the last time we showed a fallback\n// anywhere in the tree. This effectively throttles progressive loading into a\n// consistent train of commits. This also gives us an opportunity to restart to\n// get to the completed state slightly earlier.\n//\n// If there's ambiguity due to batching it's resolved in preference of:\n// 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n//\n// We want to ensure that a \"busy\" state doesn't get force committed. We want to\n// ensure that new initial loading states can commit as soon as possible.\nsuspenseBoundary.flags|=ShouldCapture;// TODO: I think we can remove this, since we now use `DidCapture` in\n// the begin phase to prevent an early bailout.\nsuspenseBoundary.lanes=rootRenderLanes;return suspenseBoundary;}function throwException(root,returnFiber,sourceFiber,value,rootRenderLanes){// The source fiber did not complete.\nsourceFiber.flags|=Incomplete;{if(isDevToolsPresent){// If we have pending work still, restore the original updaters\nrestorePendingUpdaters(root,rootRenderLanes);}}if(value!==null&&_typeof(value)==='object'&&typeof value.then==='function'){// This is a wakeable. The component suspended.\nvar wakeable=value;resetSuspendedComponent(sourceFiber);var suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);if(suspenseBoundary!==null){suspenseBoundary.flags&=~ForceClientRender;markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// We only attach ping listeners in concurrent mode. Legacy Suspense always\n// commits fallbacks synchronously, so there are no pings.\nif(suspenseBoundary.mode&ConcurrentMode){attachPingListener(root,wakeable,rootRenderLanes);}attachRetryListener(suspenseBoundary,root,wakeable);return;}else{// No boundary was found. Unless this is a sync update, this is OK.\n// We can suspend and wait for more data to arrive.\nif(!includesSyncLane(rootRenderLanes)){// This is not a sync update. Suspend. Since we're not activating a\n// Suspense boundary, this will unwind all the way to the root without\n// performing a second pass to render a fallback. (This is arguably how\n// refresh transitions should work, too, since we're not going to commit\n// the fallbacks anyway.)\n//\n// This case also applies to initial hydration.\nattachPingListener(root,wakeable,rootRenderLanes);renderDidSuspendDelayIfPossible();return;}// This is a sync/discrete update. We treat this case like an error\n// because discrete renders are expected to produce a complete tree\n// synchronously to maintain consistency with external state.\nvar uncaughtSuspenseError=new Error('A component suspended while responding to synchronous input. This '+'will cause the UI to be replaced with a loading indicator. To '+'fix, updates that suspend should be wrapped '+'with startTransition.');// If we're outside a transition, fall through to the regular error path.\n// The error will be caught by the nearest suspense boundary.\nvalue=uncaughtSuspenseError;}}else{// This is a regular error, not a Suspense wakeable.\nif(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidSuspendWhileHydratingDEV();var _suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);// If the error was thrown during hydration, we may be able to recover by\n// discarding the dehydrated content and switching to a client render.\n// Instead of surfacing the error, find the nearest Suspense boundary\n// and render it again without hydration.\nif(_suspenseBoundary!==null){if((_suspenseBoundary.flags&ShouldCapture)===NoFlags){// Set a flag to indicate that we should try rendering the normal\n// children again, not the fallback.\n_suspenseBoundary.flags|=ForceClientRender;}markSuspenseBoundaryShouldCapture(_suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// Even though the user may not be affected by this error, we should\n// still log it so it can be fixed.\nqueueHydrationError(value);return;}}}// We didn't find a boundary that could handle this type of exception. Start\n// over and traverse parent path again, this time treating the exception\n// as an error.\nrenderDidError(value);value=createCapturedValue(value,sourceFiber);var workInProgress=returnFiber;do{switch(workInProgress.tag){case HostRoot:{var _errorInfo=value;workInProgress.flags|=ShouldCapture;var lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);var update=createRootErrorUpdate(workInProgress,_errorInfo,lane);enqueueCapturedUpdate(workInProgress,update);return;}case ClassComponent:// Capture and retry\nvar errorInfo=value;var ctor=workInProgress.type;var instance=workInProgress.stateNode;if((workInProgress.flags&DidCapture)===NoFlags&&(typeof ctor.getDerivedStateFromError==='function'||instance!==null&&typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance))){workInProgress.flags|=ShouldCapture;var _lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,_lane);// Schedule the error boundary to re-render using updated state\nvar _update=createClassErrorUpdate(workInProgress,errorInfo,_lane);enqueueCapturedUpdate(workInProgress,_update);return;}break;}workInProgress=workInProgress[\"return\"];}while(workInProgress!==null);}function getSuspendedCache(){{return null;}// This function is called when a Suspense boundary suspends. It returns the\n}function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into\n// a PlacementAndUpdate.\nworkInProgress.flags|=Update;}function markRef(workInProgress){workInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}var appendAllChildren;var updateHostContainer;var updateHostComponent;var updateHostText;{// Mutation mode\nappendAllChildren=function appendAllChildren(parent,workInProgress,needsVisibilityToggle,isHidden){// We only have the top Fiber that was created but we need recurse down its\n// children to find all the terminal nodes.\nvar node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal);else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===workInProgress){return;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}};updateHostContainer=function updateHostContainer(current,workInProgress){// Noop\n};updateHostComponent=function updateHostComponent(current,workInProgress,type,newProps,rootContainerInstance){// If we have an alternate, that means this is an update and we need to\n// schedule a side-effect to do the updates.\nvar oldProps=current.memoizedProps;if(oldProps===newProps){// In mutation mode, this is sufficient for a bailout because\n// we won't touch this node even if children changed.\nreturn;}// If we get updated because one of our children updated, we don't\n// have newProps so we'll have to reuse them.\n// TODO: Split the update API as separate for the props vs. children.\n// Even better would be if children weren't special cased at all tho.\nvar instance=workInProgress.stateNode;var currentHostContext=getHostContext();// TODO: Experiencing an error where oldProps is null. Suggests a host\n// component is hitting the resume path. Figure out why. Possibly\n// related to `hidden`.\nvar updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);// TODO: Type this specific to this type of component.\nworkInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there\n// is a new ref we mark this as an update. All the work is done in commitWork.\nif(updatePayload){markUpdate(workInProgress);}};updateHostText=function updateHostText(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.\nif(oldText!==newText){markUpdate(workInProgress);}};}function cutOffTailIfNeeded(renderState,hasRenderedATailFallback){if(getIsHydrating()){// If we're hydrating, we should consume as many items as we can\n// so we don't leave any behind.\nreturn;}switch(renderState.tailMode){case'hidden':{// Any insertions at the end of the tail list after this point\n// should be invisible. If there are already mounted boundaries\n// anything before them are not considered for collapsing.\n// Therefore we need to go through the whole tail to find if\n// there are any.\nvar tailNode=renderState.tail;var lastTailNode=null;while(tailNode!==null){if(tailNode.alternate!==null){lastTailNode=tailNode;}tailNode=tailNode.sibling;}// Next we're simply going to delete all insertions after the\n// last rendered item.\nif(lastTailNode===null){// All remaining items in the tail are insertions.\nrenderState.tail=null;}else{// Detach the insertion after the last node that was already\n// inserted.\nlastTailNode.sibling=null;}break;}case'collapsed':{// Any insertions at the end of the tail list after this point\n// should be invisible. If there are already mounted boundaries\n// anything before them are not considered for collapsing.\n// Therefore we need to go through the whole tail to find if\n// there are any.\nvar _tailNode=renderState.tail;var _lastTailNode=null;while(_tailNode!==null){if(_tailNode.alternate!==null){_lastTailNode=_tailNode;}_tailNode=_tailNode.sibling;}// Next we're simply going to delete all insertions after the\n// last rendered item.\nif(_lastTailNode===null){// All remaining items in the tail are insertions.\nif(!hasRenderedATailFallback&&renderState.tail!==null){// We suspended during the head. We want to show at least one\n// row at the tail. So we'll keep on and cut off the rest.\nrenderState.tail.sibling=null;}else{renderState.tail=null;}}else{// Detach the insertion after the last node that was already\n// inserted.\n_lastTailNode.sibling=null;}break;}}}function bubbleProperties(completedWork){var didBailout=completedWork.alternate!==null&&completedWork.alternate.child===completedWork.child;var newChildLanes=NoLanes;var subtreeFlags=NoFlags;if(!didBailout){// Bubble up the earliest expiration time.\nif((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset\n// profiler durations.\nvar actualDuration=completedWork.actualDuration;var treeBaseDuration=completedWork.selfBaseDuration;var child=completedWork.child;while(child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(child.lanes,child.childLanes));subtreeFlags|=child.subtreeFlags;subtreeFlags|=child.flags;// When a fiber is cloned, its actualDuration is reset to 0. This value will\n// only be updated if work is done on the fiber (i.e. it doesn't bailout).\n// When work is done, it should bubble to the parent's actualDuration. If\n// the fiber has not been cloned though, (meaning no work was done), then\n// this value will reflect the amount of time spent working on a previous\n// render. In that case it should not bubble. We determine whether it was\n// cloned by comparing the child pointer.\nactualDuration+=child.actualDuration;treeBaseDuration+=child.treeBaseDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;completedWork.treeBaseDuration=treeBaseDuration;}else{var _child=completedWork.child;while(_child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child.lanes,_child.childLanes));subtreeFlags|=_child.subtreeFlags;subtreeFlags|=_child.flags;// Update the return pointer so the tree is consistent. This is a code\n// smell because it assumes the commit phase is never concurrent with\n// the render phase. Will address during refactor to alternate model.\n_child[\"return\"]=completedWork;_child=_child.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}else{// Bubble up the earliest expiration time.\nif((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset\n// profiler durations.\nvar _treeBaseDuration=completedWork.selfBaseDuration;var _child2=completedWork.child;while(_child2!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child2.lanes,_child2.childLanes));// \"Static\" flags share the lifetime of the fiber/hook they belong to,\n// so we should bubble those up even during a bailout. All the other\n// flags have a lifetime only of a single render + commit, so we should\n// ignore them.\nsubtreeFlags|=_child2.subtreeFlags&StaticMask;subtreeFlags|=_child2.flags&StaticMask;_treeBaseDuration+=_child2.treeBaseDuration;_child2=_child2.sibling;}completedWork.treeBaseDuration=_treeBaseDuration;}else{var _child3=completedWork.child;while(_child3!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child3.lanes,_child3.childLanes));// \"Static\" flags share the lifetime of the fiber/hook they belong to,\n// so we should bubble those up even during a bailout. All the other\n// flags have a lifetime only of a single render + commit, so we should\n// ignore them.\nsubtreeFlags|=_child3.subtreeFlags&StaticMask;subtreeFlags|=_child3.flags&StaticMask;// Update the return pointer so the tree is consistent. This is a code\n// smell because it assumes the commit phase is never concurrent with\n// the render phase. Will address during refactor to alternate model.\n_child3[\"return\"]=completedWork;_child3=_child3.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}completedWork.childLanes=newChildLanes;return didBailout;}function completeWork(current,workInProgress,renderLanes){var newProps=workInProgress.pendingProps;// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(workInProgress);switch(workInProgress.tag){case IndeterminateComponent:case LazyComponent:case SimpleMemoComponent:case FunctionComponent:case ForwardRef:case Fragment:case Mode:case Profiler:case ContextConsumer:case MemoComponent:bubbleProperties(workInProgress);return null;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case HostRoot:{var fiberRoot=workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children\n// that weren't hydrated.\nvar wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// If we hydrated, then we'll need to schedule an update for\n// the commit side-effects on the root.\nmarkUpdate(workInProgress);}else{if(current!==null){var prevState=current.memoizedState;if(// Check if this is a client root\n!prevState.isDehydrated||// Check if we reverted to client rendering (e.g. due to an error)\n(workInProgress.flags&ForceClientRender)!==NoFlags){// Schedule an effect to clear this container at the start of the\n// next commit. This handles the case of React rendering into a\n// container with previous children. It's also safe to do for\n// updates too, because current.child would only be null if the\n// previous render was null (so the container would already\n// be empty).\nworkInProgress.flags|=Snapshot;// If this was a forced client render, there may have been\n// recoverable errors during first hydration attempt. If so, add\n// them to a queue so we can log them in the commit phase.\nupgradeHydrationErrorsToRecoverable();}}}}updateHostContainer(current,workInProgress);bubbleProperties(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){updateHostComponent(current,workInProgress,type,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef(workInProgress);}}else{if(!newProps){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.\nbubbleProperties(workInProgress);return null;}var currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context\n// \"stack\" as the parent. Then append children as we go in beginWork\n// or completeWork depending on whether we want to add them top->down or\n// bottom->up. Top->down is faster in IE11.\nvar _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){// TODO: Move this and createInstance step into the beginPhase\n// to consolidate.\nif(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,currentHostContext)){// If changes to the hydrated node need to be applied at the\n// commit-phase we mark this as such.\nmarkUpdate(workInProgress);}}else{var instance=createInstance(type,newProps,rootContainerInstance,currentHostContext,workInProgress);appendAllChildren(instance,workInProgress,false,false);workInProgress.stateNode=instance;// Certain renderers require commit-time effects for initial mount.\n// (eg DOM renderer supports auto-focus for certain elements).\n// Make sure such renderers get scheduled for later work.\nif(finalizeInitialChildren(instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback\nmarkRef(workInProgress);}}bubbleProperties(workInProgress);return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need\n// to schedule a side-effect to do the updates.\nupdateHostText(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.\n}var _rootContainerInstance=getRootHostContainer();var _currentHostContext=getHostContext();var _wasHydrated2=popHydrationState(workInProgress);if(_wasHydrated2){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext,workInProgress);}}bubbleProperties(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var nextState=workInProgress.memoizedState;{if(hasUnhydratedTailNodes()&&(workInProgress.mode&ConcurrentMode)!==NoMode&&(workInProgress.flags&DidCapture)===NoFlags){warnIfUnhydratedTailNodes(workInProgress);resetHydrationState();workInProgress.flags|=ForceClientRender|Incomplete|ShouldCapture;return workInProgress;}if(nextState!==null&&nextState.dehydrated!==null){// We might be inside a hydration state the first time we're picking up this\n// Suspense boundary, and also after we've reentered it for further hydration.\nvar _wasHydrated3=popHydrationState(workInProgress);if(current===null){if(!_wasHydrated3){throw new Error('A dehydrated suspense component was completed without a hydrated node. '+'This is probably a bug in React.');}prepareToHydrateHostSuspenseInstance(workInProgress);bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var isTimedOutSuspense=nextState!==null;if(isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar primaryChildFragment=workInProgress.child;if(primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}}}return null;}else{// We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n// state since we're now exiting out of it. popHydrationState doesn't do that for us.\nresetHydrationState();if((workInProgress.flags&DidCapture)===NoFlags){// This boundary did not suspend so it's now hydrated and unsuspended.\nworkInProgress.memoizedState=null;}// If nothing suspended, we need to schedule an effect to mark this boundary\n// as having hydrated so events know that they're free to be invoked.\n// It's also a signal to replay events and the suspense callback.\n// If something suspended, schedule an effect to attach retry listeners.\n// So we might as well always mark this.\nworkInProgress.flags|=Update;bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var _isTimedOutSuspense=nextState!==null;if(_isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar _primaryChildFragment=workInProgress.child;if(_primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=_primaryChildFragment.treeBaseDuration;}}}}return null;}}// Successfully completed this tree. If this was a forced client render,\n// there may have been recoverable errors during first hydration\n// attempt. If so, add them to a queue so we can log them in the\n// commit phase.\nupgradeHydrationErrorsToRecoverable();}if((workInProgress.flags&DidCapture)!==NoFlags){// Something suspended. Re-render with the fallback children.\nworkInProgress.lanes=renderLanes;// Do not reset the effect list.\nif((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}// Don't bubble properties in this case.\nreturn workInProgress;}var nextDidTimeout=nextState!==null;var prevDidTimeout=false;if(current===null){popHydrationState(workInProgress);}else{var _prevState=current.memoizedState;prevDidTimeout=_prevState!==null;}// an effect to toggle the subtree's visibility. When we switch from\n// fallback -> primary, the inner Offscreen fiber schedules this effect\n// as part of its normal complete phase. But when we switch from\n// primary -> fallback, the inner Offscreen fiber does not have a complete\n// phase. So we need to schedule its effect here.\n//\n// We also use this flag to connect/disconnect the effects, but the same\n// logic applies: when re-connecting, the Offscreen fiber's complete\n// phase will handle scheduling the effect. It's only when the fallback\n// is active that we have to do anything special.\nif(nextDidTimeout&&!prevDidTimeout){var _offscreenFiber=workInProgress.child;_offscreenFiber.flags|=Visibility;// TODO: This will still suspend a synchronous tree if anything\n// in the concurrent tree already suspended during this render.\n// This is a known bug.\nif((workInProgress.mode&ConcurrentMode)!==NoMode){// TODO: Move this back to throwException because this is too late\n// if this is a large tree which is common for initial loads. We\n// don't know if we should restart a render or not until we get\n// this marker, and this is too late.\n// If this render already had a ping or lower pri updates,\n// and this is the first time we know we're going to suspend we\n// should be able to immediately restart from within throwException.\nvar hasInvisibleChildContext=current===null&&(workInProgress.memoizedProps.unstable_avoidThisFallback!==true||!enableSuspenseAvoidThisFallback);if(hasInvisibleChildContext||hasSuspenseContext(suspenseStackCursor.current,InvisibleParentSuspenseContext)){// If this was in an invisible tree or a new render, then showing\n// this boundary is ok.\nrenderDidSuspend();}else{// Otherwise, we're going to have to hide content so we should\n// suspend for longer if possible.\nrenderDidSuspendDelayIfPossible();}}}var wakeables=workInProgress.updateQueue;if(wakeables!==null){// Schedule an effect to attach a retry listener to the promise.\n// TODO: Move to passive phase\nworkInProgress.flags|=Update;}bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){if(nextDidTimeout){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\nvar _primaryChildFragment2=workInProgress.child;if(_primaryChildFragment2!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\nworkInProgress.treeBaseDuration-=_primaryChildFragment2.treeBaseDuration;}}}}return null;}case HostPortal:popHostContainer(workInProgress);updateHostContainer(current,workInProgress);if(current===null){preparePortalMount(workInProgress.stateNode.containerInfo);}bubbleProperties(workInProgress);return null;case ContextProvider:// Pop provider fiber\nvar context=workInProgress.type._context;popProvider(context,workInProgress);bubbleProperties(workInProgress);return null;case IncompleteClassComponent:{// Same as class component case. I put it down here so that the tags are\n// sequential to ensure this switch is compiled to a jump table.\nvar _Component=workInProgress.type;if(isContextProvider(_Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);var renderState=workInProgress.memoizedState;if(renderState===null){// We're running in the default, \"independent\" mode.\n// We don't do anything in this mode.\nbubbleProperties(workInProgress);return null;}var didSuspendAlready=(workInProgress.flags&DidCapture)!==NoFlags;var renderedTail=renderState.rendering;if(renderedTail===null){// We just rendered the head.\nif(!didSuspendAlready){// This is the first pass. We need to figure out if anything is still\n// suspended in the rendered set.\n// If new content unsuspended, but there's still some content that\n// didn't. Then we need to do a second pass that forces everything\n// to keep showing their fallbacks.\n// We might be suspended if something in this render pass suspended, or\n// something in the previous committed pass suspended. Otherwise,\n// there's no chance so we can skip the expensive call to\n// findFirstSuspended.\nvar cannotBeSuspended=renderHasNotSuspendedYet()&&(current===null||(current.flags&DidCapture)===NoFlags);if(!cannotBeSuspended){var row=workInProgress.child;while(row!==null){var suspended=findFirstSuspended(row);if(suspended!==null){didSuspendAlready=true;workInProgress.flags|=DidCapture;cutOffTailIfNeeded(renderState,false);// If this is a newly suspended tree, it might not get committed as\n// part of the second pass. In that case nothing will subscribe to\n// its thenables. Instead, we'll transfer its thenables to the\n// SuspenseList so that it can retry if they resolve.\n// There might be multiple of these in the list but since we're\n// going to wait for all of them anyway, it doesn't really matter\n// which ones gets to ping. In theory we could get clever and keep\n// track of how many dependencies remain but it gets tricky because\n// in the meantime, we can add/remove/change items and dependencies.\n// We might bail out of the loop before finding any but that\n// doesn't matter since that means that the other boundaries that\n// we did find already has their listeners attached.\nvar newThenables=suspended.updateQueue;if(newThenables!==null){workInProgress.updateQueue=newThenables;workInProgress.flags|=Update;}// Rerender the whole list, but this time, we'll force fallbacks\n// to stay in place.\n// Reset the effect flags before doing the second pass since that's now invalid.\n// Reset the child fibers to their original state.\nworkInProgress.subtreeFlags=NoFlags;resetChildFibers(workInProgress,renderLanes);// Set up the Suspense Context to force suspense and immediately\n// rerender the children.\npushSuspenseContext(workInProgress,setShallowSuspenseContext(suspenseStackCursor.current,ForceSuspenseFallback));// Don't bubble properties in this case.\nreturn workInProgress.child;}row=row.sibling;}}if(renderState.tail!==null&&now()>getRenderTargetTime()){// We have already passed our CPU deadline but we still have rows\n// left in the tail. We'll just give up further attempts to render\n// the main content and only render fallbacks.\nworkInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this\n// to get it started back up to attempt the next item. While in terms\n// of priority this work has the same priority as this current render,\n// it's not part of the same transition once the transition has\n// committed. If it's sync, we still want to yield so that it can be\n// painted. Conceptually, this is really the same as pinging.\n// We can use any RetryLane even if it's the one currently rendering\n// since we're leaving it behind on this node.\nworkInProgress.lanes=SomeRetryLane;}}else{cutOffTailIfNeeded(renderState,false);}// Next we're going to render the tail.\n}else{// Append the rendered row to the child list.\nif(!didSuspendAlready){var _suspended=findFirstSuspended(renderedTail);if(_suspended!==null){workInProgress.flags|=DidCapture;didSuspendAlready=true;// Ensure we transfer the update queue to the parent so that it doesn't\n// get lost if this row ends up dropped during a second pass.\nvar _newThenables=_suspended.updateQueue;if(_newThenables!==null){workInProgress.updateQueue=_newThenables;workInProgress.flags|=Update;}cutOffTailIfNeeded(renderState,true);// This might have been modified.\nif(renderState.tail===null&&renderState.tailMode==='hidden'&&!renderedTail.alternate&&!getIsHydrating()// We don't cut it if we're hydrating.\n){// We're done.\nbubbleProperties(workInProgress);return null;}}else if(// The time it took to render last row is greater than the remaining\n// time we have to render. So rendering one more row would likely\n// exceed it.\nnow()*2-renderState.renderingStartTime>getRenderTargetTime()&&renderLanes!==OffscreenLane){// We have now passed our CPU deadline and we'll just give up further\n// attempts to render the main content and only render fallbacks.\n// The assumption is that this is usually faster.\nworkInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this\n// to get it started back up to attempt the next item. While in terms\n// of priority this work has the same priority as this current render,\n// it's not part of the same transition once the transition has\n// committed. If it's sync, we still want to yield so that it can be\n// painted. Conceptually, this is really the same as pinging.\n// We can use any RetryLane even if it's the one currently rendering\n// since we're leaving it behind on this node.\nworkInProgress.lanes=SomeRetryLane;}}if(renderState.isBackwards){// The effect list of the backwards tail will have been added\n// to the end. This breaks the guarantee that life-cycles fire in\n// sibling order but that isn't a strong guarantee promised by React.\n// Especially since these might also just pop in during future commits.\n// Append to the beginning of the list.\nrenderedTail.sibling=workInProgress.child;workInProgress.child=renderedTail;}else{var previousSibling=renderState.last;if(previousSibling!==null){previousSibling.sibling=renderedTail;}else{workInProgress.child=renderedTail;}renderState.last=renderedTail;}}if(renderState.tail!==null){// We still have tail rows to render.\n// Pop a row.\nvar next=renderState.tail;renderState.rendering=next;renderState.tail=next.sibling;renderState.renderingStartTime=now();next.sibling=null;// Restore the context.\n// TODO: We can probably just avoid popping it instead and only\n// setting it the first time we go from not suspended to suspended.\nvar suspenseContext=suspenseStackCursor.current;if(didSuspendAlready){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);}else{suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);// Do a pass over the next row.\n// Don't bubble properties in this case.\nreturn next;}bubbleProperties(workInProgress);return null;}case ScopeComponent:{break;}case OffscreenComponent:case LegacyHiddenComponent:{popRenderLanes(workInProgress);var _nextState=workInProgress.memoizedState;var nextIsHidden=_nextState!==null;if(current!==null){var _prevState2=current.memoizedState;var prevIsHidden=_prevState2!==null;if(prevIsHidden!==nextIsHidden&&// LegacyHidden doesn't do any hiding — it only pre-renders.\n!enableLegacyHidden){workInProgress.flags|=Visibility;}}if(!nextIsHidden||(workInProgress.mode&ConcurrentMode)===NoMode){bubbleProperties(workInProgress);}else{// Don't bubble properties for hidden children unless we're rendering\n// at offscreen priority.\nif(includesSomeLane(subtreeRenderLanes,OffscreenLane)){bubbleProperties(workInProgress);{// Check if there was an insertion or update in the hidden subtree.\n// If so, we need to hide those nodes in the commit phase, so\n// schedule a visibility effect.\nif(workInProgress.subtreeFlags&(Placement|Update)){workInProgress.flags|=Visibility;}}}}return null;}case CacheComponent:{return null;}case TracingMarkerComponent:{return null;}}throw new Error(\"Unknown unit of work tag (\"+workInProgress.tag+\"). This error is likely caused by a bug in \"+'React. Please file an issue.');}var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner;var didReceiveUpdate=false;var didWarnAboutBadClass;var didWarnAboutModulePatternComponent;var didWarnAboutContextTypeOnFunctionComponent;var didWarnAboutGetDerivedStateOnFunctionComponent;var didWarnAboutFunctionRefs;var didWarnAboutReassigningProps;var didWarnAboutRevealOrder;var didWarnAboutTailOptions;{didWarnAboutBadClass={};didWarnAboutModulePatternComponent={};didWarnAboutContextTypeOnFunctionComponent={};didWarnAboutGetDerivedStateOnFunctionComponent={};didWarnAboutFunctionRefs={};didWarnAboutReassigningProps=false;didWarnAboutRevealOrder={};didWarnAboutTailOptions={};}function reconcileChildren(current,workInProgress,nextChildren,renderLanes){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we\n// won't update its child set by applying minimal side-effects. Instead,\n// we will add them all to the child before it gets rendered. That means\n// we can optimize this reconciliation pass by not tracking side-effects.\nworkInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);}else{// If the current child is the same as the work in progress, it means that\n// we haven't yet started any work on these children. Therefore, we use\n// the clone algorithm to create a copy of all the current children.\n// If we had any progressed work already, that is invalid at this point so\n// let's throw it out.\nworkInProgress.child=reconcileChildFibers(workInProgress,current.child,nextChildren,renderLanes);}}function forceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes){// This function is fork of reconcileChildren. It's used in cases where we\n// want to reconcile without matching against the existing set. This has the\n// effect of all current children being unmounted; even if the type and key\n// are the same, the old child is unmounted and a new child is created.\n//\n// To do this, we're going to go through the reconcile algorithm twice. In\n// the first pass, we schedule a deletion for all the current children by\n// passing null.\nworkInProgress.child=reconcileChildFibers(workInProgress,current.child,null,renderLanes);// In the second pass, we mount the new children. The trick here is that we\n// pass null in place of where we usually pass the current child set. This has\n// the effect of remounting all children regardless of whether their\n// identities match.\nworkInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}function updateForwardRef(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component\n// hasn't yet mounted. This happens after the first render suspends.\n// We'll need to figure out if this is fine or can cause issues.\n{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}var render=Component.render;var ref=workInProgress.ref;// The rest is a fork of updateFunctionComponent\nvar nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMemoComponent(current,workInProgress,Component,nextProps,renderLanes){if(current===null){var type=Component.type;if(isSimpleFunctionComponent(type)&&Component.compare===null&&// SimpleMemoComponent codepath doesn't resolve outer props either.\nComponent.defaultProps===undefined){var resolvedType=type;{resolvedType=resolveFunctionForHotReloading(type);}// If this is a plain function component without default props,\n// and with only the default shallow comparison, we upgrade it\n// to a SimpleMemoComponent to allow fast path updates.\nworkInProgress.tag=SimpleMemoComponent;workInProgress.type=resolvedType;{validateFunctionComponentInDev(workInProgress,type);}return updateSimpleMemoComponent(current,workInProgress,resolvedType,nextProps,renderLanes);}{var innerPropTypes=type.propTypes;if(innerPropTypes){// Inner memo component props aren't currently validated in createElement.\n// We could move it there, but we'd still need this for lazy code path.\ncheckPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(type));}}var child=createFiberFromTypeAndProps(Component.type,null,nextProps,workInProgress,workInProgress.mode,renderLanes);child.ref=workInProgress.ref;child[\"return\"]=workInProgress;workInProgress.child=child;return child;}{var _type=Component.type;var _innerPropTypes=_type.propTypes;if(_innerPropTypes){// Inner memo component props aren't currently validated in createElement.\n// We could move it there, but we'd still need this for lazy code path.\ncheckPropTypes(_innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(_type));}}var currentChild=current.child;// This is always exactly one child\nvar hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext){// This will be the props with resolved defaultProps,\n// unlike current.memoizedProps which will be the unresolved ones.\nvar prevProps=currentChild.memoizedProps;// Default to shallow comparison\nvar compare=Component.compare;compare=compare!==null?compare:shallowEqual;if(compare(prevProps,nextProps)&&current.ref===workInProgress.ref){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;var newChild=createWorkInProgress(currentChild,nextProps);newChild.ref=workInProgress.ref;newChild[\"return\"]=workInProgress;workInProgress.child=newChild;return newChild;}function updateSimpleMemoComponent(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component\n// hasn't yet mounted. This happens when the inner render suspends.\n// We'll need to figure out if this is fine or can cause issues.\n{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar outerMemoType=workInProgress.elementType;if(outerMemoType.$$typeof===REACT_LAZY_TYPE){// We warn when you define propTypes on lazy()\n// so let's just skip over it to find memo() outer wrapper.\n// Inner props for memo are validated later.\nvar lazyComponent=outerMemoType;var payload=lazyComponent._payload;var init=lazyComponent._init;try{outerMemoType=init(payload);}catch(x){outerMemoType=null;}// Inner propTypes will be validated in the function component path.\nvar outerPropTypes=outerMemoType&&outerMemoType.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,nextProps,// Resolved (SimpleMemoComponent has no defaultProps)\n'prop',getComponentNameFromType(outerMemoType));}}}}if(current!==null){var prevProps=current.memoizedProps;if(shallowEqual(prevProps,nextProps)&&current.ref===workInProgress.ref&&// Prevent bailout if the implementation changed due to hot reload.\nworkInProgress.type===current.type){didReceiveUpdate=false;if(!checkScheduledUpdateOrContext(current,renderLanes)){// The pending lanes were cleared at the beginning of beginWork. We're\n// about to bail out, but there might be other lanes that weren't\n// included in the current render. Usually, the priority level of the\n// remaining updates is accumulated during the evaluation of the\n// component (i.e. when processing the update queue). But since since\n// we're bailing out early *without* evaluating the component, we need\n// to account for it here, too. Reset to the value of the current fiber.\n// NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n// because a MemoComponent fiber does not have hooks or an update queue;\n// rather, it wraps around an inner component, which may or may not\n// contains hooks.\n// TODO: Move the reset at in beginWork out of the common path so that\n// this is no longer necessary.\nworkInProgress.lanes=current.lanes;return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}else if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.\n// See https://github.com/facebook/react/pull/19216.\ndidReceiveUpdate=true;}}}return updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes);}function updateOffscreenComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;var prevState=current!==null?current.memoizedState:null;if(nextProps.mode==='hidden'||enableLegacyHidden){// Rendering a hidden tree.\nif((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy sync mode, don't defer the subtree. Render it now.\nvar nextState={baseLanes:NoLanes,cachePool:null};workInProgress.memoizedState=nextState;pushRenderLanes(workInProgress,renderLanes);}else if(!includesSomeLane(renderLanes,OffscreenLane)){var spawnedCachePool=null;// We're hidden, and we're not rendering at Offscreen. We will bail out\n// and resume this tree later.\nvar nextBaseLanes;if(prevState!==null){var prevBaseLanes=prevState.baseLanes;nextBaseLanes=mergeLanes(prevBaseLanes,renderLanes);}else{nextBaseLanes=renderLanes;}// Schedule this fiber to re-render at offscreen priority. Then bailout.\nworkInProgress.lanes=workInProgress.childLanes=laneToLanes(OffscreenLane);var _nextState={baseLanes:nextBaseLanes,cachePool:spawnedCachePool};workInProgress.memoizedState=_nextState;workInProgress.updateQueue=null;// to avoid a push/pop misalignment.\npushRenderLanes(workInProgress,nextBaseLanes);return null;}else{// This is the second render. The surrounding visible content has already\n// committed. Now we resume rendering the hidden tree.\n// Rendering at offscreen, so we can clear the base lanes.\nvar _nextState2={baseLanes:NoLanes,cachePool:null};workInProgress.memoizedState=_nextState2;// Push the lanes that were skipped when we bailed out.\nvar subtreeRenderLanes=prevState!==null?prevState.baseLanes:renderLanes;pushRenderLanes(workInProgress,subtreeRenderLanes);}}else{// Rendering a visible tree.\nvar _subtreeRenderLanes;if(prevState!==null){// We're going from hidden -> visible.\n_subtreeRenderLanes=mergeLanes(prevState.baseLanes,renderLanes);workInProgress.memoizedState=null;}else{// We weren't previously hidden, and we still aren't, so there's nothing\n// special to do. Need to push to the stack regardless, though, to avoid\n// a push/pop misalignment.\n_subtreeRenderLanes=renderLanes;}pushRenderLanes(workInProgress,_subtreeRenderLanes);}{reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}}function updateFragment(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMode(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateProfiler(current,workInProgress,renderLanes){{workInProgress.flags|=Update;{// Reset effect durations for the next eventual effect phase.\n// These are reset during render to allow the DevTools commit hook a chance to read them,\nvar stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function markRef$1(current,workInProgress){var ref=workInProgress.ref;if(current===null&&ref!==null||current!==null&&current.ref!==ref){// Schedule a Ref effect\nworkInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}}function updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes){{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,true);context=getMaskedContext(workInProgress,unmaskedContext);}var nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateClassComponent(current,workInProgress,Component,nextProps,renderLanes){{// This is used by DevTools to force a boundary to error.\nswitch(shouldError(workInProgress)){case false:{var _instance=workInProgress.stateNode;var ctor=workInProgress.type;// TODO This way of resetting the error boundary state is a hack.\n// Is there a better way to do this?\nvar tempInstance=new ctor(workInProgress.memoizedProps,_instance.context);var state=tempInstance.state;_instance.updater.enqueueSetState(_instance,state,null);break;}case true:{workInProgress.flags|=DidCapture;workInProgress.flags|=ShouldCapture;// eslint-disable-next-line react-internal/prod-error-codes\nvar error$1=new Error('Simulated error coming from DevTools');var lane=pickArbitraryLane(renderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);// Schedule the error boundary to re-render using updated state\nvar update=createClassErrorUpdate(workInProgress,createCapturedValue(error$1,workInProgress),lane);enqueueCapturedUpdate(workInProgress,update);break;}}if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n// because they're only guaranteed to be resolved here.\nvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n'prop',getComponentNameFromType(Component));}}}// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderLanes);var instance=workInProgress.stateNode;var shouldUpdate;if(instance===null){if(current!==null){// A class component without an instance only mounts if it suspended\n// inside a non-concurrent tree, in an inconsistent state. We want to\n// treat it like a new mount, even though an empty version of it already\n// committed. Disconnect the alternate pointers.\ncurrent.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect\nworkInProgress.flags|=Placement;}// In the initial pass we might need to construct the instance.\nconstructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);shouldUpdate=true;}else if(current===null){// In a resume, we'll already have an instance we can reuse.\nshouldUpdate=resumeMountClassInstance(workInProgress,Component,nextProps,renderLanes);}else{shouldUpdate=updateClassInstance(current,workInProgress,Component,nextProps,renderLanes);}var nextUnitOfWork=finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes);{var inst=workInProgress.stateNode;if(shouldUpdate&&inst.props!==nextProps){if(!didWarnAboutReassigningProps){error('It looks like %s is reassigning its own `this.props` while rendering. '+'This is not supported and can lead to confusing bugs.',getComponentNameFromFiber(workInProgress)||'a component');}didWarnAboutReassigningProps=true;}}return nextUnitOfWork;}function finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes){// Refs should update even if shouldComponentUpdate returns false\nmarkRef$1(current,workInProgress);var didCaptureError=(workInProgress.flags&DidCapture)!==NoFlags;if(!shouldUpdate&&!didCaptureError){// Context providers should defer to sCU for rendering\nif(hasContext){invalidateContextProvider(workInProgress,Component,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}var instance=workInProgress.stateNode;// Rerender\nReactCurrentOwner$1.current=workInProgress;var nextChildren;if(didCaptureError&&typeof Component.getDerivedStateFromError!=='function'){// If we captured an error, but getDerivedStateFromError is not defined,\n// unmount all the children. componentDidCatch will schedule an update to\n// re-render a fallback. This is temporary until we migrate everyone to\n// the new API.\n// TODO: Warn in a future release.\nnextChildren=null;{stopProfilerTimerIfRunning();}}else{{markComponentRenderStarted(workInProgress);}{setIsRendering(true);nextChildren=instance.render();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance.render();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;if(current!==null&&didCaptureError){// If we're recovering from an error, reconcile without reusing any of\n// the existing children. Conceptually, the normal children and the children\n// that are shown on error are two different sets, so we shouldn't reuse\n// normal children even if their identities match.\nforceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes);}else{reconcileChildren(current,workInProgress,nextChildren,renderLanes);}// Memoize state using the values we just used to render.\n// TODO: Restructure so we never read values from the instance.\nworkInProgress.memoizedState=instance.state;// The context might have changed so we need to recalculate it.\nif(hasContext){invalidateContextProvider(workInProgress,Component,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set\npushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderLanes){pushHostRootContext(workInProgress);if(current===null){throw new Error('Should have a current fiber. This is a bug in React.');}var nextProps=workInProgress.pendingProps;var prevState=workInProgress.memoizedState;var prevChildren=prevState.element;cloneUpdateQueue(current,workInProgress);processUpdateQueue(workInProgress,nextProps,null,renderLanes);var nextState=workInProgress.memoizedState;var root=workInProgress.stateNode;// being called \"element\".\nvar nextChildren=nextState.element;if(prevState.isDehydrated){// This is a hydration root whose shell has not yet hydrated. We should\n// attempt to hydrate.\n// Flip isDehydrated to false to indicate that when this render\n// finishes, the root will no longer be dehydrated.\nvar overrideState={element:nextChildren,isDehydrated:false,cache:nextState.cache,transitions:nextState.transitions};var updateQueue=workInProgress.updateQueue;// `baseState` can always be the last state because the root doesn't\n// have reducer functions so it doesn't need rebasing.\nupdateQueue.baseState=overrideState;workInProgress.memoizedState=overrideState;if(workInProgress.flags&ForceClientRender){// Something errored during a previous attempt to hydrate the shell, so we\n// forced a client render.\nvar recoverableError=new Error('There was an error while hydrating. Because the error happened outside '+'of a Suspense boundary, the entire root will switch to '+'client rendering.');return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError);}else if(nextChildren!==prevChildren){var _recoverableError=new Error('This root received an early update, before anything was able '+'hydrate. Switched the entire root to client rendering.');return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,_recoverableError);}else{// The outermost shell has not hydrated yet. Start hydrating.\nenterHydrationState(workInProgress);var child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);workInProgress.child=child;var node=child;while(node){// Mark each child as hydrating. This is a fast path to know whether this\n// tree is part of a hydrating tree. This is used to determine if a child\n// node has fully mounted yet, and for scheduling event replaying.\n// Conceptually this is similar to Placement in that a new subtree is\n// inserted into the React tree here. It just happens to not need DOM\n// mutations because it already exists.\nnode.flags=node.flags&~Placement|Hydrating;node=node.sibling;}}}else{// Root is not dehydrated. Either this is a client-only root, or it\n// already hydrated.\nresetHydrationState();if(nextChildren===prevChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}function mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError){// Revert to client rendering.\nresetHydrationState();queueHydrationError(recoverableError);workInProgress.flags|=ForceClientRender;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostComponent$1(current,workInProgress,renderLanes){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var nextProps=workInProgress.pendingProps;var prevProps=current!==null?current.memoizedProps:null;var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common\n// case. We won't handle it as a reified child. We will instead handle\n// this in the host environment that also has access to this prop. That\n// avoids allocating another HostText fiber and traversing it.\nnextChildren=null;}else if(prevProps!==null&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to\n// empty, we need to schedule the text content to be reset.\nworkInProgress.flags|=ContentReset;}markRef$1(current,workInProgress);reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostText$1(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}// Nothing to do here. This is terminal. We'll do the completion step\n// immediately after.\nreturn null;}function mountLazyComponent(_current,workInProgress,elementType,renderLanes){if(_current!==null){// A lazy component only mounts if it suspended inside a non-\n// concurrent tree, in an inconsistent state. We want to treat it like\n// a new mount, even though an empty version of it already committed.\n// Disconnect the alternate pointers.\n_current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect\nworkInProgress.flags|=Placement;}var props=workInProgress.pendingProps;var lazyComponent=elementType;var payload=lazyComponent._payload;var init=lazyComponent._init;var Component=init(payload);// Store the unwrapped component in the type.\nworkInProgress.type=Component;var resolvedTag=workInProgress.tag=resolveLazyComponentTag(Component);var resolvedProps=resolveDefaultProps(Component,props);var child;switch(resolvedTag){case FunctionComponent:{{validateFunctionComponentInDev(workInProgress,Component);workInProgress.type=Component=resolveFunctionForHotReloading(Component);}child=updateFunctionComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ClassComponent:{{workInProgress.type=Component=resolveClassForHotReloading(Component);}child=updateClassComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ForwardRef:{{workInProgress.type=Component=resolveForwardRefForHotReloading(Component);}child=updateForwardRef(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case MemoComponent:{{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=Component.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,resolvedProps,// Resolved for outer only\n'prop',getComponentNameFromType(Component));}}}child=updateMemoComponent(null,workInProgress,Component,resolveDefaultProps(Component.type,resolvedProps),// The inner type can have defaults too\nrenderLanes);return child;}}var hint='';{if(Component!==null&&_typeof(Component)==='object'&&Component.$$typeof===REACT_LAZY_TYPE){hint=' Did you wrap a component in React.lazy() more than once?';}}// This message intentionally doesn't mention ForwardRef or MemoComponent\n// because the fact that it's a separate type of work is an\n// implementation detail.\nthrow new Error(\"Element type is invalid. Received a promise that resolves to: \"+Component+\". \"+(\"Lazy element type must resolve to a class or function.\"+hint));}function mountIncompleteClassComponent(_current,workInProgress,Component,nextProps,renderLanes){if(_current!==null){// An incomplete component only mounts if it suspended inside a non-\n// concurrent tree, in an inconsistent state. We want to treat it like\n// a new mount, even though an empty version of it already committed.\n// Disconnect the alternate pointers.\n_current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect\nworkInProgress.flags|=Placement;}// Promote the fiber to a class and try rendering again.\nworkInProgress.tag=ClassComponent;// The rest of this function is a fork of `updateClassComponent`\n// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderLanes);constructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}function mountIndeterminateComponent(_current,workInProgress,Component,renderLanes){if(_current!==null){// An indeterminate component only mounts if it suspended inside a non-\n// concurrent tree, in an inconsistent state. We want to treat it like\n// a new mount, even though an empty version of it already committed.\n// Disconnect the alternate pointers.\n_current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect\nworkInProgress.flags|=Placement;}var props=workInProgress.pendingProps;var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,false);context=getMaskedContext(workInProgress,unmaskedContext);}prepareToReadContext(workInProgress,renderLanes);var value;var hasId;{markComponentRenderStarted(workInProgress);}{if(Component.prototype&&typeof Component.prototype.render==='function'){var componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutBadClass[componentName]){error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \"+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);didWarnAboutBadClass[componentName]=true;}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,null);}setIsRendering(true);ReactCurrentOwner$1.current=workInProgress;value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;{// Support for module components is deprecated and is removed behind a flag.\n// Whether or not it would crash later, we want to show a good message in DEV first.\nif(_typeof(value)==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){var _componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+\"If you can't use a class try assigning the prototype on the function as a workaround. \"+\"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \"+'cannot be called with `new` by React.',_componentName,_componentName,_componentName);didWarnAboutModulePatternComponent[_componentName]=true;}}}if(// Run these checks in production only if the flag is off.\n// Eventually we'll delete this branch altogether.\n_typeof(value)==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){{var _componentName2=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName2]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+\"If you can't use a class try assigning the prototype on the function as a workaround. \"+\"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \"+'cannot be called with `new` by React.',_componentName2,_componentName2,_componentName2);didWarnAboutModulePatternComponent[_componentName2]=true;}}// Proceed under the assumption that this is a class instance\nworkInProgress.tag=ClassComponent;// Throw out any hooks that were used.\nworkInProgress.memoizedState=null;workInProgress.updateQueue=null;// Push context providers early to prevent context stack mismatches.\n// During mounting we don't know the child context yet as the instance doesn't exist.\n// We will invalidate the child context in finishClassComponent() right after rendering.\nvar hasContext=false;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}workInProgress.memoizedState=value.state!==null&&value.state!==undefined?value.state:null;initializeUpdateQueue(workInProgress);adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,Component,props,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}else{// Proceed under the assumption that this is a function component\nworkInProgress.tag=FunctionComponent;{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}reconcileChildren(null,workInProgress,value,renderLanes);{validateFunctionComponentInDev(workInProgress,Component);}return workInProgress.child;}}function validateFunctionComponentInDev(workInProgress,Component){{if(Component){if(Component.childContextTypes){error('%s(...): childContextTypes cannot be defined on a function component.',Component.displayName||Component.name||'Component');}}if(workInProgress.ref!==null){var info='';var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){info+='\\n\\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!didWarnAboutFunctionRefs[warningKey]){didWarnAboutFunctionRefs[warningKey]=true;error('Function components cannot be given refs. '+'Attempts to access this ref will fail. '+'Did you mean to use React.forwardRef()?%s',info);}}if(typeof Component.getDerivedStateFromProps==='function'){var _componentName3=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]){error('%s: Function components do not support getDerivedStateFromProps.',_componentName3);didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]=true;}}if(_typeof(Component.contextType)==='object'&&Component.contextType!==null){var _componentName4=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutContextTypeOnFunctionComponent[_componentName4]){error('%s: Function components do not support contextType.',_componentName4);didWarnAboutContextTypeOnFunctionComponent[_componentName4]=true;}}}}var SUSPENDED_MARKER={dehydrated:null,treeContext:null,retryLane:NoLane};function mountSuspenseOffscreenState(renderLanes){return{baseLanes:renderLanes,cachePool:getSuspendedCache()};}function updateSuspenseOffscreenState(prevOffscreenState,renderLanes){var cachePool=null;return{baseLanes:mergeLanes(prevOffscreenState.baseLanes,renderLanes),cachePool:cachePool};}// TODO: Probably should inline this back\nfunction shouldRemainOnFallback(suspenseContext,current,workInProgress,renderLanes){// If we're already showing a fallback, there are cases where we need to\n// remain on that fallback regardless of whether the content has resolved.\n// For example, SuspenseList coordinates when nested content appears.\nif(current!==null){var suspenseState=current.memoizedState;if(suspenseState===null){// Currently showing content. Don't hide it, even if ForceSuspenseFallback\n// is true. More precise name might be \"ForceRemainSuspenseFallback\".\n// Note: This is a factoring smell. Can't remain on a fallback if there's\n// no fallback to remain on.\nreturn false;}}// Not currently showing content. Consult the Suspense context.\nreturn hasSuspenseContext(suspenseContext,ForceSuspenseFallback);}function getRemainingWorkInPrimaryTree(current,renderLanes){// TODO: Should not remove render lanes that were pinged during this render\nreturn removeLanes(current.childLanes,renderLanes);}function updateSuspenseComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;// This is used by DevTools to force a boundary to suspend.\n{if(shouldSuspend(workInProgress)){workInProgress.flags|=DidCapture;}}var suspenseContext=suspenseStackCursor.current;var showFallback=false;var didSuspend=(workInProgress.flags&DidCapture)!==NoFlags;if(didSuspend||shouldRemainOnFallback(suspenseContext,current)){// Something in this boundary's subtree already suspended. Switch to\n// rendering the fallback children.\nshowFallback=true;workInProgress.flags&=~DidCapture;}else{// Attempting the main content\nif(current===null||current.memoizedState!==null){// This is a new mount or this boundary is already showing a fallback state.\n// Mark this subtree context as having at least one invisible parent that could\n// handle the fallback state.\n// Avoided boundaries are not considered since they cannot handle preferred fallback states.\n{suspenseContext=addSubtreeSuspenseContext(suspenseContext,InvisibleParentSuspenseContext);}}}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);pushSuspenseContext(workInProgress,suspenseContext);// OK, the next part is confusing. We're about to reconcile the Suspense\n// boundary's children. This involves some custom reconciliation logic. Two\n// main reasons this is so complicated.\n//\n// First, Legacy Mode has different semantics for backwards compatibility. The\n// primary tree will commit in an inconsistent state, so when we do the\n// second pass to render the fallback, we do some exceedingly, uh, clever\n// hacks to make that not totally break. Like transferring effects and\n// deletions from hidden tree. In Concurrent Mode, it's much simpler,\n// because we bailout on the primary tree completely and leave it in its old\n// state, no effects. Same as what we do for Offscreen (except that\n// Offscreen doesn't have the first render pass).\n//\n// Second is hydration. During hydration, the Suspense fiber has a slightly\n// different layout, where the child points to a dehydrated fragment, which\n// contains the DOM rendered by the server.\n//\n// Third, even if you set all that aside, Suspense is like error boundaries in\n// that we first we try to render one tree, and if that fails, we render again\n// and switch to a different tree. Like a try/catch block. So we have to track\n// which branch we're currently rendering. Ideally we would model this using\n// a stack.\nif(current===null){// Initial mount\n// If we're currently hydrating, try to hydrate this boundary.\ntryToClaimNextHydratableInstance(workInProgress);// This could've been a dehydrated suspense component.\n{var suspenseState=workInProgress.memoizedState;if(suspenseState!==null){var dehydrated=suspenseState.dehydrated;if(dehydrated!==null){return mountDehydratedSuspenseComponent(workInProgress,dehydrated);}}}var nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;if(showFallback){var fallbackFragment=mountSuspenseFallbackChildren(workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var primaryChildFragment=workInProgress.child;primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackFragment;}else{return mountSuspensePrimaryChildren(workInProgress,nextPrimaryChildren);}}else{// This is an update.\n// If the current fiber has a SuspenseState, that means it's already showing\n// a fallback.\nvar prevState=current.memoizedState;if(prevState!==null){// The current tree is already showing a fallback\n// Special path for hydration\n{var _dehydrated=prevState.dehydrated;if(_dehydrated!==null){if(!didSuspend){return updateDehydratedSuspenseComponent(current,workInProgress,_dehydrated,prevState,renderLanes);}else if(workInProgress.flags&ForceClientRender){// Something errored during hydration. Try again without hydrating.\nworkInProgress.flags&=~ForceClientRender;return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,new Error('There was an error while hydrating this Suspense boundary. '+'Switched to client rendering.'));}else if(workInProgress.memoizedState!==null){// Something suspended and we should still be in dehydrated mode.\n// Leave the existing child in place.\nworkInProgress.child=current.child;// The dehydrated completion pass expects this flag to be there\n// but the normal suspense pass doesn't.\nworkInProgress.flags|=DidCapture;return null;}else{// Suspended but we should no longer be in dehydrated mode.\n// Therefore we now have to render the fallback.\nvar _nextPrimaryChildren=nextProps.children;var _nextFallbackChildren=nextProps.fallback;var fallbackChildFragment=mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,_nextPrimaryChildren,_nextFallbackChildren,renderLanes);var _primaryChildFragment2=workInProgress.child;_primaryChildFragment2.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackChildFragment;}}}if(showFallback){var _nextFallbackChildren2=nextProps.fallback;var _nextPrimaryChildren2=nextProps.children;var _fallbackChildFragment=updateSuspenseFallbackChildren(current,workInProgress,_nextPrimaryChildren2,_nextFallbackChildren2,renderLanes);var _primaryChildFragment3=workInProgress.child;var prevOffscreenState=current.child.memoizedState;_primaryChildFragment3.memoizedState=prevOffscreenState===null?mountSuspenseOffscreenState(renderLanes):updateSuspenseOffscreenState(prevOffscreenState,renderLanes);_primaryChildFragment3.childLanes=getRemainingWorkInPrimaryTree(current,renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return _fallbackChildFragment;}else{var _nextPrimaryChildren3=nextProps.children;var _primaryChildFragment4=updateSuspensePrimaryChildren(current,workInProgress,_nextPrimaryChildren3,renderLanes);workInProgress.memoizedState=null;return _primaryChildFragment4;}}else{// The current tree is not already showing a fallback.\nif(showFallback){// Timed out.\nvar _nextFallbackChildren3=nextProps.fallback;var _nextPrimaryChildren4=nextProps.children;var _fallbackChildFragment2=updateSuspenseFallbackChildren(current,workInProgress,_nextPrimaryChildren4,_nextFallbackChildren3,renderLanes);var _primaryChildFragment5=workInProgress.child;var _prevOffscreenState=current.child.memoizedState;_primaryChildFragment5.memoizedState=_prevOffscreenState===null?mountSuspenseOffscreenState(renderLanes):updateSuspenseOffscreenState(_prevOffscreenState,renderLanes);_primaryChildFragment5.childLanes=getRemainingWorkInPrimaryTree(current,renderLanes);// Skip the primary children, and continue working on the\n// fallback children.\nworkInProgress.memoizedState=SUSPENDED_MARKER;return _fallbackChildFragment2;}else{// Still haven't timed out. Continue rendering the children, like we\n// normally do.\nvar _nextPrimaryChildren5=nextProps.children;var _primaryChildFragment6=updateSuspensePrimaryChildren(current,workInProgress,_nextPrimaryChildren5,renderLanes);workInProgress.memoizedState=null;return _primaryChildFragment6;}}}}function mountSuspensePrimaryChildren(workInProgress,primaryChildren,renderLanes){var mode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);primaryChildFragment[\"return\"]=workInProgress;workInProgress.child=primaryChildFragment;return primaryChildFragment;}function mountSuspenseFallbackChildren(workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var progressedPrimaryFragment=workInProgress.child;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;var fallbackChildFragment;if((mode&ConcurrentMode)===NoMode&&progressedPrimaryFragment!==null){// In legacy mode, we commit the primary tree as if it successfully\n// completed, even though it's in an inconsistent state.\nprimaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the\n// final amounts. This seems counterintuitive, since we're intentionally\n// not measuring part of the render phase, but this makes it match what we\n// do in Concurrent Mode.\nprimaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=0;primaryChildFragment.treeBaseDuration=0;}fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}else{primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}primaryChildFragment[\"return\"]=workInProgress;fallbackChildFragment[\"return\"]=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function mountWorkInProgressOffscreenFiber(offscreenProps,mode,renderLanes){// The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n// this wrapper function to constrain it.\nreturn createFiberFromOffscreen(offscreenProps,mode,NoLanes,null);}function updateWorkInProgressOffscreenFiber(current,offscreenProps){// The props argument to `createWorkInProgress` is `any` typed, so we use this\n// wrapper function to constrain it.\nreturn createWorkInProgress(current,offscreenProps);}function updateSuspensePrimaryChildren(current,workInProgress,primaryChildren,renderLanes){var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,{mode:'visible',children:primaryChildren});if((workInProgress.mode&ConcurrentMode)===NoMode){primaryChildFragment.lanes=renderLanes;}primaryChildFragment[\"return\"]=workInProgress;primaryChildFragment.sibling=null;if(currentFallbackChildFragment!==null){// Delete the fallback child fragment\nvar deletions=workInProgress.deletions;if(deletions===null){workInProgress.deletions=[currentFallbackChildFragment];workInProgress.flags|=ChildDeletion;}else{deletions.push(currentFallbackChildFragment);}}workInProgress.child=primaryChildFragment;return primaryChildFragment;}function updateSuspenseFallbackChildren(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;if(// In legacy mode, we commit the primary tree as if it successfully\n// completed, even though it's in an inconsistent state.\n(mode&ConcurrentMode)===NoMode&&// Make sure we're on the second pass, i.e. the primary child fragment was\n// already cloned. In legacy mode, the only case where this isn't true is\n// when DevTools forces us to display a fallback; we skip the first render\n// pass entirely and go straight to rendering the fallback. (In Concurrent\n// Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n// only codepath.)\nworkInProgress.child!==currentPrimaryChildFragment){var progressedPrimaryFragment=workInProgress.child;primaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the\n// final amounts. This seems counterintuitive, since we're intentionally\n// not measuring part of the render phase, but this makes it match what we\n// do in Concurrent Mode.\nprimaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=currentPrimaryChildFragment.selfBaseDuration;primaryChildFragment.treeBaseDuration=currentPrimaryChildFragment.treeBaseDuration;}// However, since we're going to remain on the fallback, we no longer want\n// to delete it.\nworkInProgress.deletions=null;}else{primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,primaryChildProps);// (We don't do this in legacy mode, because in legacy mode we don't re-use\n// the current tree; see previous branch.)\nprimaryChildFragment.subtreeFlags=currentPrimaryChildFragment.subtreeFlags&StaticMask;}var fallbackChildFragment;if(currentFallbackChildFragment!==null){fallbackChildFragment=createWorkInProgress(currentFallbackChildFragment,fallbackChildren);}else{fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);// Needs a placement effect because the parent (the Suspense boundary) already\n// mounted but this is a new fiber.\nfallbackChildFragment.flags|=Placement;}fallbackChildFragment[\"return\"]=workInProgress;primaryChildFragment[\"return\"]=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,recoverableError){// Falling back to client rendering. Because this has performance\n// implications, it's considered a recoverable error, even though the user\n// likely won't observe anything wrong with the UI.\n//\n// The error is passed in as an argument to enforce that every caller provide\n// a custom message, or explicitly opt out (currently the only path that opts\n// out is legacy mode; every concurrent path provides an error).\nif(recoverableError!==null){queueHydrationError(recoverableError);}// This will add the old fiber to the deletion list\nreconcileChildFibers(workInProgress,current.child,null,renderLanes);// We're now not suspended nor dehydrated.\nvar nextProps=workInProgress.pendingProps;var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Needs a placement effect because the parent (the Suspense boundary) already\n// mounted but this is a new fiber.\nprimaryChildFragment.flags|=Placement;workInProgress.memoizedState=null;return primaryChildFragment;}function mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var fiberMode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,fiberMode);var fallbackChildFragment=createFiberFromFragment(fallbackChildren,fiberMode,renderLanes,null);// Needs a placement effect because the parent (the Suspense\n// boundary) already mounted but this is a new fiber.\nfallbackChildFragment.flags|=Placement;primaryChildFragment[\"return\"]=workInProgress;fallbackChildFragment[\"return\"]=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;if((workInProgress.mode&ConcurrentMode)!==NoMode){// We will have dropped the effect list which contains the\n// deletion. We need to reconcile to delete the current child.\nreconcileChildFibers(workInProgress,current.child,null,renderLanes);}return fallbackChildFragment;}function mountDehydratedSuspenseComponent(workInProgress,suspenseInstance,renderLanes){// During the first pass, we'll bail out and not drill into the children.\n// Instead, we'll leave the content in place and try to hydrate it later.\nif((workInProgress.mode&ConcurrentMode)===NoMode){{error('Cannot hydrate Suspense in legacy mode. Switch from '+'ReactDOM.hydrate(element, container) to '+'ReactDOMClient.hydrateRoot(container, <App />)'+'.render(element) or remove the Suspense components from '+'the server rendered components.');}workInProgress.lanes=laneToLanes(SyncLane);}else if(isSuspenseInstanceFallback(suspenseInstance)){// This is a client-only boundary. Since we won't get any content from the server\n// for this, we need to schedule that at a higher priority based on when it would\n// have timed out. In theory we could render it in this pass but it would have the\n// wrong priority associated with it and will prevent hydration of parent path.\n// Instead, we'll leave work left on it to render it in a separate commit.\n// TODO This time should be the time at which the server rendered response that is\n// a parent to this boundary was displayed. However, since we currently don't have\n// a protocol to transfer that time, we'll just estimate it by using the current\n// time. This will mean that Suspense timeouts are slightly shifted to later than\n// they should be.\n// Schedule a normal pri update to render this content.\nworkInProgress.lanes=laneToLanes(DefaultHydrationLane);}else{// We'll continue hydrating the rest at offscreen priority since we'll already\n// be showing the right content coming from the server, it is no rush.\nworkInProgress.lanes=laneToLanes(OffscreenLane);}return null;}function updateDehydratedSuspenseComponent(current,workInProgress,suspenseInstance,suspenseState,renderLanes){// We should never be hydrating at this point because it is the first pass,\n// but after we've already committed once.\nwarnIfHydrating();if((workInProgress.mode&ConcurrentMode)===NoMode){return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,// TODO: When we delete legacy mode, we should make this error argument\n// required — every concurrent mode path that causes hydration to\n// de-opt to client rendering should have an error message.\nnull);}if(isSuspenseInstanceFallback(suspenseInstance)){// This boundary is in a permanent fallback state. In this case, we'll never\n// get an update and we'll never be able to hydrate the final content. Let's just try the\n// client side render instead.\nreturn retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,// TODO: The server should serialize the error message so we can log it\n// here on the client. Or, in production, a hash/id that corresponds to\n// the error.\nnew Error('The server could not finish this Suspense boundary, likely '+'due to an error during server rendering. Switched to '+'client rendering.'));}// any context has changed, we need to treat is as if the input might have changed.\nvar hasContextChanged=includesSomeLane(renderLanes,current.childLanes);if(didReceiveUpdate||hasContextChanged){// This boundary has changed since the first render. This means that we are now unable to\n// hydrate it. We might still be able to hydrate it using a higher priority lane.\nvar root=getWorkInProgressRoot();if(root!==null){var attemptHydrationAtLane=getBumpedLaneForHydration(root,renderLanes);if(attemptHydrationAtLane!==NoLane&&attemptHydrationAtLane!==suspenseState.retryLane){// Intentionally mutating since this render will get interrupted. This\n// is one of the very rare times where we mutate the current tree\n// during the render phase.\nsuspenseState.retryLane=attemptHydrationAtLane;// TODO: Ideally this would inherit the event time of the current render\nvar eventTime=NoTimestamp;scheduleUpdateOnFiber(current,attemptHydrationAtLane,eventTime);}}// If we have scheduled higher pri work above, this will probably just abort the render\n// since we now have higher priority work, but in case it doesn't, we need to prepare to\n// render something, if we time out. Even if that requires us to delete everything and\n// skip hydration.\n// Delay having to do this as long as the suspense timeout allows us.\nrenderDidSuspendDelayIfPossible();return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,new Error('This Suspense boundary received an update before it finished '+'hydrating. This caused the boundary to switch to client rendering. '+'The usual way to fix this is to wrap the original update '+'in startTransition.'));}else if(isSuspenseInstancePending(suspenseInstance)){// This component is still pending more data from the server, so we can't hydrate its\n// content. We treat it as if this component suspended itself. It might seem as if\n// we could just try to render it client-side instead. However, this will perform a\n// lot of unnecessary work and is unlikely to complete since it often will suspend\n// on missing data anyway. Additionally, the server might be able to render more\n// than we can on the client yet. In that case we'd end up with more fallback states\n// on the client than if we just leave it alone. If the server times out or errors\n// these should update this boundary to the permanent Fallback state instead.\n// Mark it as having captured (i.e. suspended).\nworkInProgress.flags|=DidCapture;// Leave the child in place. I.e. the dehydrated fragment.\nworkInProgress.child=current.child;// Register a callback to retry this boundary once the server has sent the result.\nvar retry=retryDehydratedSuspenseBoundary.bind(null,current);registerSuspenseInstanceRetry(suspenseInstance,retry);return null;}else{// This is the first attempt.\nreenterHydrationStateFromDehydratedSuspenseInstance(workInProgress,suspenseInstance,suspenseState.treeContext);var nextProps=workInProgress.pendingProps;var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Mark the children as hydrating. This is a fast path to know whether this\n// tree is part of a hydrating tree. This is used to determine if a child\n// node has fully mounted yet, and for scheduling event replaying.\n// Conceptually this is similar to Placement in that a new subtree is\n// inserted into the React tree here. It just happens to not need DOM\n// mutations because it already exists.\nprimaryChildFragment.flags|=Hydrating;return primaryChildFragment;}}function scheduleSuspenseWorkOnFiber(fiber,renderLanes,propagationRoot){fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber[\"return\"],renderLanes,propagationRoot);}function propagateSuspenseContextChange(workInProgress,firstChild,renderLanes){// Mark any Suspense boundaries with fallbacks as having work to do.\n// If they were previously forced into fallbacks, they may now be able\n// to unblock.\nvar node=firstChild;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){scheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}}else if(node.tag===SuspenseListComponent){// If the tail is hidden there might not be an Suspense boundaries\n// to schedule work on. In this case we have to schedule it on the\n// list itself.\n// We don't have to traverse to the children of the list since\n// the list will propagate the change when it rerenders.\nscheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===workInProgress){return;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}}function findLastContentRow(firstChild){// This is going to find the last row among these children that is already\n// showing content on the screen, as opposed to being in fallback state or\n// new. If a row has multiple Suspense boundaries, any of them being in the\n// fallback state, counts as the whole row being in a fallback state.\n// Note that the \"rows\" will be workInProgress, but any nested children\n// will still be current since we haven't rendered them yet. The mounted\n// order may not be the same as the new order. We use the new order.\nvar row=firstChild;var lastContentRow=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.\nif(currentRow!==null&&findFirstSuspended(currentRow)===null){lastContentRow=row;}row=row.sibling;}return lastContentRow;}function validateRevealOrder(revealOrder){{if(revealOrder!==undefined&&revealOrder!=='forwards'&&revealOrder!=='backwards'&&revealOrder!=='together'&&!didWarnAboutRevealOrder[revealOrder]){didWarnAboutRevealOrder[revealOrder]=true;if(typeof revealOrder==='string'){switch(revealOrder.toLowerCase()){case'together':case'forwards':case'backwards':{error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. '+'Use lowercase \"%s\" instead.',revealOrder,revealOrder.toLowerCase());break;}case'forward':case'backward':{error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. '+'React uses the -s suffix in the spelling. Use \"%ss\" instead.',revealOrder,revealOrder.toLowerCase());break;}default:error('\"%s\" is not a supported revealOrder on <SuspenseList />. '+'Did you mean \"together\", \"forwards\" or \"backwards\"?',revealOrder);break;}}else{error('%s is not a supported value for revealOrder on <SuspenseList />. '+'Did you mean \"together\", \"forwards\" or \"backwards\"?',revealOrder);}}}}function validateTailOptions(tailMode,revealOrder){{if(tailMode!==undefined&&!didWarnAboutTailOptions[tailMode]){if(tailMode!=='collapsed'&&tailMode!=='hidden'){didWarnAboutTailOptions[tailMode]=true;error('\"%s\" is not a supported value for tail on <SuspenseList />. '+'Did you mean \"collapsed\" or \"hidden\"?',tailMode);}else if(revealOrder!=='forwards'&&revealOrder!=='backwards'){didWarnAboutTailOptions[tailMode]=true;error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is '+'\"forwards\" or \"backwards\". '+'Did you mean to specify revealOrder=\"forwards\"?',tailMode);}}}}function validateSuspenseListNestedChild(childSlot,index){{var isAnArray=isArray(childSlot);var isIterable=!isAnArray&&typeof getIteratorFn(childSlot)==='function';if(isAnArray||isIterable){var type=isAnArray?'array':'iterable';error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in '+'an additional SuspenseList to configure its revealOrder: '+'<SuspenseList revealOrder=...> ... '+'<SuspenseList revealOrder=...>{%s}</SuspenseList> ... '+'</SuspenseList>',type,index,type);return false;}}return true;}function validateSuspenseListChildren(children,revealOrder){{if((revealOrder==='forwards'||revealOrder==='backwards')&&children!==undefined&&children!==null&&children!==false){if(isArray(children)){for(var i=0;i<children.length;i++){if(!validateSuspenseListNestedChild(children[i],i)){return;}}}else{var iteratorFn=getIteratorFn(children);if(typeof iteratorFn==='function'){var childrenIterator=iteratorFn.call(children);if(childrenIterator){var step=childrenIterator.next();var _i=0;for(;!step.done;step=childrenIterator.next()){if(!validateSuspenseListNestedChild(step.value,_i)){return;}_i++;}}}else{error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. '+'This is not useful since it needs multiple rows. '+'Did you mean to pass multiple children or an array?',revealOrder);}}}}}function initSuspenseListRenderState(workInProgress,isBackwards,tail,lastContentRow,tailMode){var renderState=workInProgress.memoizedState;if(renderState===null){workInProgress.memoizedState={isBackwards:isBackwards,rendering:null,renderingStartTime:0,last:lastContentRow,tail:tail,tailMode:tailMode};}else{// We can reuse the existing object from previous renders.\nrenderState.isBackwards=isBackwards;renderState.rendering=null;renderState.renderingStartTime=0;renderState.last=lastContentRow;renderState.tail=tail;renderState.tailMode=tailMode;}}// This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\nfunction updateSuspenseListComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var revealOrder=nextProps.revealOrder;var tailMode=nextProps.tail;var newChildren=nextProps.children;validateRevealOrder(revealOrder);validateTailOptions(tailMode,revealOrder);validateSuspenseListChildren(newChildren,revealOrder);reconcileChildren(current,workInProgress,newChildren,renderLanes);var suspenseContext=suspenseStackCursor.current;var shouldForceFallback=hasSuspenseContext(suspenseContext,ForceSuspenseFallback);if(shouldForceFallback){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);workInProgress.flags|=DidCapture;}else{var didSuspendBefore=current!==null&&(current.flags&DidCapture)!==NoFlags;if(didSuspendBefore){// If we previously forced a fallback, we need to schedule work\n// on any nested boundaries to let them know to try to render\n// again. This is the same as context updating.\npropagateSuspenseContextChange(workInProgress,workInProgress.child,renderLanes);}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);if((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy mode, SuspenseList doesn't work so we just\n// use make it a noop by treating it as the default revealOrder.\nworkInProgress.memoizedState=null;}else{switch(revealOrder){case'forwards':{var lastContentRow=findLastContentRow(workInProgress.child);var tail;if(lastContentRow===null){// The whole list is part of the tail.\n// TODO: We could fast path by just rendering the tail now.\ntail=workInProgress.child;workInProgress.child=null;}else{// Disconnect the tail rows after the content row.\n// We're going to render them separately later.\ntail=lastContentRow.sibling;lastContentRow.sibling=null;}initSuspenseListRenderState(workInProgress,false,// isBackwards\ntail,lastContentRow,tailMode);break;}case'backwards':{// We're going to find the first row that has existing content.\n// At the same time we're going to reverse the list of everything\n// we pass in the meantime. That's going to be our tail in reverse\n// order.\nvar _tail=null;var row=workInProgress.child;workInProgress.child=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.\nif(currentRow!==null&&findFirstSuspended(currentRow)===null){// This is the beginning of the main content.\nworkInProgress.child=row;break;}var nextRow=row.sibling;row.sibling=_tail;_tail=row;row=nextRow;}// TODO: If workInProgress.child is null, we can continue on the tail immediately.\ninitSuspenseListRenderState(workInProgress,true,// isBackwards\n_tail,null,// last\ntailMode);break;}case'together':{initSuspenseListRenderState(workInProgress,false,// isBackwards\nnull,// tail\nnull,// last\nundefined);break;}default:{// The default reveal order is the same as not having\n// a boundary.\nworkInProgress.memoizedState=null;}}}return workInProgress.child;}function updatePortalComponent(current,workInProgress,renderLanes){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(current===null){// Portals are special because we don't append the children during mount\n// but at commit. Therefore we need to track insertions which the normal\n// flow doesn't do during mount. This doesn't happen at the root because\n// the root always starts with a \"current\" with a null child.\n// TODO: Consider unifying this with how the root works.\nworkInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}else{reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}var hasWarnedAboutUsingNoValuePropOnContextProvider=false;function updateContextProvider(current,workInProgress,renderLanes){var providerType=workInProgress.type;var context=providerType._context;var newProps=workInProgress.pendingProps;var oldProps=workInProgress.memoizedProps;var newValue=newProps.value;{if(!('value'in newProps)){if(!hasWarnedAboutUsingNoValuePropOnContextProvider){hasWarnedAboutUsingNoValuePropOnContextProvider=true;error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');}}var providerPropTypes=workInProgress.type.propTypes;if(providerPropTypes){checkPropTypes(providerPropTypes,newProps,'prop','Context.Provider');}}pushProvider(workInProgress,context,newValue);{if(oldProps!==null){var oldValue=oldProps.value;if(objectIs(oldValue,newValue)){// No change. Bailout early if children are the same.\nif(oldProps.children===newProps.children&&!hasContextChanged()){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}else{// The context value changed. Search for matching consumers and schedule\n// them to update.\npropagateContextChange(workInProgress,context,renderLanes);}}}var newChildren=newProps.children;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}var hasWarnedAboutUsingContextAsConsumer=false;function updateContextConsumer(current,workInProgress,renderLanes){var context=workInProgress.type;// The logic below for Context differs depending on PROD or DEV mode. In\n// DEV mode, we create a separate object for Context.Consumer that acts\n// like a proxy to Context. This proxy object adds unnecessary code in PROD\n// so we use the old behaviour (Context.Consumer references Context) to\n// reduce size and overhead. The separate object references context via\n// a property called \"_context\", which also gives us the ability to check\n// in DEV mode if this property exists or not and warn if it does not.\n{if(context._context===undefined){// This may be because it's a Context (rather than a Consumer).\n// Or it may be because it's older React where they're the same thing.\n// We only want to warn if we're sure it's a new React.\nif(context!==context.Consumer){if(!hasWarnedAboutUsingContextAsConsumer){hasWarnedAboutUsingContextAsConsumer=true;error('Rendering <Context> directly is not supported and will be removed in '+'a future major release. Did you mean to render <Context.Consumer> instead?');}}}else{context=context._context;}}var newProps=workInProgress.pendingProps;var render=newProps.children;{if(typeof render!=='function'){error('A context consumer was rendered with multiple children, or a child '+\"that isn't a function. A context consumer expects a single child \"+'that is a function. If you did pass a function, make sure there '+'is no trailing or leading whitespace around it.');}}prepareToReadContext(workInProgress,renderLanes);var newValue=_readContext(context);{markComponentRenderStarted(workInProgress);}var newChildren;{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);newChildren=render(newValue);setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.\nworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}function markWorkInProgressReceivedUpdate(){didReceiveUpdate=true;}function bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes){if(current!==null){// Reuse previous dependencies\nworkInProgress.dependencies=current.dependencies;}{// Don't update \"base\" render times for bailouts.\nstopProfilerTimerIfRunning();}markSkippedUpdateLanes(workInProgress.lanes);// Check if the children have any pending work.\nif(!includesSomeLane(renderLanes,workInProgress.childLanes)){// The children don't have any work either. We can skip them.\n// TODO: Once we add back resuming, we should check if the children are\n// a work-in-progress set. If so, we need to transfer their effects.\n{return null;}}// This fiber doesn't have work, but its subtree does. Clone the child\n// fibers and continue.\ncloneChildFibers(current,workInProgress);return workInProgress.child;}function remountFiber(current,oldWorkInProgress,newWorkInProgress){{var returnFiber=oldWorkInProgress[\"return\"];if(returnFiber===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Cannot swap the root fiber.');}// Disconnect from the old current.\n// It will get deleted.\ncurrent.alternate=null;oldWorkInProgress.alternate=null;// Connect to the new tree.\nnewWorkInProgress.index=oldWorkInProgress.index;newWorkInProgress.sibling=oldWorkInProgress.sibling;newWorkInProgress[\"return\"]=oldWorkInProgress[\"return\"];newWorkInProgress.ref=oldWorkInProgress.ref;// Replace the child/sibling pointers above it.\nif(oldWorkInProgress===returnFiber.child){returnFiber.child=newWorkInProgress;}else{var prevSibling=returnFiber.child;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Expected parent to have a child.');}while(prevSibling.sibling!==oldWorkInProgress){prevSibling=prevSibling.sibling;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes\nthrow new Error('Expected to find the previous sibling.');}}prevSibling.sibling=newWorkInProgress;}// Delete the old fiber and place the new one.\n// Since the old fiber is disconnected, we have to schedule it manually.\nvar deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[current];returnFiber.flags|=ChildDeletion;}else{deletions.push(current);}newWorkInProgress.flags|=Placement;// Restart work from the new fiber.\nreturn newWorkInProgress;}}function checkScheduledUpdateOrContext(current,renderLanes){// Before performing an early bailout, we must check if there are pending\n// updates or context.\nvar updateLanes=current.lanes;if(includesSomeLane(updateLanes,renderLanes)){return true;}// No pending update, but because context is propagated lazily, we need\nreturn false;}function attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes){// This fiber does not have any pending work. Bailout without entering\n// the begin phase. There's still some bookkeeping we that needs to be done\n// in this optimized path, mostly pushing stuff onto the stack.\nswitch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);var root=workInProgress.stateNode;resetHydrationState();break;case HostComponent:pushHostContext(workInProgress);break;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){pushContextProvider(workInProgress);}break;}case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;case ContextProvider:{var newValue=workInProgress.memoizedProps.value;var context=workInProgress.type._context;pushProvider(workInProgress,context,newValue);break;}case Profiler:{// Profiler should only call onRender when one of its descendants actually rendered.\nvar hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(hasChildWork){workInProgress.flags|=Update;}{// Reset effect durations for the next eventual effect phase.\n// These are reset during render to allow the DevTools commit hook a chance to read them,\nvar stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}break;case SuspenseComponent:{var state=workInProgress.memoizedState;if(state!==null){{if(state.dehydrated!==null){pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// We know that this component will suspend again because if it has\n// been unsuspended it has committed as a resolved Suspense component.\n// If it needs to be retried, it should have work scheduled on it.\nworkInProgress.flags|=DidCapture;// We should never render the children of a dehydrated boundary until we\n// upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\nreturn null;}}// If this boundary is currently timed out, we need to decide\n// whether to retry the primary children, or to skip over it and\n// go straight to the fallback. Check the priority of the primary\n// child fragment.\nvar primaryChildFragment=workInProgress.child;var primaryChildLanes=primaryChildFragment.childLanes;if(includesSomeLane(renderLanes,primaryChildLanes)){// The primary children have pending work. Use the normal path\n// to attempt to render the primary children again.\nreturn updateSuspenseComponent(current,workInProgress,renderLanes);}else{// The primary child fragment does not have pending work marked\n// on it\npushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// The primary children do not have pending work with sufficient\n// priority. Bailout.\nvar child=bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);if(child!==null){// The fallback children have pending work. Skip over the\n// primary children and work on the fallback.\nreturn child.sibling;}else{// Note: We can return `null` here because we already checked\n// whether there were nested context consumers, via the call to\n// `bailoutOnAlreadyFinishedWork` above.\nreturn null;}}}else{pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));}break;}case SuspenseListComponent:{var didSuspendBefore=(current.flags&DidCapture)!==NoFlags;var _hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(didSuspendBefore){if(_hasChildWork){// If something was in fallback state last time, and we have all the\n// same children then we're still in progressive loading state.\n// Something might get unblocked by state updates or retries in the\n// tree which will affect the tail. So we need to use the normal\n// path to compute the correct tail.\nreturn updateSuspenseListComponent(current,workInProgress,renderLanes);}// If none of the children had any work, that means that none of\n// them got retried so they'll still be blocked in the same way\n// as before. We can fast bail out.\nworkInProgress.flags|=DidCapture;}// If nothing suspended before and we're rendering the same children,\n// then the tail doesn't matter. Anything new that suspends will work\n// in the \"together\" mode, so we can continue from the state we had.\nvar renderState=workInProgress.memoizedState;if(renderState!==null){// Reset to the \"together\" mode in case we've started a different\n// update in the past but didn't complete it.\nrenderState.rendering=null;renderState.tail=null;renderState.lastEffect=null;}pushSuspenseContext(workInProgress,suspenseStackCursor.current);if(_hasChildWork){break;}else{// If none of the children had any work, that means that none of\n// them got retried so they'll still be blocked in the same way\n// as before. We can fast bail out.\nreturn null;}}case OffscreenComponent:case LegacyHiddenComponent:{// Need to check if the tree still needs to be deferred. This is\n// almost identical to the logic used in the normal update path,\n// so we'll just enter that. The only difference is we'll bail out\n// at the next level instead of this one, because the child props\n// have not changed. Which is fine.\n// TODO: Probably should refactor `beginWork` to split the bailout\n// path from the normal path. I'm tempted to do a labeled break here\n// but I won't :)\nworkInProgress.lanes=NoLanes;return updateOffscreenComponent(current,workInProgress,renderLanes);}}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}function beginWork(current,workInProgress,renderLanes){{if(workInProgress._debugNeedsRemount&&current!==null){// This will restart the begin phase with a new fiber.\nreturn remountFiber(current,workInProgress,createFiberFromTypeAndProps(workInProgress.type,workInProgress.key,workInProgress.pendingProps,workInProgress._debugOwner||null,workInProgress.mode,workInProgress.lanes));}}if(current!==null){var oldProps=current.memoizedProps;var newProps=workInProgress.pendingProps;if(oldProps!==newProps||hasContextChanged()||// Force a re-render if the implementation changed due to hot reload:\nworkInProgress.type!==current.type){// If props or context changed, mark the fiber as having performed work.\n// This may be unset if the props are determined to be equal later (memo).\ndidReceiveUpdate=true;}else{// Neither props nor legacy context changes. Check if there's a pending\n// update or context change.\nvar hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext&&// If this is the second pass of an error or suspense boundary, there\n// may not be work scheduled on `current`, so we check for this flag.\n(workInProgress.flags&DidCapture)===NoFlags){// No pending updates or context. Bail out now.\ndidReceiveUpdate=false;return attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes);}if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.\n// See https://github.com/facebook/react/pull/19216.\ndidReceiveUpdate=true;}else{// An update was scheduled on this fiber, but there are no new props\n// nor legacy context. Set this to false. If an update queue or context\n// consumer produces a changed value, it will set this to true. Otherwise,\n// the component will assume the children have not changed and bail out.\ndidReceiveUpdate=false;}}}else{didReceiveUpdate=false;if(getIsHydrating()&&isForkedChild(workInProgress)){// Check if this child belongs to a list of muliple children in\n// its parent.\n//\n// In a true multi-threaded implementation, we would render children on\n// parallel threads. This would represent the beginning of a new render\n// thread for this subtree.\n//\n// We only use this for id generation during hydration, which is why the\n// logic is located in this special branch.\nvar slotIndex=workInProgress.index;var numberOfForks=getForksAtLevel();pushTreeId(workInProgress,numberOfForks,slotIndex);}}// Before entering the begin phase, clear pending update priority.\n// TODO: This assumes that we're about to evaluate the component and process\n// the update queue. However, there's an exception: SimpleMemoComponent\n// sometimes bails out later in the begin phase. This indicates that we should\n// move this assignment out of the common path and into each branch.\nworkInProgress.lanes=NoLanes;switch(workInProgress.tag){case IndeterminateComponent:{return mountIndeterminateComponent(current,workInProgress,workInProgress.type,renderLanes);}case LazyComponent:{var elementType=workInProgress.elementType;return mountLazyComponent(current,workInProgress,elementType,renderLanes);}case FunctionComponent:{var Component=workInProgress.type;var unresolvedProps=workInProgress.pendingProps;var resolvedProps=workInProgress.elementType===Component?unresolvedProps:resolveDefaultProps(Component,unresolvedProps);return updateFunctionComponent(current,workInProgress,Component,resolvedProps,renderLanes);}case ClassComponent:{var _Component=workInProgress.type;var _unresolvedProps=workInProgress.pendingProps;var _resolvedProps=workInProgress.elementType===_Component?_unresolvedProps:resolveDefaultProps(_Component,_unresolvedProps);return updateClassComponent(current,workInProgress,_Component,_resolvedProps,renderLanes);}case HostRoot:return updateHostRoot(current,workInProgress,renderLanes);case HostComponent:return updateHostComponent$1(current,workInProgress,renderLanes);case HostText:return updateHostText$1(current,workInProgress);case SuspenseComponent:return updateSuspenseComponent(current,workInProgress,renderLanes);case HostPortal:return updatePortalComponent(current,workInProgress,renderLanes);case ForwardRef:{var type=workInProgress.type;var _unresolvedProps2=workInProgress.pendingProps;var _resolvedProps2=workInProgress.elementType===type?_unresolvedProps2:resolveDefaultProps(type,_unresolvedProps2);return updateForwardRef(current,workInProgress,type,_resolvedProps2,renderLanes);}case Fragment:return updateFragment(current,workInProgress,renderLanes);case Mode:return updateMode(current,workInProgress,renderLanes);case Profiler:return updateProfiler(current,workInProgress,renderLanes);case ContextProvider:return updateContextProvider(current,workInProgress,renderLanes);case ContextConsumer:return updateContextConsumer(current,workInProgress,renderLanes);case MemoComponent:{var _type2=workInProgress.type;var _unresolvedProps3=workInProgress.pendingProps;// Resolve outer props first, then resolve inner props.\nvar _resolvedProps3=resolveDefaultProps(_type2,_unresolvedProps3);{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=_type2.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,_resolvedProps3,// Resolved for outer only\n'prop',getComponentNameFromType(_type2));}}}_resolvedProps3=resolveDefaultProps(_type2.type,_resolvedProps3);return updateMemoComponent(current,workInProgress,_type2,_resolvedProps3,renderLanes);}case SimpleMemoComponent:{return updateSimpleMemoComponent(current,workInProgress,workInProgress.type,workInProgress.pendingProps,renderLanes);}case IncompleteClassComponent:{var _Component2=workInProgress.type;var _unresolvedProps4=workInProgress.pendingProps;var _resolvedProps4=workInProgress.elementType===_Component2?_unresolvedProps4:resolveDefaultProps(_Component2,_unresolvedProps4);return mountIncompleteClassComponent(current,workInProgress,_Component2,_resolvedProps4,renderLanes);}case SuspenseListComponent:{return updateSuspenseListComponent(current,workInProgress,renderLanes);}case ScopeComponent:{break;}case OffscreenComponent:{return updateOffscreenComponent(current,workInProgress,renderLanes);}}throw new Error(\"Unknown unit of work tag (\"+workInProgress.tag+\"). This error is likely caused by a bug in \"+'React. Please file an issue.');}function unwindWork(current,workInProgress,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(workInProgress);switch(workInProgress.tag){case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}var flags=workInProgress.flags;if(flags&ShouldCapture){workInProgress.flags=flags&~ShouldCapture|DidCapture;if((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case HostRoot:{popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();var _flags=workInProgress.flags;if((_flags&ShouldCapture)!==NoFlags&&(_flags&DidCapture)===NoFlags){// There was an error during render that wasn't captured by a suspense\n// boundary. Do a second pass on the root to unmount the children.\nworkInProgress.flags=_flags&~ShouldCapture|DidCapture;return workInProgress;}// We unwound to the root without completing it. Exit.\nreturn null;}case HostComponent:{// TODO: popHydrationState\npopHostContext(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);{var suspenseState=workInProgress.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){if(workInProgress.alternate===null){throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in '+'React. Please file an issue.');}resetHydrationState();}}var _flags2=workInProgress.flags;if(_flags2&ShouldCapture){workInProgress.flags=_flags2&~ShouldCapture|DidCapture;// Captured a suspense effect. Re-render the boundary.\nif((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);// SuspenseList doesn't actually catch anything. It should've been\n// caught by a nested boundary. If not, it should bubble through.\nreturn null;}case HostPortal:popHostContainer(workInProgress);return null;case ContextProvider:var context=workInProgress.type._context;popProvider(context,workInProgress);return null;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(workInProgress);return null;case CacheComponent:return null;default:return null;}}function unwindInterruptedWork(current,interruptedWork,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing\n// to the current tree provider fiber is just as fast and less error-prone.\n// Ideally we would have a special version of the work loop only\n// for hydration.\npopTreeContext(interruptedWork);switch(interruptedWork.tag){case ClassComponent:{var childContextTypes=interruptedWork.type.childContextTypes;if(childContextTypes!==null&&childContextTypes!==undefined){popContext(interruptedWork);}break;}case HostRoot:{popHostContainer(interruptedWork);popTopLevelContextObject(interruptedWork);resetWorkInProgressVersions();break;}case HostComponent:{popHostContext(interruptedWork);break;}case HostPortal:popHostContainer(interruptedWork);break;case SuspenseComponent:popSuspenseContext(interruptedWork);break;case SuspenseListComponent:popSuspenseContext(interruptedWork);break;case ContextProvider:var context=interruptedWork.type._context;popProvider(context,interruptedWork);break;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(interruptedWork);break;}}var didWarnAboutUndefinedSnapshotBeforeUpdate=null;{didWarnAboutUndefinedSnapshotBeforeUpdate=new Set();}// Used during the commit phase to track the state of the Offscreen component stack.\n// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n// Only used when enableSuspenseLayoutEffectSemantics is enabled.\nvar offscreenSubtreeIsHidden=false;var offscreenSubtreeWasHidden=false;var PossiblyWeakSet=typeof WeakSet==='function'?WeakSet:Set;var nextEffect=null;// Used for Profiling builds to track updaters.\nvar inProgressLanes=null;var inProgressRoot=null;function reportUncaughtErrorInDEV(error){// Wrapping each small part of the commit phase into a guarded\n// callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n// But we rely on it to surface errors to DEV tools like overlays\n// (https://github.com/facebook/react/issues/21712).\n// As a compromise, rethrow only caught errors in a guard.\n{invokeGuardedCallback(null,function(){throw error;});clearCaughtError();}}var callComponentWillUnmountWithTimer=function callComponentWillUnmountWithTimer(current,instance){instance.props=current.memoizedProps;instance.state=current.memoizedState;if(current.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentWillUnmount();}finally{recordLayoutEffectDuration(current);}}else{instance.componentWillUnmount();}};// Capture errors so they don't interrupt mounting.\nfunction safelyCallCommitHookLayoutEffectListMount(current,nearestMountedAncestor){try{commitHookEffectListMount(Layout,current);}catch(error){reportUncaughtErrorInDEV(error);captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt unmounting.\nfunction safelyCallComponentWillUnmount(current,nearestMountedAncestor,instance){try{callComponentWillUnmountWithTimer(current,instance);}catch(error){reportUncaughtErrorInDEV(error);captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.\nfunction safelyCallComponentDidMount(current,nearestMountedAncestor,instance){try{instance.componentDidMount();}catch(error){reportUncaughtErrorInDEV(error);captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.\nfunction safelyAttachRef(current,nearestMountedAncestor){try{commitAttachRef(current);}catch(error){reportUncaughtErrorInDEV(error);captureCommitPhaseError(current,nearestMountedAncestor,error);}}function safelyDetachRef(current,nearestMountedAncestor){var ref=current.ref;if(ref!==null){if(typeof ref==='function'){var retVal;try{if(enableProfilerTimer&&enableProfilerCommitHooks&&current.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(null);}finally{recordLayoutEffectDuration(current);}}else{retVal=ref(null);}}catch(error){reportUncaughtErrorInDEV(error);captureCommitPhaseError(current,nearestMountedAncestor,error);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(current));}}}else{ref.current=null;}}}function safelyCallDestroy(current,nearestMountedAncestor,destroy){try{destroy();}catch(error){reportUncaughtErrorInDEV(error);captureCommitPhaseError(current,nearestMountedAncestor,error);}}var focusedInstanceHandle=null;var shouldFireAfterActiveInstanceBlur=false;function commitBeforeMutationEffects(root,firstChild){focusedInstanceHandle=prepareForCommit(root.containerInfo);nextEffect=firstChild;commitBeforeMutationEffects_begin();// We no longer need to track the active instance fiber\nvar shouldFire=shouldFireAfterActiveInstanceBlur;shouldFireAfterActiveInstanceBlur=false;focusedInstanceHandle=null;return shouldFire;}function commitBeforeMutationEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;// This phase is only used for beforeActiveInstanceBlur.\nvar child=fiber.child;if((fiber.subtreeFlags&BeforeMutationMask)!==NoFlags&&child!==null){ensureCorrectReturnPointer(child,fiber);nextEffect=child;}else{commitBeforeMutationEffects_complete();}}}function commitBeforeMutationEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;setCurrentFiber(fiber);try{commitBeforeMutationEffectsOnFiber(fiber);}catch(error){reportUncaughtErrorInDEV(error);captureCommitPhaseError(fiber,fiber[\"return\"],error);}resetCurrentFiber();var sibling=fiber.sibling;if(sibling!==null){ensureCorrectReturnPointer(sibling,fiber[\"return\"]);nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function commitBeforeMutationEffectsOnFiber(finishedWork){var current=finishedWork.alternate;var flags=finishedWork.flags;if((flags&Snapshot)!==NoFlags){setCurrentFiber(finishedWork);switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{break;}case ClassComponent:{if(current!==null){var prevProps=current.memoizedProps;var prevState=current.memoizedState;var instance=finishedWork.stateNode;// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}var snapshot=instance.getSnapshotBeforeUpdate(finishedWork.elementType===finishedWork.type?prevProps:resolveDefaultProps(finishedWork.type,prevProps),prevState);{var didWarnSet=didWarnAboutUndefinedSnapshotBeforeUpdate;if(snapshot===undefined&&!didWarnSet.has(finishedWork.type)){didWarnSet.add(finishedWork.type);error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) '+'must be returned. You have returned undefined.',getComponentNameFromFiber(finishedWork));}}instance.__reactInternalSnapshotBeforeUpdate=snapshot;}break;}case HostRoot:{{var root=finishedWork.stateNode;clearContainer(root.containerInfo);}break;}case HostComponent:case HostText:case HostPortal:case IncompleteClassComponent:// Nothing to do for these component types\nbreak;default:{throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}resetCurrentFiber();}}function commitHookEffectListUnmount(flags,finishedWork,nearestMountedAncestor){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){// Unmount\nvar destroy=effect.destroy;effect.destroy=undefined;if(destroy!==undefined){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStarted(finishedWork);}}safelyCallDestroy(finishedWork,nearestMountedAncestor,destroy);{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStopped();}}}}effect=effect.next;}while(effect!==firstEffect);}}function commitHookEffectListMount(flags,finishedWork){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStarted(finishedWork);}}// Mount\nvar create=effect.create;effect.destroy=create();{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStopped();}}{var destroy=effect.destroy;if(destroy!==undefined&&typeof destroy!=='function'){var hookName=void 0;if((effect.tag&Layout)!==NoFlags){hookName='useLayoutEffect';}else if((effect.tag&Insertion)!==NoFlags){hookName='useInsertionEffect';}else{hookName='useEffect';}var addendum=void 0;if(destroy===null){addendum=' You returned null. If your effect does not require clean '+'up, return undefined (or nothing).';}else if(typeof destroy.then==='function'){addendum='\\n\\nIt looks like you wrote '+hookName+'(async () => ...) or returned a Promise. '+'Instead, write the async function inside your effect '+'and call it immediately:\\n\\n'+hookName+'(() => {\\n'+'  async function fetchData() {\\n'+'    // You can await here\\n'+'    const response = await MyAPI.getData(someId);\\n'+'    // ...\\n'+'  }\\n'+'  fetchData();\\n'+\"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\"+'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';}else{addendum=' You returned: '+destroy;}error('%s must not return anything besides a function, '+'which is used for clean-up.%s',hookName,addendum);}}}effect=effect.next;}while(effect!==firstEffect);}}function commitPassiveEffectDurations(finishedRoot,finishedWork){{// Only Profilers with work in their subtree will have an Update effect scheduled.\nif((finishedWork.flags&Update)!==NoFlags){switch(finishedWork.tag){case Profiler:{var passiveEffectDuration=finishedWork.stateNode.passiveEffectDuration;var _finishedWork$memoize=finishedWork.memoizedProps,id=_finishedWork$memoize.id,onPostCommit=_finishedWork$memoize.onPostCommit;// This value will still reflect the previous commit phase.\n// It does not get reset until the start of the next commit phase.\nvar commitTime=getCommitTime();var phase=finishedWork.alternate===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onPostCommit==='function'){onPostCommit(id,phase,passiveEffectDuration,commitTime);}// Bubble times to the next nearest ancestor Profiler.\n// After we process that Profiler, we'll bubble further up.\nvar parentFiber=finishedWork[\"return\"];outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.passiveEffectDuration+=passiveEffectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.passiveEffectDuration+=passiveEffectDuration;break outer;}parentFiber=parentFiber[\"return\"];}break;}}}}}function commitLayoutEffectOnFiber(finishedRoot,current,finishedWork,committedLanes){if((finishedWork.flags&LayoutMask)!==NoFlags){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){// At this point layout effects have already been destroyed (during mutation phase).\n// This is done to prevent sibling component effects from interfering with each other,\n// e.g. a destroy function in one component should never override a ref set\n// by a create function in another component during the same commit.\nif(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListMount(Layout|HasEffect,finishedWork);}finally{recordLayoutEffectDuration(finishedWork);}}else{commitHookEffectListMount(Layout|HasEffect,finishedWork);}}break;}case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.flags&Update){if(!offscreenSubtreeWasHidden){if(current===null){// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidMount();}finally{recordLayoutEffectDuration(finishedWork);}}else{instance.componentDidMount();}}else{var prevProps=finishedWork.elementType===finishedWork.type?current.memoizedProps:resolveDefaultProps(finishedWork.type,current.memoizedProps);var prevState=current.memoizedState;// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\n{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}finally{recordLayoutEffectDuration(finishedWork);}}else{instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}}}}// TODO: I think this is now always non-null by the time it reaches the\n// commit phase. Consider removing the type check.\nvar updateQueue=finishedWork.updateQueue;if(updateQueue!==null){{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}// We could update instance props and state here,\n// but instead we rely on them being set during last render.\n// TODO: revisit this when we implement resuming.\ncommitUpdateQueue(finishedWork,updateQueue,instance);}break;}case HostRoot:{// TODO: I think this is now always non-null by the time it reaches the\n// commit phase. Consider removing the type check.\nvar _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=null;if(finishedWork.child!==null){switch(finishedWork.child.tag){case HostComponent:_instance=getPublicInstance(finishedWork.child.stateNode);break;case ClassComponent:_instance=finishedWork.child.stateNode;break;}}commitUpdateQueue(finishedWork,_updateQueue,_instance);}break;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted\n// (eg DOM renderer may schedule auto-focus for inputs and form controls).\n// These effects should only be committed when components are first mounted,\n// aka when there is no current/alternate.\nif(current===null&&finishedWork.flags&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props);}break;}case HostText:{// We have no life-cycles associated with text.\nbreak;}case HostPortal:{// We have no life-cycles associated with portals.\nbreak;}case Profiler:{{var _finishedWork$memoize2=finishedWork.memoizedProps,onCommit=_finishedWork$memoize2.onCommit,onRender=_finishedWork$memoize2.onRender;var effectDuration=finishedWork.stateNode.effectDuration;var commitTime=getCommitTime();var phase=current===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onRender==='function'){onRender(finishedWork.memoizedProps.id,phase,finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,commitTime);}{if(typeof onCommit==='function'){onCommit(finishedWork.memoizedProps.id,phase,effectDuration,commitTime);}// Schedule a passive effect for this Profiler to call onPostCommit hooks.\n// This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n// because the effect is also where times bubble to parent Profilers.\nenqueuePendingPassiveProfilerEffect(finishedWork);// Propagate layout effect durations to the next nearest Profiler ancestor.\n// Do not reset these values until the next render so DevTools has a chance to read them first.\nvar parentFiber=finishedWork[\"return\"];outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=effectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=effectDuration;break outer;}parentFiber=parentFiber[\"return\"];}}}break;}case SuspenseComponent:{commitSuspenseHydrationCallbacks(finishedRoot,finishedWork);break;}case SuspenseListComponent:case IncompleteClassComponent:case ScopeComponent:case OffscreenComponent:case LegacyHiddenComponent:{break;}default:throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}if(!offscreenSubtreeWasHidden){{if(finishedWork.flags&Ref){commitAttachRef(finishedWork);}}}}function reappearLayoutEffectsOnFiber(node){// Turn on layout effects in a tree that previously disappeared.\n// TODO (Offscreen) Check: flags & LayoutStatic\nswitch(node.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(node.mode&ProfileMode){try{startLayoutEffectTimer();safelyCallCommitHookLayoutEffectListMount(node,node[\"return\"]);}finally{recordLayoutEffectDuration(node);}}else{safelyCallCommitHookLayoutEffectListMount(node,node[\"return\"]);}break;}case ClassComponent:{var instance=node.stateNode;if(typeof instance.componentDidMount==='function'){safelyCallComponentDidMount(node,node[\"return\"],instance);}safelyAttachRef(node,node[\"return\"]);break;}case HostComponent:{safelyAttachRef(node,node[\"return\"]);break;}}}function hideOrUnhideAllChildren(finishedWork,isHidden){// Only hide or unhide the top-most host nodes.\nvar hostSubtreeRoot=null;{// We only have the top Fiber that was inserted but we need to recurse down its\n// children to find all the terminal nodes.\nvar node=finishedWork;while(true){if(node.tag===HostComponent){if(hostSubtreeRoot===null){hostSubtreeRoot=node;var instance=node.stateNode;if(isHidden){hideInstance(instance);}else{unhideInstance(node.stateNode,node.memoizedProps);}}}else if(node.tag===HostText){if(hostSubtreeRoot===null){var _instance3=node.stateNode;if(isHidden){hideTextInstance(_instance3);}else{unhideTextInstance(_instance3,node.memoizedProps);}}}else if((node.tag===OffscreenComponent||node.tag===LegacyHiddenComponent)&&node.memoizedState!==null&&node!==finishedWork);else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===finishedWork){return;}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node=node[\"return\"];}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;var instanceToUse;switch(finishedWork.tag){case HostComponent:instanceToUse=getPublicInstance(instance);break;default:instanceToUse=instance;}// Moved outside to ensure DCE works with this flag\nif(typeof ref==='function'){var retVal;if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(instanceToUse);}finally{recordLayoutEffectDuration(finishedWork);}}else{retVal=ref(instanceToUse);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(finishedWork));}}}else{{if(!ref.hasOwnProperty('current')){error('Unexpected ref object provided for %s. '+'Use either a ref-setter function or React.createRef().',getComponentNameFromFiber(finishedWork));}}ref.current=instanceToUse;}}}function commitDetachRef(current){var currentRef=current.ref;if(currentRef!==null){if(typeof currentRef==='function'){if(current.mode&ProfileMode){try{startLayoutEffectTimer();currentRef(null);}finally{recordLayoutEffectDuration(current);}}else{currentRef(null);}}else{currentRef.current=null;}}}// User-originating errors (lifecycles and refs) should not interrupt\n// deletion, so don't let them throw. Host-originating errors should\n// interrupt deletion, so it's okay\nfunction commitUnmount(finishedRoot,current,nearestMountedAncestor){onCommitUnmount(current);switch(current.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{var updateQueue=current.updateQueue;if(updateQueue!==null){var lastEffect=updateQueue.lastEffect;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{var _effect=effect,destroy=_effect.destroy,tag=_effect.tag;if(destroy!==undefined){if((tag&Insertion)!==NoFlags$1){safelyCallDestroy(current,nearestMountedAncestor,destroy);}else if((tag&Layout)!==NoFlags$1){{markComponentLayoutEffectUnmountStarted(current);}if(current.mode&ProfileMode){startLayoutEffectTimer();safelyCallDestroy(current,nearestMountedAncestor,destroy);recordLayoutEffectDuration(current);}else{safelyCallDestroy(current,nearestMountedAncestor,destroy);}{markComponentLayoutEffectUnmountStopped();}}}effect=effect.next;}while(effect!==firstEffect);}}return;}case ClassComponent:{safelyDetachRef(current,nearestMountedAncestor);var instance=current.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(current,nearestMountedAncestor,instance);}return;}case HostComponent:{safelyDetachRef(current,nearestMountedAncestor);return;}case HostPortal:{// TODO: this is recursive.\n// We are also not using this parent because\n// the portal will get pushed immediately.\n{unmountHostComponents(finishedRoot,current,nearestMountedAncestor);}return;}case DehydratedFragment:{return;}case ScopeComponent:{return;}}}function commitNestedUnmounts(finishedRoot,root,nearestMountedAncestor){// While we're inside a removed host node we don't want to call\n// removeChild on the inner nodes because they're removed by the top\n// call anyway. We also want to call componentWillUnmount on all\n// composites before this host node is removed from the tree. Therefore\n// we do an inner loop while we're still inside the host node.\nvar node=root;while(true){commitUnmount(finishedRoot,node,nearestMountedAncestor);// Visit children because they may contain more composite or host nodes.\n// Skip portals because commitUnmount() currently visits them recursively.\nif(node.child!==null&&// If we use mutation we drill down into portals using commitUnmount above.\n// If we don't use mutation we drill down into portals here instead.\nnode.tag!==HostPortal){node.child[\"return\"]=node;node=node.child;continue;}if(node===root){return;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===root){return;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}}function detachFiberMutation(fiber){// Cut off the return pointer to disconnect it from the tree.\n// This enables us to detect and warn against state updates on an unmounted component.\n// It also prevents events from bubbling from within disconnected components.\n//\n// Ideally, we should also clear the child pointer of the parent alternate to let this\n// get GC:ed but we don't know which for sure which parent is the current\n// one so we'll settle for GC:ing the subtree of this child.\n// This child itself will be GC:ed when the parent updates the next time.\n//\n// Note that we can't clear child or sibling pointers yet.\n// They're needed for passive effects and for findDOMNode.\n// We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n//\n// Don't reset the alternate yet, either. We need that so we can detach the\n// alternate's fields in the passive phase. Clearing the return pointer is\n// sufficient for findDOMNode semantics.\nvar alternate=fiber.alternate;if(alternate!==null){alternate[\"return\"]=null;}fiber[\"return\"]=null;}function detachFiberAfterEffects(fiber){var alternate=fiber.alternate;if(alternate!==null){fiber.alternate=null;detachFiberAfterEffects(alternate);}// Note: Defensively using negation instead of < in case\n// `deletedTreeCleanUpLevel` is undefined.\n{// Clear cyclical Fiber fields. This level alone is designed to roughly\n// approximate the planned Fiber refactor. In that world, `setState` will be\n// bound to a special \"instance\" object instead of a Fiber. The Instance\n// object will not have any of these fields. It will only be connected to\n// the fiber tree via a single link at the root. So if this level alone is\n// sufficient to fix memory issues, that bodes well for our plans.\nfiber.child=null;fiber.deletions=null;fiber.sibling=null;// The `stateNode` is cyclical because on host nodes it points to the host\n// tree, which has its own pointers to children, parents, and siblings.\n// The other host nodes also point back to fibers, so we should detach that\n// one, too.\nif(fiber.tag===HostComponent){var hostInstance=fiber.stateNode;if(hostInstance!==null){detachDeletedInstance(hostInstance);}}fiber.stateNode=null;// I'm intentionally not clearing the `return` field in this level. We\n// already disconnect the `return` pointer at the root of the deleted\n// subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n// cyclical — it's only cyclical when combined with `child`, `sibling`, and\n// `alternate`. But we'll clear it in the next level anyway, just in case.\n{fiber._debugOwner=null;}{// Theoretically, nothing in here should be necessary, because we already\n// disconnected the fiber from the tree. So even if something leaks this\n// particular fiber, it won't leak anything else\n//\n// The purpose of this branch is to be super aggressive so we can measure\n// if there's any difference in memory impact. If there is, that could\n// indicate a React leak we don't know about.\nfiber[\"return\"]=null;fiber.dependencies=null;fiber.memoizedProps=null;fiber.memoizedState=null;fiber.pendingProps=null;fiber.stateNode=null;// TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\nfiber.updateQueue=null;}}}function getHostParentFiber(fiber){var parent=fiber[\"return\"];while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent[\"return\"];}throw new Error('Expected to find a host parent. This error is likely caused by a bug '+'in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host\n// node. Unfortunately, if multiple insertions are done in a row we have to\n// search past them. This leads to exponential search for the next sibling.\n// TODO: Find a more efficient way to do this.\nvar node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.\nwhile(node.sibling===null){if(node[\"return\"]===null||isHostParent(node[\"return\"])){// If we pop out of the root or hit the parent the fiber we are the\n// last sibling.\nreturn null;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText&&node.tag!==DehydratedFragment){// If it is not host node and, we might have a host node inside it.\n// Try to search down until we find one.\nif(node.flags&Placement){// If we don't have a child, try the siblings instead.\ncontinue siblings;}// If we don't have a child, try the siblings instead.\n// We also skip portals because they are not part of this host tree.\nif(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child[\"return\"]=node;node=node.child;}}// Check if this host node is stable or about to be placed.\nif(!(node.flags&Placement)){// Found it!\nreturn node.stateNode;}}}function commitPlacement(finishedWork){var parentFiber=getHostParentFiber(finishedWork);// Note: these two variables *must* always be updated together.\nswitch(parentFiber.tag){case HostComponent:{var parent=parentFiber.stateNode;if(parentFiber.flags&ContentReset){// Reset the text content of the parent before doing any insertions\nresetTextContent(parent);// Clear ContentReset from the effect tag\nparentFiber.flags&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need to recurse down its\n// children to find all the terminal nodes.\ninsertOrAppendPlacementNode(finishedWork,before,parent);break;}case HostRoot:case HostPortal:{var _parent=parentFiber.stateNode.containerInfo;var _before=getHostSibling(finishedWork);insertOrAppendPlacementNodeIntoContainer(finishedWork,_before,_parent);break;}// eslint-disable-next-line-no-fallthrough\ndefault:throw new Error('Invalid host parent fiber. This error is likely caused by a bug '+'in React. Please file an issue.');}}function insertOrAppendPlacementNodeIntoContainer(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertInContainerBefore(parent,stateNode,before);}else{appendChildToContainer(parent,stateNode);}}else if(tag===HostPortal);else{var child=node.child;if(child!==null){insertOrAppendPlacementNodeIntoContainer(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNodeIntoContainer(sibling,before,parent);sibling=sibling.sibling;}}}}function insertOrAppendPlacementNode(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertBefore(parent,stateNode,before);}else{appendChild(parent,stateNode);}}else if(tag===HostPortal);else{var child=node.child;if(child!==null){insertOrAppendPlacementNode(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNode(sibling,before,parent);sibling=sibling.sibling;}}}}function unmountHostComponents(finishedRoot,current,nearestMountedAncestor){// We only have the top Fiber that was deleted but we need to recurse down its\n// children to find all the terminal nodes.\nvar node=current;// Each iteration, currentParent is populated with node's host parent if not\n// currentParentIsValid.\nvar currentParentIsValid=false;// Note: these two variables *must* always be updated together.\nvar currentParent;var currentParentIsContainer;while(true){if(!currentParentIsValid){var parent=node[\"return\"];findParent:while(true){if(parent===null){throw new Error('Expected to find a host parent. This error is likely caused by '+'a bug in React. Please file an issue.');}var parentStateNode=parent.stateNode;switch(parent.tag){case HostComponent:currentParent=parentStateNode;currentParentIsContainer=false;break findParent;case HostRoot:currentParent=parentStateNode.containerInfo;currentParentIsContainer=true;break findParent;case HostPortal:currentParent=parentStateNode.containerInfo;currentParentIsContainer=true;break findParent;}parent=parent[\"return\"];}currentParentIsValid=true;}if(node.tag===HostComponent||node.tag===HostText){commitNestedUnmounts(finishedRoot,node,nearestMountedAncestor);// After all the children have unmounted, it is now safe to remove the\n// node from the tree.\nif(currentParentIsContainer){removeChildFromContainer(currentParent,node.stateNode);}else{removeChild(currentParent,node.stateNode);}// Don't visit children because we already visited them.\n}else if(node.tag===DehydratedFragment){if(currentParentIsContainer){clearSuspenseBoundaryFromContainer(currentParent,node.stateNode);}else{clearSuspenseBoundary(currentParent,node.stateNode);}}else if(node.tag===HostPortal){if(node.child!==null){// When we go into a portal, it becomes the parent to remove from.\n// We will reassign it back when we pop the portal on the way up.\ncurrentParent=node.stateNode.containerInfo;currentParentIsContainer=true;// Visit children because portals might contain host components.\nnode.child[\"return\"]=node;node=node.child;continue;}}else{commitUnmount(finishedRoot,node,nearestMountedAncestor);// Visit children because we may find more host components below.\nif(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}}if(node===current){return;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===current){return;}node=node[\"return\"];if(node.tag===HostPortal){// When we go out of the portal, we need to restore the parent.\n// Since we don't keep a stack of them, we will search for it.\ncurrentParentIsValid=false;}}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}}function commitDeletion(finishedRoot,current,nearestMountedAncestor){{// Recursively delete all host nodes from the parent.\n// Detach refs and call componentWillUnmount() on the whole subtree.\nunmountHostComponents(finishedRoot,current,nearestMountedAncestor);}detachFiberMutation(current);}function commitWork(current,finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{commitHookEffectListUnmount(Insertion|HasEffect,finishedWork,finishedWork[\"return\"]);commitHookEffectListMount(Insertion|HasEffect,finishedWork);// Layout effects are destroyed during the mutation phase so that all\n// destroy functions for all fibers are called before any create functions.\n// This prevents sibling component effects from interfering with each other,\n// e.g. a destroy function in one component should never override a ref set\n// by a create function in another component during the same commit.\nif(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork[\"return\"]);}finally{recordLayoutEffectDuration(finishedWork);}}else{commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork[\"return\"]);}return;}case ClassComponent:{return;}case HostComponent:{var instance=finishedWork.stateNode;if(instance!=null){// Commit the work prepared earlier.\nvar newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps\n// as the newProps. The updatePayload will contain the real change in\n// this case.\nvar oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.\nvar updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){commitUpdate(instance,updatePayload,type,oldProps,newProps);}}return;}case HostText:{if(finishedWork.stateNode===null){throw new Error('This should have a text node initialized. This error is likely '+'caused by a bug in React. Please file an issue.');}var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps\n// as the newProps. The updatePayload will contain the real change in\n// this case.\nvar oldText=current!==null?current.memoizedProps:newText;commitTextUpdate(textInstance,oldText,newText);return;}case HostRoot:{{if(current!==null){var _prevRootState=current.memoizedState;if(_prevRootState.isDehydrated){var _root=finishedWork.stateNode;commitHydratedContainer(_root.containerInfo);}}}return;}case Profiler:{return;}case SuspenseComponent:{commitSuspenseCallback(finishedWork);attachSuspenseRetryListeners(finishedWork);return;}case SuspenseListComponent:{attachSuspenseRetryListeners(finishedWork);return;}case IncompleteClassComponent:{return;}}throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}function commitSuspenseCallback(finishedWork){// TODO: Move this to passive phase\nvar newState=finishedWork.memoizedState;}function commitSuspenseHydrationCallbacks(finishedRoot,finishedWork){var newState=finishedWork.memoizedState;if(newState===null){var current=finishedWork.alternate;if(current!==null){var prevState=current.memoizedState;if(prevState!==null){var suspenseInstance=prevState.dehydrated;if(suspenseInstance!==null){commitHydratedSuspenseInstance(suspenseInstance);}}}}}function attachSuspenseRetryListeners(finishedWork){// If this boundary just timed out, then it will have a set of wakeables.\n// For each wakeable, attach a listener so that when it resolves, React\n// attempts to re-render the boundary in the primary (pre-timeout) state.\nvar wakeables=finishedWork.updateQueue;if(wakeables!==null){finishedWork.updateQueue=null;var retryCache=finishedWork.stateNode;if(retryCache===null){retryCache=finishedWork.stateNode=new PossiblyWeakSet();}wakeables.forEach(function(wakeable){// Memoize using the boundary fiber to prevent redundant listeners.\nvar retry=resolveRetryWakeable.bind(null,finishedWork,wakeable);if(!retryCache.has(wakeable)){retryCache.add(wakeable);{if(isDevToolsPresent){if(inProgressLanes!==null&&inProgressRoot!==null){// If we have pending work still, associate the original updaters with it.\nrestorePendingUpdaters(inProgressRoot,inProgressLanes);}else{throw Error('Expected finished root and lanes to be set. This is a bug in React.');}}}wakeable.then(retry,retry);}});}}// This function detects when a Suspense boundary goes from visible to hidden.\nfunction commitResetTextContent(current){resetTextContent(current.stateNode);}function commitMutationEffects(root,firstChild,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;nextEffect=firstChild;commitMutationEffects_begin(root,committedLanes);inProgressLanes=null;inProgressRoot=null;}function commitMutationEffects_begin(root,lanes){while(nextEffect!==null){var fiber=nextEffect;// TODO: Should wrap this in flags check, too, as optimization\nvar deletions=fiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var childToDelete=deletions[i];try{commitDeletion(root,childToDelete,fiber);}catch(error){reportUncaughtErrorInDEV(error);captureCommitPhaseError(childToDelete,fiber,error);}}}var child=fiber.child;if((fiber.subtreeFlags&MutationMask)!==NoFlags&&child!==null){ensureCorrectReturnPointer(child,fiber);nextEffect=child;}else{commitMutationEffects_complete(root,lanes);}}}function commitMutationEffects_complete(root,lanes){while(nextEffect!==null){var fiber=nextEffect;setCurrentFiber(fiber);try{commitMutationEffectsOnFiber(fiber,root,lanes);}catch(error){reportUncaughtErrorInDEV(error);captureCommitPhaseError(fiber,fiber[\"return\"],error);}resetCurrentFiber();var sibling=fiber.sibling;if(sibling!==null){ensureCorrectReturnPointer(sibling,fiber[\"return\"]);nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function commitMutationEffectsOnFiber(finishedWork,root,lanes){// TODO: The factoring of this phase could probably be improved. Consider\n// switching on the type of work before checking the flags. That's what\n// we do in all the other phases. I think this one is only different\n// because of the shared reconciliation logic below.\nvar flags=finishedWork.flags;if(flags&ContentReset){commitResetTextContent(finishedWork);}if(flags&Ref){var current=finishedWork.alternate;if(current!==null){commitDetachRef(current);}}if(flags&Visibility){switch(finishedWork.tag){case SuspenseComponent:{var newState=finishedWork.memoizedState;var isHidden=newState!==null;if(isHidden){var _current=finishedWork.alternate;var wasHidden=_current!==null&&_current.memoizedState!==null;if(!wasHidden){// TODO: Move to passive phase\nmarkCommitTimeOfFallback();}}break;}case OffscreenComponent:{var _newState=finishedWork.memoizedState;var _isHidden=_newState!==null;var _current2=finishedWork.alternate;var _wasHidden=_current2!==null&&_current2.memoizedState!==null;var offscreenBoundary=finishedWork;{// TODO: This needs to run whenever there's an insertion or update\n// inside a hidden Offscreen tree.\nhideOrUnhideAllChildren(offscreenBoundary,_isHidden);}{if(_isHidden){if(!_wasHidden){if((offscreenBoundary.mode&ConcurrentMode)!==NoMode){nextEffect=offscreenBoundary;var offscreenChild=offscreenBoundary.child;while(offscreenChild!==null){nextEffect=offscreenChild;disappearLayoutEffects_begin(offscreenChild);offscreenChild=offscreenChild.sibling;}}}}break;}}}}// The following switch statement is only concerned about placement,\n// updates, and deletions. To avoid needing to add a case for every possible\n// bitmap value, we remove the secondary effects from the effect tag and\n// switch on that value.\nvar primaryFlags=flags&(Placement|Update|Hydrating);switch(primaryFlags){case Placement:{commitPlacement(finishedWork);// Clear the \"placement\" from effect tag so that we know that this is\n// inserted, before any life-cycles like componentDidMount gets called.\n// TODO: findDOMNode doesn't rely on this any more but isMounted does\n// and isMounted is deprecated anyway so we should be able to kill this.\nfinishedWork.flags&=~Placement;break;}case PlacementAndUpdate:{// Placement\ncommitPlacement(finishedWork);// Clear the \"placement\" from effect tag so that we know that this is\n// inserted, before any life-cycles like componentDidMount gets called.\nfinishedWork.flags&=~Placement;// Update\nvar _current3=finishedWork.alternate;commitWork(_current3,finishedWork);break;}case Hydrating:{finishedWork.flags&=~Hydrating;break;}case HydratingAndUpdate:{finishedWork.flags&=~Hydrating;// Update\nvar _current4=finishedWork.alternate;commitWork(_current4,finishedWork);break;}case Update:{var _current5=finishedWork.alternate;commitWork(_current5,finishedWork);break;}}}function commitLayoutEffects(finishedWork,root,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;nextEffect=finishedWork;commitLayoutEffects_begin(finishedWork,root,committedLanes);inProgressLanes=null;inProgressRoot=null;}function commitLayoutEffects_begin(subtreeRoot,root,committedLanes){// Suspense layout effects semantics don't change for legacy roots.\nvar isModernRoot=(subtreeRoot.mode&ConcurrentMode)!==NoMode;while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent&&isModernRoot){// Keep track of the current Offscreen stack's state.\nvar isHidden=fiber.memoizedState!==null;var newOffscreenSubtreeIsHidden=isHidden||offscreenSubtreeIsHidden;if(newOffscreenSubtreeIsHidden){// The Offscreen tree is hidden. Skip over its layout effects.\ncommitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}else{// TODO (Offscreen) Also check: subtreeFlags & LayoutMask\nvar current=fiber.alternate;var wasHidden=current!==null&&current.memoizedState!==null;var newOffscreenSubtreeWasHidden=wasHidden||offscreenSubtreeWasHidden;var prevOffscreenSubtreeIsHidden=offscreenSubtreeIsHidden;var prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;// Traverse the Offscreen subtree with the current Offscreen as the root.\noffscreenSubtreeIsHidden=newOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=newOffscreenSubtreeWasHidden;if(offscreenSubtreeWasHidden&&!prevOffscreenSubtreeWasHidden){// This is the root of a reappearing boundary. Turn its layout effects\n// back on.\nnextEffect=fiber;reappearLayoutEffects_begin(fiber);}var child=firstChild;while(child!==null){nextEffect=child;commitLayoutEffects_begin(child,// New root; bubble back up to here and stop.\nroot,committedLanes);child=child.sibling;}// Restore Offscreen state and resume in our-progress traversal.\nnextEffect=fiber;offscreenSubtreeIsHidden=prevOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}}if((fiber.subtreeFlags&LayoutMask)!==NoFlags&&firstChild!==null){ensureCorrectReturnPointer(firstChild,fiber);nextEffect=firstChild;}else{commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);}}}function commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&LayoutMask)!==NoFlags){var current=fiber.alternate;setCurrentFiber(fiber);try{commitLayoutEffectOnFiber(root,current,fiber,committedLanes);}catch(error){reportUncaughtErrorInDEV(error);captureCommitPhaseError(fiber,fiber[\"return\"],error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){ensureCorrectReturnPointer(sibling,fiber[\"return\"]);nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function disappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;// TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(fiber.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout,fiber,fiber[\"return\"]);}finally{recordLayoutEffectDuration(fiber);}}else{commitHookEffectListUnmount(Layout,fiber,fiber[\"return\"]);}break;}case ClassComponent:{// TODO (Offscreen) Check: flags & RefStatic\nsafelyDetachRef(fiber,fiber[\"return\"]);var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber[\"return\"],instance);}break;}case HostComponent:{safelyDetachRef(fiber,fiber[\"return\"]);break;}case OffscreenComponent:{// Check if this is a\nvar isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is already hidden. Don't disappear\n// its effects.\ndisappearLayoutEffects_complete(subtreeRoot);continue;}break;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic\nif(firstChild!==null){firstChild[\"return\"]=fiber;nextEffect=firstChild;}else{disappearLayoutEffects_complete(subtreeRoot);}}}function disappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function reappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent){var isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is still hidden. Don't re-appear its effects.\nreappearLayoutEffects_complete(subtreeRoot);continue;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic\nif(firstChild!==null){// This node may have been reused from a previous render, so we can't\n// assume its return pointer is correct.\nfirstChild[\"return\"]=fiber;nextEffect=firstChild;}else{reappearLayoutEffects_complete(subtreeRoot);}}}function reappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;// TODO (Offscreen) Check: flags & LayoutStatic\nsetCurrentFiber(fiber);try{reappearLayoutEffectsOnFiber(fiber);}catch(error){reportUncaughtErrorInDEV(error);captureCommitPhaseError(fiber,fiber[\"return\"],error);}resetCurrentFiber();if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){// This node may have been reused from a previous render, so we can't\n// assume its return pointer is correct.\nsibling[\"return\"]=fiber[\"return\"];nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function commitPassiveMountEffects(root,finishedWork){nextEffect=finishedWork;commitPassiveMountEffects_begin(finishedWork,root);}function commitPassiveMountEffects_begin(subtreeRoot,root){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&firstChild!==null){ensureCorrectReturnPointer(firstChild,fiber);nextEffect=firstChild;}else{commitPassiveMountEffects_complete(subtreeRoot,root);}}}function commitPassiveMountEffects_complete(subtreeRoot,root){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);try{commitPassiveMountOnFiber(root,fiber);}catch(error){reportUncaughtErrorInDEV(error);captureCommitPhaseError(fiber,fiber[\"return\"],error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){ensureCorrectReturnPointer(sibling,fiber[\"return\"]);nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function commitPassiveMountOnFiber(finishedRoot,finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();try{commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}finally{recordPassiveEffectDuration(finishedWork);}}else{commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}break;}}}function commitPassiveUnmountEffects(firstChild){nextEffect=firstChild;commitPassiveUnmountEffects_begin();}function commitPassiveUnmountEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;var child=fiber.child;if((nextEffect.flags&ChildDeletion)!==NoFlags){var deletions=fiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var fiberToDelete=deletions[i];nextEffect=fiberToDelete;commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete,fiber);}{// A fiber was deleted from this parent fiber, but it's still part of\n// the previous (alternate) parent fiber's list of children. Because\n// children are a linked list, an earlier sibling that's still alive\n// will be connected to the deleted fiber via its `alternate`:\n//\n//   live fiber\n//   --alternate--> previous live fiber\n//   --sibling--> deleted fiber\n//\n// We can't disconnect `alternate` on nodes that haven't been deleted\n// yet, but we can disconnect the `sibling` and `child` pointers.\nvar previousFiber=fiber.alternate;if(previousFiber!==null){var detachedChild=previousFiber.child;if(detachedChild!==null){previousFiber.child=null;do{var detachedSibling=detachedChild.sibling;detachedChild.sibling=null;detachedChild=detachedSibling;}while(detachedChild!==null);}}}nextEffect=fiber;}}if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&child!==null){ensureCorrectReturnPointer(child,fiber);nextEffect=child;}else{commitPassiveUnmountEffects_complete();}}}function commitPassiveUnmountEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);commitPassiveUnmountOnFiber(fiber);resetCurrentFiber();}var sibling=fiber.sibling;if(sibling!==null){ensureCorrectReturnPointer(sibling,fiber[\"return\"]);nextEffect=sibling;return;}nextEffect=fiber[\"return\"];}}function commitPassiveUnmountOnFiber(finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork[\"return\"]);recordPassiveEffectDuration(finishedWork);}else{commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork[\"return\"]);}break;}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot,nearestMountedAncestor){while(nextEffect!==null){var fiber=nextEffect;// Deletion effects fire in parent -> child order\n// TODO: Check if fiber has a PassiveStatic flag\nsetCurrentFiber(fiber);commitPassiveUnmountInsideDeletedTreeOnFiber(fiber,nearestMountedAncestor);resetCurrentFiber();var child=fiber.child;// TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n// do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\nif(child!==null){ensureCorrectReturnPointer(child,fiber);nextEffect=child;}else{commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var sibling=fiber.sibling;var returnFiber=fiber[\"return\"];{// Recursively traverse the entire deleted tree and clean up fiber fields.\n// This is more aggressive than ideal, and the long term goal is to only\n// have to detach the deleted tree at the root.\ndetachFiberAfterEffects(fiber);if(fiber===deletedSubtreeRoot){nextEffect=null;return;}}if(sibling!==null){ensureCorrectReturnPointer(sibling,returnFiber);nextEffect=sibling;return;}nextEffect=returnFiber;}}function commitPassiveUnmountInsideDeletedTreeOnFiber(current,nearestMountedAncestor){switch(current.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(current.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);recordPassiveEffectDuration(current);}else{commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);}break;}}}var didWarnWrongReturnPointer=false;function ensureCorrectReturnPointer(fiber,expectedReturnFiber){{if(!didWarnWrongReturnPointer&&fiber[\"return\"]!==expectedReturnFiber){didWarnWrongReturnPointer=true;error('Internal React error: Return pointer is inconsistent '+'with parent.');}}// TODO: Remove this assignment once we're confident that it won't break\n// anything, by checking the warning logs for the above invariant\nfiber[\"return\"]=expectedReturnFiber;}// TODO: Reuse reappearLayoutEffects traversal here?\nfunction invokeLayoutEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Layout|HasEffect,fiber);}catch(error){reportUncaughtErrorInDEV(error);captureCommitPhaseError(fiber,fiber[\"return\"],error);}break;}case ClassComponent:{var instance=fiber.stateNode;try{instance.componentDidMount();}catch(error){reportUncaughtErrorInDEV(error);captureCommitPhaseError(fiber,fiber[\"return\"],error);}break;}}}}function invokePassiveEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Passive$1|HasEffect,fiber);}catch(error){reportUncaughtErrorInDEV(error);captureCommitPhaseError(fiber,fiber[\"return\"],error);}break;}}}}function invokeLayoutEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Layout|HasEffect,fiber,fiber[\"return\"]);}catch(error){reportUncaughtErrorInDEV(error);captureCommitPhaseError(fiber,fiber[\"return\"],error);}break;}case ClassComponent:{var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber[\"return\"],instance);}break;}}}}function invokePassiveEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Passive$1|HasEffect,fiber,fiber[\"return\"]);}catch(error){reportUncaughtErrorInDEV(error);captureCommitPhaseError(fiber,fiber[\"return\"],error);}}}}}var COMPONENT_TYPE=0;var HAS_PSEUDO_CLASS_TYPE=1;var ROLE_TYPE=2;var TEST_NAME_TYPE=3;var TEXT_TYPE=4;if(typeof Symbol==='function'&&Symbol[\"for\"]){var symbolFor=Symbol[\"for\"];COMPONENT_TYPE=symbolFor('selector.component');HAS_PSEUDO_CLASS_TYPE=symbolFor('selector.has_pseudo_class');ROLE_TYPE=symbolFor('selector.role');TEST_NAME_TYPE=symbolFor('selector.test_id');TEXT_TYPE=symbolFor('selector.text');}var commitHooks=[];function onCommitRoot$1(){{commitHooks.forEach(function(commitHook){return commitHook();});}}var ReactCurrentActQueue=ReactSharedInternals.ReactCurrentActQueue;function isLegacyActEnvironment(fiber){{// Legacy mode. We preserve the behavior of React 17's act. It assumes an\n// act environment whenever `jest` is defined, but you can still turn off\n// spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly\n// to false.\nvar isReactActEnvironmentGlobal=// $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\ntypeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;// $FlowExpectedError - Flow doesn't know about jest\nvar jestIsDefined=typeof jest!=='undefined';return jestIsDefined&&isReactActEnvironmentGlobal!==false;}}function isConcurrentActEnvironment(){{var isReactActEnvironmentGlobal=// $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\ntypeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;if(!isReactActEnvironmentGlobal&&ReactCurrentActQueue.current!==null){// TODO: Include link to relevant documentation page.\nerror('The current testing environment is not configured to support '+'act(...)');}return isReactActEnvironmentGlobal;}}var ceil=Math.ceil;var ReactCurrentDispatcher$2=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentOwner$2=ReactSharedInternals.ReactCurrentOwner,ReactCurrentBatchConfig$3=ReactSharedInternals.ReactCurrentBatchConfig,ReactCurrentActQueue$1=ReactSharedInternals.ReactCurrentActQueue;var NoContext=/*             */0;var BatchedContext=/*               */1;var RenderContext=/*                */2;var CommitContext=/*                */4;var RootInProgress=0;var RootFatalErrored=1;var RootErrored=2;var RootSuspended=3;var RootSuspendedWithDelay=4;var RootCompleted=5;var RootDidNotComplete=6;// Describes where we are in the React execution stack\nvar executionContext=NoContext;// The root we're working on\nvar workInProgressRoot=null;// The fiber we're working on\nvar workInProgress=null;// The lanes we're rendering\nvar workInProgressRootRenderLanes=NoLanes;// Stack that allows components to change the render lanes for its subtree\n// This is a superset of the lanes we started working on at the root. The only\n// case where it's different from `workInProgressRootRenderLanes` is when we\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\n// Offscreen component.\n//\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\nvar subtreeRenderLanes=NoLanes;var subtreeRenderLanesCursor=createCursor(NoLanes);// Whether to root completed, errored, suspended, etc.\nvar workInProgressRootExitStatus=RootInProgress;// A fatal error, if one is thrown\nvar workInProgressRootFatalError=null;// \"Included\" lanes refer to lanes that were worked on during this render. It's\n// slightly different than `renderLanes` because `renderLanes` can change as you\n// enter and exit an Offscreen tree. This value is the combination of all render\n// lanes for the entire render phase.\nvar workInProgressRootIncludedLanes=NoLanes;// The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\nvar workInProgressRootSkippedLanes=NoLanes;// Lanes that were updated (in an interleaved event) during this render.\nvar workInProgressRootInterleavedUpdatedLanes=NoLanes;// Lanes that were updated during the render phase (*not* an interleaved event).\nvar workInProgressRootPingedLanes=NoLanes;// Errors that are thrown during the render phase.\nvar workInProgressRootConcurrentErrors=null;// These are errors that we recovered from without surfacing them to the UI.\n// We will log them once the tree commits.\nvar workInProgressRootRecoverableErrors=null;// The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\nvar globalMostRecentFallbackTime=0;var FALLBACK_THROTTLE_MS=500;// The absolute time for when we should start giving up on rendering\n// more and prefer CPU suspense heuristics instead.\nvar workInProgressRootRenderTargetTime=Infinity;// How long a render is supposed to take before we start following CPU\n// suspense heuristics and opt out of rendering more content.\nvar RENDER_TIMEOUT_MS=500;function resetRenderTimer(){workInProgressRootRenderTargetTime=now()+RENDER_TIMEOUT_MS;}function getRenderTargetTime(){return workInProgressRootRenderTargetTime;}var hasUncaughtError=false;var firstUncaughtError=null;var legacyErrorBoundariesThatAlreadyFailed=null;// Only used when enableProfilerNestedUpdateScheduledHook is true;\nvar rootDoesHavePassiveEffects=false;var rootWithPendingPassiveEffects=null;var pendingPassiveEffectsLanes=NoLanes;var pendingPassiveProfilerEffects=[];var NESTED_UPDATE_LIMIT=50;var nestedUpdateCount=0;var rootWithNestedUpdates=null;var NESTED_PASSIVE_UPDATE_LIMIT=50;var nestedPassiveUpdateCount=0;// If two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\nvar currentEventTime=NoTimestamp;var currentEventTransitionLane=NoLanes;function getWorkInProgressRoot(){return workInProgressRoot;}function requestEventTime(){if((executionContext&(RenderContext|CommitContext))!==NoContext){// We're inside React, so it's fine to read the actual time.\nreturn now();}// We're not inside React, so we may be in the middle of a browser event.\nif(currentEventTime!==NoTimestamp){// Use the same start time for all updates until we enter React again.\nreturn currentEventTime;}// This is the first update since React yielded. Compute a new start time.\ncurrentEventTime=now();return currentEventTime;}function requestUpdateLane(fiber){// Special cases\nvar mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}else if((executionContext&RenderContext)!==NoContext&&workInProgressRootRenderLanes!==NoLanes){// This is a render phase update. These are not officially supported. The\n// old behavior is to give this the same \"thread\" (lanes) as\n// whatever is currently rendering. So if you call `setState` on a component\n// that happens later in the same render, it will flush. Ideally, we want to\n// remove the special case and treat them as if they came from an\n// interleaved event. Regardless, this pattern is not officially supported.\n// This behavior is only a fallback. The flag only exists until we can roll\n// out the setState warning, since existing code might accidentally rely on\n// the current behavior.\nreturn pickArbitraryLane(workInProgressRootRenderLanes);}var isTransition=requestCurrentTransition()!==NoTransition;if(isTransition){if(ReactCurrentBatchConfig$3.transition!==null){var transition=ReactCurrentBatchConfig$3.transition;if(!transition._updatedFibers){transition._updatedFibers=new Set();}transition._updatedFibers.add(fiber);}// The algorithm for assigning an update to a lane should be stable for all\n// updates at the same priority within the same event. To do this, the\n// inputs to the algorithm must be the same.\n//\n// The trick we use is to cache the first of each of these inputs within an\n// event. Then reset the cached values once we can be sure the event is\n// over. Our heuristic for that is whenever we enter a concurrent work loop.\nif(currentEventTransitionLane===NoLane){// All transitions within the same event are assigned the same lane.\ncurrentEventTransitionLane=claimNextTransitionLane();}return currentEventTransitionLane;}// Updates originating inside certain React methods, like flushSync, have\n// their priority set by tracking it with a context variable.\n//\n// The opaque type returned by the host config is internally a lane, so we can\n// use that directly.\n// TODO: Move this type conversion to the event priority module.\nvar updateLane=getCurrentUpdatePriority();if(updateLane!==NoLane){return updateLane;}// This update originated outside React. Ask the host environment for an\n// appropriate priority, based on the type of event.\n//\n// The opaque type returned by the host config is internally a lane, so we can\n// use that directly.\n// TODO: Move this type conversion to the event priority module.\nvar eventLane=getCurrentEventPriority();return eventLane;}function requestRetryLane(fiber){// This is a fork of `requestUpdateLane` designed specifically for Suspense\n// \"retries\" — a special update that attempts to flip a Suspense boundary\n// from its placeholder state to its primary/resolved state.\n// Special cases\nvar mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}return claimNextRetryLane();}function scheduleUpdateOnFiber(fiber,lane,eventTime){checkForNestedUpdates();var root=markUpdateLaneFromFiberToRoot(fiber,lane);if(root===null){return null;}// Mark that the root has a pending update.\nmarkRootUpdated(root,lane,eventTime);if((executionContext&RenderContext)!==NoLanes&&root===workInProgressRoot){// This update was dispatched during the render phase. This is a mistake\n// if the update originates from user space (with the exception of local\n// hook updates, which are handled differently and don't reach this\n// function), but there are some internal React features that use this as\n// an implementation detail, like selective hydration.\nwarnAboutRenderPhaseUpdatesInDEV(fiber);// Track lanes that were updated during the render phase\n}else{// This is a normal update, scheduled from outside the render phase. For\n// example, during an input event.\n{if(isDevToolsPresent){addFiberToLanesMap(root,fiber,lane);}}warnIfUpdatesNotWrappedWithActDEV(fiber);if(root===workInProgressRoot){// TODO: Consolidate with `isInterleavedUpdate` check\n// Received an update to a tree that's in the middle of rendering. Mark\n// that there was an interleaved update work on this root. Unless the\n// `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n// phase update. In that case, we don't treat render phase updates as if\n// they were interleaved, for backwards compat reasons.\nif((executionContext&RenderContext)===NoContext){workInProgressRootInterleavedUpdatedLanes=mergeLanes(workInProgressRootInterleavedUpdatedLanes,lane);}if(workInProgressRootExitStatus===RootSuspendedWithDelay){// The root already suspended with a delay, which means this render\n// definitely won't finish. Since we have a new update, let's mark it as\n// suspended now, right before marking the incoming update. This has the\n// effect of interrupting the current render and switching to the update.\n// TODO: Make sure this doesn't override pings that happen while we've\n// already started rendering.\nmarkRootSuspended$1(root,workInProgressRootRenderLanes);}}ensureRootIsScheduled(root,eventTime);if(lane===SyncLane&&executionContext===NoContext&&(fiber.mode&ConcurrentMode)===NoMode&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n!ReactCurrentActQueue$1.isBatchingLegacy){// Flush the synchronous work now, unless we're already working or inside\n// a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n// scheduleCallbackForFiber to preserve the ability to schedule a callback\n// without immediately flushing it. We only do this for user-initiated\n// updates, to preserve historical behavior of legacy mode.\nresetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}return root;}function scheduleInitialHydrationOnRoot(root,lane,eventTime){// This is a special fork of scheduleUpdateOnFiber that is only used to\n// schedule the initial hydration of a root that has just been created. Most\n// of the stuff in scheduleUpdateOnFiber can be skipped.\n//\n// The main reason for this separate path, though, is to distinguish the\n// initial children from subsequent updates. In fully client-rendered roots\n// (createRoot instead of hydrateRoot), all top-level renders are modeled as\n// updates, but hydration roots are special because the initial render must\n// match what was rendered on the server.\nvar current=root.current;current.lanes=lane;markRootUpdated(root,lane,eventTime);ensureRootIsScheduled(root,eventTime);}// This is split into a separate function so we can mark a fiber with pending\n// work without treating it as a typical update that originates from an event;\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\n// on a fiber.\nfunction markUpdateLaneFromFiberToRoot(sourceFiber,lane){// Update the source fiber's lanes\nsourceFiber.lanes=mergeLanes(sourceFiber.lanes,lane);var alternate=sourceFiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,lane);}{if(alternate===null&&(sourceFiber.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}// Walk the parent path to the root and update the child lanes.\nvar node=sourceFiber;var parent=sourceFiber[\"return\"];while(parent!==null){parent.childLanes=mergeLanes(parent.childLanes,lane);alternate=parent.alternate;if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,lane);}else{{if((parent.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}}node=parent;parent=parent[\"return\"];}if(node.tag===HostRoot){var root=node.stateNode;return root;}else{return null;}}function isInterleavedUpdate(fiber,lane){return(// TODO: Optimize slightly by comparing to root that fiber belongs to.\n// Requires some refactoring. Not a big deal though since it's rare for\n// concurrent apps to have more than a single root.\nworkInProgressRoot!==null&&(fiber.mode&ConcurrentMode)!==NoMode&&// If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),\n// then don't treat this as an interleaved update. This pattern is\n// accompanied by a warning but we haven't fully deprecated it yet. We can\n// remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.\n(executionContext&RenderContext)===NoContext);}// Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the priority\n// of the existing task is the same as the priority of the next level that the\n// root has work on. This function is called on every update, and right before\n// exiting a task.\nfunction ensureRootIsScheduled(root,currentTime){var existingCallbackNode=root.callbackNode;// Check if any lanes are being starved by other work. If so, mark them as\n// expired so we know to work on those next.\nmarkStarvedLanesAsExpired(root,currentTime);// Determine the next lanes to work on, and their priority.\nvar nextLanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(nextLanes===NoLanes){// Special case: There's nothing to work on.\nif(existingCallbackNode!==null){cancelCallback$1(existingCallbackNode);}root.callbackNode=null;root.callbackPriority=NoLane;return;}// We use the highest priority lane to represent the priority of the callback.\nvar newCallbackPriority=getHighestPriorityLane(nextLanes);// Check if there's an existing task. We may be able to reuse it.\nvar existingCallbackPriority=root.callbackPriority;if(existingCallbackPriority===newCallbackPriority&&// Special case related to `act`. If the currently scheduled task is a\n// Scheduler task, rather than an `act` task, cancel it and re-scheduled\n// on the `act` queue.\n!(ReactCurrentActQueue$1.current!==null&&existingCallbackNode!==fakeActCallbackNode)){{// If we're going to re-use an existing task, it needs to exist.\n// Assume that discrete update microtasks are non-cancellable and null.\n// TODO: Temporary until we confirm this warning is not fired.\nif(existingCallbackNode==null&&existingCallbackPriority!==SyncLane){error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');}}// The priority hasn't changed. We can reuse the existing task. Exit.\nreturn;}if(existingCallbackNode!=null){// Cancel the existing callback. We'll schedule a new one below.\ncancelCallback$1(existingCallbackNode);}// Schedule a new callback.\nvar newCallbackNode;if(newCallbackPriority===SyncLane){// Special case: Sync React callbacks are scheduled on a special\n// internal queue\nif(root.tag===LegacyRoot){if(ReactCurrentActQueue$1.isBatchingLegacy!==null){ReactCurrentActQueue$1.didScheduleLegacyUpdate=true;}scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null,root));}else{scheduleSyncCallback(performSyncWorkOnRoot.bind(null,root));}{// Flush the queue in a microtask.\nif(ReactCurrentActQueue$1.current!==null){// Inside `act`, use our internal `act` queue so that these get flushed\n// at the end of the current scope even when using the sync version\n// of `act`.\nReactCurrentActQueue$1.current.push(flushSyncCallbacks);}else{scheduleMicrotask(function(){// In Safari, appending an iframe forces microtasks to run.\n// https://github.com/facebook/react/issues/22459\n// We don't support running callbacks in the middle of render\n// or commit so we need to check against that.\nif(executionContext===NoContext){// It's only safe to do this conditionally because we always\n// check for pending work before we exit the task.\nflushSyncCallbacks();}});}}newCallbackNode=null;}else{var schedulerPriorityLevel;switch(lanesToEventPriority(nextLanes)){case DiscreteEventPriority:schedulerPriorityLevel=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriorityLevel=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriorityLevel=NormalPriority;break;case IdleEventPriority:schedulerPriorityLevel=IdlePriority;break;default:schedulerPriorityLevel=NormalPriority;break;}newCallbackNode=scheduleCallback$1(schedulerPriorityLevel,performConcurrentWorkOnRoot.bind(null,root));}root.callbackPriority=newCallbackPriority;root.callbackNode=newCallbackNode;}// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot(root,didTimeout){{resetNestedUpdateFlag();}// Since we know we're in a React event, we can clear the current\n// event time. The next update will compute a new event time.\ncurrentEventTime=NoTimestamp;currentEventTransitionLane=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}// Flush any pending passive effects before deciding which lanes to work on,\n// in case they schedule additional work.\nvar originalCallbackNode=root.callbackNode;var didFlushPassiveEffects=flushPassiveEffects();if(didFlushPassiveEffects){// Something in the passive effect phase may have canceled the current task.\n// Check if the task node for this root was changed.\nif(root.callbackNode!==originalCallbackNode){// The current task was canceled. Exit. We don't need to call\n// `ensureRootIsScheduled` because the check above implies either that\n// there's a new task, or that there's no remaining work on this root.\nreturn null;}}// Determine the next lanes to work on, using the fields stored\n// on the root.\nvar lanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(lanes===NoLanes){// Defensive coding. This is never expected to happen.\nreturn null;}// We disable time-slicing in some cases: if the work has been CPU-bound\n// for too long (\"expired\" work, to prevent starvation), or we're in\n// sync-updates-by-default mode.\n// TODO: We only check `didTimeout` defensively, to account for a Scheduler\n// bug we're still investigating. Once the bug in Scheduler is fixed,\n// we can remove this, since we track expiration ourselves.\nvar shouldTimeSlice=!includesBlockingLane(root,lanes)&&!includesExpiredLane(root,lanes)&&!didTimeout;var exitStatus=shouldTimeSlice?renderRootConcurrent(root,lanes):renderRootSync(root,lanes);if(exitStatus!==RootInProgress){if(exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll\n// render synchronously to block concurrent data mutations, and we'll\n// includes all pending updates are included. If it still fails after\n// the second attempt, we'll give up and commit the resulting tree.\nvar errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){// The render unwound without completing the tree. This happens in special\n// cases where need to exit the current render without producing a\n// consistent tree or committing.\n//\n// This should only happen during a concurrent render, not a discrete or\n// synchronous update. We should have already checked for this when we\n// unwound the stack.\nmarkRootSuspended$1(root,lanes);}else{// The render completed.\n// Check if this render may have yielded to a concurrent event, and if so,\n// confirm that any newly rendered stores are consistent.\n// TODO: It's possible that even a concurrent render may never have yielded\n// to the main thread, if it was fast enough, or if it expired. We could\n// skip the consistency check in that case, too.\nvar renderWasConcurrent=!includesBlockingLane(root,lanes);var finishedWork=root.current.alternate;if(renderWasConcurrent&&!isRenderConsistentWithExternalStores(finishedWork)){// A store was mutated in an interleaved event. Render again,\n// synchronously, to block further mutations.\nexitStatus=renderRootSync(root,lanes);// We need to check again if something threw\nif(exitStatus===RootErrored){var _errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(_errorRetryLanes!==NoLanes){lanes=_errorRetryLanes;exitStatus=recoverFromConcurrentError(root,_errorRetryLanes);// We assume the tree is now consistent because we didn't yield to any\n// concurrent events.\n}}if(exitStatus===RootFatalErrored){var _fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw _fatalError;}}// We now have a consistent tree. The next step is either to commit it,\n// or, if something suspended, wait to commit it after a timeout.\nroot.finishedWork=finishedWork;root.finishedLanes=lanes;finishConcurrentRender(root,exitStatus,lanes);}}ensureRootIsScheduled(root,now());if(root.callbackNode===originalCallbackNode){// The task node scheduled for this root is the same one that's\n// currently executed. Need to return a continuation.\nreturn performConcurrentWorkOnRoot.bind(null,root);}return null;}function recoverFromConcurrentError(root,errorRetryLanes){// If an error occurred during hydration, discard server response and fall\n// back to client side render.\n// Before rendering again, save the errors from the previous attempt.\nvar errorsFromFirstAttempt=workInProgressRootConcurrentErrors;if(isRootDehydrated(root)){// The shell failed to hydrate. Set a flag to force a client rendering\n// during the next attempt. To do this, we call prepareFreshStack now\n// to create the root work-in-progress fiber. This is a bit weird in terms\n// of factoring, because it relies on renderRootSync not calling\n// prepareFreshStack again in the call below, which happens because the\n// root and lanes haven't changed.\n//\n// TODO: I think what we should do is set ForceClientRender inside\n// throwException, like we do for nested Suspense boundaries. The reason\n// it's here instead is so we can switch to the synchronous work loop, too.\n// Something to consider for a future refactor.\nvar rootWorkInProgress=prepareFreshStack(root,errorRetryLanes);rootWorkInProgress.flags|=ForceClientRender;{errorHydratingContainer(root.containerInfo);}}var exitStatus=renderRootSync(root,errorRetryLanes);if(exitStatus!==RootErrored){// Successfully finished rendering on retry\n// The errors from the failed first attempt have been recovered. Add\n// them to the collection of recoverable errors. We'll log them in the\n// commit phase.\nvar errorsFromSecondAttempt=workInProgressRootRecoverableErrors;workInProgressRootRecoverableErrors=errorsFromFirstAttempt;// The errors from the second attempt should be queued after the errors\n// from the first attempt, to preserve the causal sequence.\nif(errorsFromSecondAttempt!==null){queueRecoverableErrors(errorsFromSecondAttempt);}}return exitStatus;}function queueRecoverableErrors(errors){if(workInProgressRootRecoverableErrors===null){workInProgressRootRecoverableErrors=errors;}else{workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors,errors);}}function finishConcurrentRender(root,exitStatus,lanes){switch(exitStatus){case RootInProgress:case RootFatalErrored:{throw new Error('Root did not complete. This is a bug in React.');}// Flow knows about invariant, so it complains if I add a break\n// statement, but eslint doesn't know about invariant, so it complains\n// if I do. eslint-disable-next-line no-fallthrough\ncase RootErrored:{// We should have already attempted to retry this tree. If we reached\n// this point, it errored again. Commit it.\ncommitRoot(root,workInProgressRootRecoverableErrors);break;}case RootSuspended:{markRootSuspended$1(root,lanes);// We have an acceptable loading state. We need to figure out if we\n// should immediately commit it or wait a bit.\nif(includesOnlyRetries(lanes)&&// do not delay if we're inside an act() scope\n!shouldForceFlushFallbacksInDEV()){// This render only included retries, no updates. Throttle committing\n// retries so that we don't show too many loading states too quickly.\nvar msUntilTimeout=globalMostRecentFallbackTime+FALLBACK_THROTTLE_MS-now();// Don't bother with a very short suspense time.\nif(msUntilTimeout>10){var nextLanes=getNextLanes(root,NoLanes);if(nextLanes!==NoLanes){// There's additional work on this root.\nbreak;}var suspendedLanes=root.suspendedLanes;if(!isSubsetOfLanes(suspendedLanes,lanes)){// We should prefer to render the fallback of at the last\n// suspended level. Ping the last suspended level to try\n// rendering it again.\n// FIXME: What if the suspended lanes are Idle? Should not restart.\nvar eventTime=requestEventTime();markRootPinged(root,suspendedLanes);break;}// The render is suspended, it hasn't timed out, and there's no\n// lower priority work to do. Instead of committing the fallback\n// immediately, wait for more data to arrive.\nroot.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors),msUntilTimeout);break;}}// The work expired. Commit immediately.\ncommitRoot(root,workInProgressRootRecoverableErrors);break;}case RootSuspendedWithDelay:{markRootSuspended$1(root,lanes);if(includesOnlyTransitions(lanes)){// This is a transition, so we should exit without committing a\n// placeholder and without scheduling a timeout. Delay indefinitely\n// until we receive more data.\nbreak;}if(!shouldForceFlushFallbacksInDEV()){// This is not a transition, but we did trigger an avoided state.\n// Schedule a placeholder to display after a short delay, using the Just\n// Noticeable Difference.\n// TODO: Is the JND optimization worth the added complexity? If this is\n// the only reason we track the event time, then probably not.\n// Consider removing.\nvar mostRecentEventTime=getMostRecentEventTime(root,lanes);var eventTimeMs=mostRecentEventTime;var timeElapsedMs=now()-eventTimeMs;var _msUntilTimeout=jnd(timeElapsedMs)-timeElapsedMs;// Don't bother with a very short suspense time.\nif(_msUntilTimeout>10){// Instead of committing the fallback immediately, wait for more data\n// to arrive.\nroot.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors),_msUntilTimeout);break;}}// Commit the placeholder.\ncommitRoot(root,workInProgressRootRecoverableErrors);break;}case RootCompleted:{// The work completed. Ready to commit.\ncommitRoot(root,workInProgressRootRecoverableErrors);break;}default:{throw new Error('Unknown root exit status.');}}}function isRenderConsistentWithExternalStores(finishedWork){// Search the rendered tree for external store reads, and check whether the\n// stores were mutated in a concurrent event. Intentionally using an iterative\n// loop instead of recursion so we can exit early.\nvar node=finishedWork;while(true){if(node.flags&StoreConsistency){var updateQueue=node.updateQueue;if(updateQueue!==null){var checks=updateQueue.stores;if(checks!==null){for(var i=0;i<checks.length;i++){var check=checks[i];var getSnapshot=check.getSnapshot;var renderedValue=check.value;try{if(!objectIs(getSnapshot(),renderedValue)){// Found an inconsistent store.\nreturn false;}}catch(error){// If `getSnapshot` throws, return `false`. This will schedule\n// a re-render, and the error will be rethrown during render.\nreturn false;}}}}}var child=node.child;if(node.subtreeFlags&StoreConsistency&&child!==null){child[\"return\"]=node;node=child;continue;}if(node===finishedWork){return true;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===finishedWork){return true;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}// Flow doesn't know this is unreachable, but eslint does\n// eslint-disable-next-line no-unreachable\nreturn true;}function markRootSuspended$1(root,suspendedLanes){// When suspending, we should always exclude lanes that were pinged or (more\n// rarely, since we try to avoid it) updated during the render phase.\n// TODO: Lol maybe there's a better way to factor this besides this\n// obnoxiously named function :)\nsuspendedLanes=removeLanes(suspendedLanes,workInProgressRootPingedLanes);suspendedLanes=removeLanes(suspendedLanes,workInProgressRootInterleavedUpdatedLanes);markRootSuspended(root,suspendedLanes);}// This is the entry point for synchronous tasks that don't go\n// through Scheduler\nfunction performSyncWorkOnRoot(root){{syncNestedUpdateFlag();}if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}flushPassiveEffects();var lanes=getNextLanes(root,NoLanes);if(!includesSomeLane(lanes,SyncLane)){// There's no remaining sync work left.\nensureRootIsScheduled(root,now());return null;}var exitStatus=renderRootSync(root,lanes);if(root.tag!==LegacyRoot&&exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll render\n// synchronously to block concurrent data mutations, and we'll includes\n// all pending updates are included. If it still fails after the second\n// attempt, we'll give up and commit the resulting tree.\nvar errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){throw new Error('Root did not complete. This is a bug in React.');}// We now have a consistent tree. Because this is a sync render, we\n// will commit it even if something suspended.\nvar finishedWork=root.current.alternate;root.finishedWork=finishedWork;root.finishedLanes=lanes;commitRoot(root,workInProgressRootRecoverableErrors);// Before exiting, make sure there's a callback scheduled for the next\n// pending level.\nensureRootIsScheduled(root,now());return null;}function flushRoot(root,lanes){if(lanes!==NoLanes){markRootEntangled(root,mergeLanes(lanes,SyncLane));ensureRootIsScheduled(root,now());if((executionContext&(RenderContext|CommitContext))===NoContext){resetRenderTimer();flushSyncCallbacks();}}}function batchedUpdates$1(fn,a){var prevExecutionContext=executionContext;executionContext|=BatchedContext;try{return fn(a);}finally{executionContext=prevExecutionContext;// If there were legacy sync updates, flush them at the end of the outer\n// most batchedUpdates-like method.\nif(executionContext===NoContext&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n!ReactCurrentActQueue$1.isBatchingLegacy){resetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}}function discreteUpdates(fn,a,b,c,d){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);return fn(a,b,c,d);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;if(executionContext===NoContext){resetRenderTimer();}}}// Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n// eslint-disable-next-line no-redeclare\nfunction flushSync(fn){// In legacy mode, we flush pending passive effects at the beginning of the\n// next event, not at the end of the previous one.\nif(rootWithPendingPassiveEffects!==null&&rootWithPendingPassiveEffects.tag===LegacyRoot&&(executionContext&(RenderContext|CommitContext))===NoContext){flushPassiveEffects();}var prevExecutionContext=executionContext;executionContext|=BatchedContext;var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);if(fn){return fn();}else{return undefined;}}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;executionContext=prevExecutionContext;// Flush the immediate callbacks that were scheduled during this batch.\n// Note that this will happen even if batchedUpdates is higher up\n// the stack.\nif((executionContext&(RenderContext|CommitContext))===NoContext){flushSyncCallbacks();}}}function isAlreadyRendering(){// Used by the renderer to print a warning if certain APIs are called from\n// the wrong context.\nreturn(executionContext&(RenderContext|CommitContext))!==NoContext;}function pushRenderLanes(fiber,lanes){push(subtreeRenderLanesCursor,subtreeRenderLanes,fiber);subtreeRenderLanes=mergeLanes(subtreeRenderLanes,lanes);workInProgressRootIncludedLanes=mergeLanes(workInProgressRootIncludedLanes,lanes);}function popRenderLanes(fiber){subtreeRenderLanes=subtreeRenderLanesCursor.current;pop(subtreeRenderLanesCursor,fiber);}function prepareFreshStack(root,lanes){root.finishedWork=null;root.finishedLanes=NoLanes;var timeoutHandle=root.timeoutHandle;if(timeoutHandle!==noTimeout){// The root previous suspended and scheduled a timeout to commit a fallback\n// state. Now that we have additional work, cancel the timeout.\nroot.timeoutHandle=noTimeout;// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\ncancelTimeout(timeoutHandle);}if(workInProgress!==null){var interruptedWork=workInProgress[\"return\"];while(interruptedWork!==null){var current=interruptedWork.alternate;unwindInterruptedWork(current,interruptedWork);interruptedWork=interruptedWork[\"return\"];}}workInProgressRoot=root;var rootWorkInProgress=createWorkInProgress(root.current,null);workInProgress=rootWorkInProgress;workInProgressRootRenderLanes=subtreeRenderLanes=workInProgressRootIncludedLanes=lanes;workInProgressRootExitStatus=RootInProgress;workInProgressRootFatalError=null;workInProgressRootSkippedLanes=NoLanes;workInProgressRootInterleavedUpdatedLanes=NoLanes;workInProgressRootPingedLanes=NoLanes;workInProgressRootConcurrentErrors=null;workInProgressRootRecoverableErrors=null;enqueueInterleavedUpdates();{ReactStrictModeWarnings.discardPendingWarnings();}return rootWorkInProgress;}function handleError(root,thrownValue){do{var erroredWork=workInProgress;try{// Reset module-level state that was set during the render phase.\nresetContextDependencies();resetHooksAfterThrow();resetCurrentFiber();// TODO: I found and added this missing line while investigating a\n// separate issue. Write a regression test using string refs.\nReactCurrentOwner$2.current=null;if(erroredWork===null||erroredWork[\"return\"]===null){// Expected to be working on a non-root fiber. This is a fatal error\n// because there's no ancestor that can handle it; the root is\n// supposed to capture all errors that weren't caught by an error\n// boundary.\nworkInProgressRootExitStatus=RootFatalErrored;workInProgressRootFatalError=thrownValue;// Set `workInProgress` to null. This represents advancing to the next\n// sibling, or the parent if there are no siblings. But since the root\n// has no siblings nor a parent, we set it to null. Usually this is\n// handled by `completeUnitOfWork` or `unwindWork`, but since we're\n// intentionally not calling those, we need set it here.\n// TODO: Consider calling `unwindWork` to pop the contexts.\nworkInProgress=null;return;}if(enableProfilerTimer&&erroredWork.mode&ProfileMode){// Record the time spent rendering before an error was thrown. This\n// avoids inaccurate Profiler durations in the case of a\n// suspended render.\nstopProfilerTimerIfRunningAndRecordDelta(erroredWork,true);}if(enableSchedulingProfiler){markComponentRenderStopped();if(thrownValue!==null&&_typeof(thrownValue)==='object'&&typeof thrownValue.then==='function'){var wakeable=thrownValue;markComponentSuspended(erroredWork,wakeable,workInProgressRootRenderLanes);}else{markComponentErrored(erroredWork,thrownValue,workInProgressRootRenderLanes);}}throwException(root,erroredWork[\"return\"],erroredWork,thrownValue,workInProgressRootRenderLanes);completeUnitOfWork(erroredWork);}catch(yetAnotherThrownValue){// Something in the return path also threw.\nthrownValue=yetAnotherThrownValue;if(workInProgress===erroredWork&&erroredWork!==null){// If this boundary has already errored, then we had trouble processing\n// the error. Bubble it to the next boundary.\nerroredWork=erroredWork[\"return\"];workInProgress=erroredWork;}else{erroredWork=workInProgress;}continue;}// Return to the normal work loop.\nreturn;}while(true);}function pushDispatcher(){var prevDispatcher=ReactCurrentDispatcher$2.current;ReactCurrentDispatcher$2.current=ContextOnlyDispatcher;if(prevDispatcher===null){// The React isomorphic package does not include a default dispatcher.\n// Instead the first renderer will lazily attach one, in order to give\n// nicer error messages.\nreturn ContextOnlyDispatcher;}else{return prevDispatcher;}}function popDispatcher(prevDispatcher){ReactCurrentDispatcher$2.current=prevDispatcher;}function markCommitTimeOfFallback(){globalMostRecentFallbackTime=now();}function markSkippedUpdateLanes(lane){workInProgressRootSkippedLanes=mergeLanes(lane,workInProgressRootSkippedLanes);}function renderDidSuspend(){if(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootSuspended;}}function renderDidSuspendDelayIfPossible(){if(workInProgressRootExitStatus===RootInProgress||workInProgressRootExitStatus===RootSuspended||workInProgressRootExitStatus===RootErrored){workInProgressRootExitStatus=RootSuspendedWithDelay;}// Check if there are updates that we skipped tree that might have unblocked\n// this render.\nif(workInProgressRoot!==null&&(includesNonIdleWork(workInProgressRootSkippedLanes)||includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))){// Mark the current render as suspended so that we switch to working on\n// the updates that were skipped. Usually we only suspend at the end of\n// the render phase.\n// TODO: We should probably always mark the root as suspended immediately\n// (inside this function), since by suspending at the end of the render\n// phase introduces a potential mistake where we suspend lanes that were\n// pinged or updated while we were rendering.\nmarkRootSuspended$1(workInProgressRoot,workInProgressRootRenderLanes);}}function renderDidError(error){if(workInProgressRootExitStatus!==RootSuspendedWithDelay){workInProgressRootExitStatus=RootErrored;}if(workInProgressRootConcurrentErrors===null){workInProgressRootConcurrentErrors=[error];}else{workInProgressRootConcurrentErrors.push(error);}}// Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\nfunction renderHasNotSuspendedYet(){// If something errored or completed, we can't really be sure,\n// so those are false.\nreturn workInProgressRootExitStatus===RootInProgress;}function renderRootSync(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack\n// and prepare a fresh one. Otherwise we'll continue where we left off.\nif(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n// If we bailout on this work, we'll move them back (like above).\n// It's important to move them now in case the work spawns more work at the same priority with different updaters.\n// That way we can keep the current update and future updates separate.\nmovePendingFibersToMemoized(root,lanes);}}prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopSync();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();executionContext=prevExecutionContext;popDispatcher(prevDispatcher);if(workInProgress!==null){// This is a sync render, so we should have finished the whole tree.\nthrow new Error('Cannot commit an incomplete root. This error is likely caused by a '+'bug in React. Please file an issue.');}{markRenderStopped();}// Set this to null to indicate there's no in-progress render.\nworkInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;return workInProgressRootExitStatus;}// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */function workLoopSync(){// Already timed out, so perform work without checking if we need to yield.\nwhile(workInProgress!==null){performUnitOfWork(workInProgress);}}function renderRootConcurrent(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack\n// and prepare a fresh one. Otherwise we'll continue where we left off.\nif(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n// If we bailout on this work, we'll move them back (like above).\n// It's important to move them now in case the work spawns more work at the same priority with different updaters.\n// That way we can keep the current update and future updates separate.\nmovePendingFibersToMemoized(root,lanes);}}resetRenderTimer();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopConcurrent();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();popDispatcher(prevDispatcher);executionContext=prevExecutionContext;if(workInProgress!==null){// Still work remaining.\n{markRenderYielded();}return RootInProgress;}else{// Completed the tree.\n{markRenderStopped();}// Set this to null to indicate there's no in-progress render.\nworkInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;// Return the final exit status.\nreturn workInProgressRootExitStatus;}}/** @noinline */function workLoopConcurrent(){// Perform work until Scheduler asks us to yield\nwhile(workInProgress!==null&&!shouldYield()){performUnitOfWork(workInProgress);}}function performUnitOfWork(unitOfWork){// The current, flushed, state of this fiber is the alternate. Ideally\n// nothing should rely on this, but relying on it here means that we don't\n// need an additional field on the work in progress.\nvar current=unitOfWork.alternate;setCurrentFiber(unitOfWork);var next;if((unitOfWork.mode&ProfileMode)!==NoMode){startProfilerTimer(unitOfWork);next=beginWork$1(current,unitOfWork,subtreeRenderLanes);stopProfilerTimerIfRunningAndRecordDelta(unitOfWork,true);}else{next=beginWork$1(current,unitOfWork,subtreeRenderLanes);}resetCurrentFiber();unitOfWork.memoizedProps=unitOfWork.pendingProps;if(next===null){// If this doesn't spawn new work, complete the current work.\ncompleteUnitOfWork(unitOfWork);}else{workInProgress=next;}ReactCurrentOwner$2.current=null;}function completeUnitOfWork(unitOfWork){// Attempt to complete the current unit of work, then move to the next\n// sibling. If there are no more siblings, return to the parent fiber.\nvar completedWork=unitOfWork;do{// The current, flushed, state of this fiber is the alternate. Ideally\n// nothing should rely on this, but relying on it here means that we don't\n// need an additional field on the work in progress.\nvar current=completedWork.alternate;var returnFiber=completedWork[\"return\"];// Check if the work completed or if something threw.\nif((completedWork.flags&Incomplete)===NoFlags){setCurrentFiber(completedWork);var next=void 0;if((completedWork.mode&ProfileMode)===NoMode){next=completeWork(current,completedWork,subtreeRenderLanes);}else{startProfilerTimer(completedWork);next=completeWork(current,completedWork,subtreeRenderLanes);// Update render duration assuming we didn't error.\nstopProfilerTimerIfRunningAndRecordDelta(completedWork,false);}resetCurrentFiber();if(next!==null){// Completing this fiber spawned new work. Work on that next.\nworkInProgress=next;return;}}else{// This fiber did not complete because something threw. Pop values off\n// the stack without entering the complete phase. If this is a boundary,\n// capture values if possible.\nvar _next=unwindWork(current,completedWork);// Because this fiber did not complete, don't reset its lanes.\nif(_next!==null){// If completing this work spawned new work, do that next. We'll come\n// back here again.\n// Since we're restarting, remove anything that is not a host effect\n// from the effect tag.\n_next.flags&=HostEffectMask;workInProgress=_next;return;}if((completedWork.mode&ProfileMode)!==NoMode){// Record the render duration for the fiber that errored.\nstopProfilerTimerIfRunningAndRecordDelta(completedWork,false);// Include the time spent working on failed children before continuing.\nvar actualDuration=completedWork.actualDuration;var child=completedWork.child;while(child!==null){actualDuration+=child.actualDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;}if(returnFiber!==null){// Mark the parent fiber as incomplete and clear its subtree flags.\nreturnFiber.flags|=Incomplete;returnFiber.subtreeFlags=NoFlags;returnFiber.deletions=null;}else{// We've unwound all the way to the root.\nworkInProgressRootExitStatus=RootDidNotComplete;workInProgress=null;return;}}var siblingFiber=completedWork.sibling;if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.\nworkInProgress=siblingFiber;return;}// Otherwise, return to the parent\ncompletedWork=returnFiber;// Update the next thing we're working on in case something throws.\nworkInProgress=completedWork;}while(completedWork!==null);// We've reached the root.\nif(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootCompleted;}}function commitRoot(root,recoverableErrors){// TODO: This no longer makes any sense. We already wrap the mutation and\n// layout phases. Should be able to remove.\nvar previousUpdateLanePriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);commitRootImpl(root,recoverableErrors,previousUpdateLanePriority);}finally{ReactCurrentBatchConfig$3.transition=prevTransition;setCurrentUpdatePriority(previousUpdateLanePriority);}return null;}function commitRootImpl(root,recoverableErrors,renderPriorityLevel){do{// `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n// means `flushPassiveEffects` will sometimes result in additional\n// passive effects. So we need to keep flushing in a loop until there are\n// no more pending effects.\n// TODO: Might be better if `flushPassiveEffects` did not automatically\n// flush synchronous work at the end, to avoid factoring hazards like this.\nflushPassiveEffects();}while(rootWithPendingPassiveEffects!==null);flushRenderPhaseStrictModeWarningsInDEV();if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}var finishedWork=root.finishedWork;var lanes=root.finishedLanes;{markCommitStarted(lanes);}if(finishedWork===null){{markCommitStopped();}return null;}else{{if(lanes===NoLanes){error('root.finishedLanes should not be empty during a commit. This is a '+'bug in React.');}}}root.finishedWork=null;root.finishedLanes=NoLanes;if(finishedWork===root.current){throw new Error('Cannot commit the same tree as before. This error is likely caused by '+'a bug in React. Please file an issue.');}// commitRoot never returns a continuation; it always finishes synchronously.\n// So we can clear these now to allow a new callback to be scheduled.\nroot.callbackNode=null;root.callbackPriority=NoLane;// Update the first and last pending times on this root. The new first\n// pending time is whatever is left on the root fiber.\nvar remainingLanes=mergeLanes(finishedWork.lanes,finishedWork.childLanes);markRootFinished(root,remainingLanes);if(root===workInProgressRoot){// We can reset these now that they are finished.\nworkInProgressRoot=null;workInProgress=null;workInProgressRootRenderLanes=NoLanes;}// If there are pending passive effects, schedule a callback to process them.\n// Do this as early as possible, so it is queued before anything else that\n// might get scheduled in the commit phase. (See #16714.)\n// TODO: Delete all other places that schedule the passive effect callback\n// They're redundant.\nif((finishedWork.subtreeFlags&PassiveMask)!==NoFlags||(finishedWork.flags&PassiveMask)!==NoFlags){if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();// This render triggered passive effects: release the root cache pool\n// *after* passive effects fire to avoid freeing a cache pool that may\n// be referenced by a node in the tree (HostRoot, Cache boundary etc)\nreturn null;});}}// Check if there are any effects in the whole tree.\n// TODO: This is left over from the effect list implementation, where we had\n// to check for the existence of `firstEffect` to satisfy Flow. I think the\n// only other reason this optimization exists is because it affects profiling.\n// Reconsider whether this is necessary.\nvar subtreeHasEffects=(finishedWork.subtreeFlags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;var rootHasEffect=(finishedWork.flags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;if(subtreeHasEffects||rootHasEffect){var prevTransition=ReactCurrentBatchConfig$3.transition;ReactCurrentBatchConfig$3.transition=null;var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(DiscreteEventPriority);var prevExecutionContext=executionContext;executionContext|=CommitContext;// Reset this to null before calling lifecycles\nReactCurrentOwner$2.current=null;// The commit phase is broken into several sub-phases. We do a separate pass\n// of the effect list for each phase: all mutation effects come before all\n// layout effects, and so on.\n// The first phase a \"before mutation\" phase. We use this phase to read the\n// state of the host tree right before we mutate it. This is where\n// getSnapshotBeforeUpdate is called.\nvar shouldFireAfterActiveInstanceBlur=commitBeforeMutationEffects(root,finishedWork);{// Mark the current commit time to be shared by all Profilers in this\n// batch. This enables them to be grouped later.\nrecordCommitTime();}commitMutationEffects(root,finishedWork,lanes);resetAfterCommit(root.containerInfo);// The work-in-progress tree is now the current tree. This must come after\n// the mutation phase, so that the previous tree is still current during\n// componentWillUnmount, but before the layout phase, so that the finished\n// work is current during componentDidMount/Update.\nroot.current=finishedWork;// The next phase is the layout phase, where we call effects that read\n{markLayoutEffectsStarted(lanes);}commitLayoutEffects(finishedWork,root,lanes);{markLayoutEffectsStopped();}// opportunity to paint.\nrequestPaint();executionContext=prevExecutionContext;// Reset the priority to the previous non-sync value.\nsetCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;}else{// No effects.\nroot.current=finishedWork;// Measure these anyway so the flamegraph explicitly shows that there were\n// no effects.\n// TODO: Maybe there's a better way to report this.\n{recordCommitTime();}}var rootDidHavePassiveEffects=rootDoesHavePassiveEffects;if(rootDoesHavePassiveEffects){// This commit has passive effects. Stash a reference to them. But don't\n// schedule a callback until after flushing layout work.\nrootDoesHavePassiveEffects=false;rootWithPendingPassiveEffects=root;pendingPassiveEffectsLanes=lanes;}// Read this again, since an effect might have updated it\nremainingLanes=root.pendingLanes;// Check if there's remaining work on this root\n// TODO: This is part of the `componentDidCatch` implementation. Its purpose\n// is to detect whether something might have called setState inside\n// `componentDidCatch`. The mechanism is known to be flawed because `setState`\n// inside `componentDidCatch` is itself flawed — that's why we recommend\n// `getDerivedStateFromError` instead. However, it could be improved by\n// checking if remainingLanes includes Sync work, instead of whether there's\n// any work remaining at all (which would also include stuff like Suspense\n// retries or transitions). It's been like this for a while, though, so fixing\n// it probably isn't that urgent.\nif(remainingLanes===NoLanes){// If there's no remaining work, we can clear the set of already failed\n// error boundaries.\nlegacyErrorBoundariesThatAlreadyFailed=null;}{if(!rootDidHavePassiveEffects){commitDoubleInvokeEffectsInDEV(root.current,false);}}onCommitRoot(finishedWork.stateNode,renderPriorityLevel);{if(isDevToolsPresent){root.memoizedUpdaters.clear();}}{onCommitRoot$1();}// Always call this before exiting `commitRoot`, to ensure that any\n// additional work on this root is scheduled.\nensureRootIsScheduled(root,now());if(recoverableErrors!==null){// There were errors during this render, but recovered from them without\n// needing to surface it to the UI. We log them here.\nvar onRecoverableError=root.onRecoverableError;for(var i=0;i<recoverableErrors.length;i++){var recoverableError=recoverableErrors[i];onRecoverableError(recoverableError);}}if(hasUncaughtError){hasUncaughtError=false;var error$1=firstUncaughtError;firstUncaughtError=null;throw error$1;}// If the passive effects are the result of a discrete render, flush them\n// synchronously at the end of the current task so that the result is\n// immediately observable. Otherwise, we assume that they are not\n// order-dependent and do not need to be observed by external systems, so we\n// can wait until after paint.\n// TODO: We can optimize this by not scheduling the callback earlier. Since we\n// currently schedule the callback in multiple places, will wait until those\n// are consolidated.\nif(includesSomeLane(pendingPassiveEffectsLanes,SyncLane)&&root.tag!==LegacyRoot){flushPassiveEffects();}// Read this again, since a passive effect might have updated it\nremainingLanes=root.pendingLanes;if(includesSomeLane(remainingLanes,SyncLane)){{markNestedUpdateScheduled();}// Count the number of times the root synchronously re-renders without\n// finishing. If there are too many, it indicates an infinite update loop.\nif(root===rootWithNestedUpdates){nestedUpdateCount++;}else{nestedUpdateCount=0;rootWithNestedUpdates=root;}}else{nestedUpdateCount=0;}// If layout work was scheduled, flush it now.\nflushSyncCallbacks();{markCommitStopped();}return null;}function flushPassiveEffects(){// Returns whether passive effects were flushed.\n// TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n// probably just combine the two functions. I believe they were only separate\n// in the first place because we used to wrap it with\n// `Scheduler.runWithPriority`, which accepts a function. But now we track the\n// priority within React itself, so we can mutate the variable directly.\nif(rootWithPendingPassiveEffects!==null){var renderPriority=lanesToEventPriority(pendingPassiveEffectsLanes);var priority=lowerEventPriority(DefaultEventPriority,renderPriority);var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(priority);return flushPassiveEffectsImpl();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;// Once passive effects have run for the tree - giving components a\n}}return false;}function enqueuePendingPassiveProfilerEffect(fiber){{pendingPassiveProfilerEffects.push(fiber);if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();return null;});}}}function flushPassiveEffectsImpl(){if(rootWithPendingPassiveEffects===null){return false;}var root=rootWithPendingPassiveEffects;var lanes=pendingPassiveEffectsLanes;rootWithPendingPassiveEffects=null;// TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n// Figure out why and fix it. It's not causing any known issues (probably\n// because it's only used for profiling), but it's a refactor hazard.\npendingPassiveEffectsLanes=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Cannot flush passive effects while already rendering.');}{markPassiveEffectsStarted(lanes);}var prevExecutionContext=executionContext;executionContext|=CommitContext;commitPassiveUnmountEffects(root.current);commitPassiveMountEffects(root,root.current);// TODO: Move to commitPassiveMountEffects\n{var profilerEffects=pendingPassiveProfilerEffects;pendingPassiveProfilerEffects=[];for(var i=0;i<profilerEffects.length;i++){var _fiber=profilerEffects[i];commitPassiveEffectDurations(root,_fiber);}}{markPassiveEffectsStopped();}{commitDoubleInvokeEffectsInDEV(root.current,true);}executionContext=prevExecutionContext;flushSyncCallbacks();// If additional passive effects were scheduled, increment a counter. If this\n// exceeds the limit, we'll fire a warning.\nnestedPassiveUpdateCount=rootWithPendingPassiveEffects===null?0:nestedPassiveUpdateCount+1;// TODO: Move to commitPassiveMountEffects\nonPostCommitRoot(root);{var stateNode=root.current.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}return true;}function isAlreadyFailedLegacyErrorBoundary(instance){return legacyErrorBoundariesThatAlreadyFailed!==null&&legacyErrorBoundariesThatAlreadyFailed.has(instance);}function markLegacyErrorBoundaryAsFailed(instance){if(legacyErrorBoundariesThatAlreadyFailed===null){legacyErrorBoundariesThatAlreadyFailed=new Set([instance]);}else{legacyErrorBoundariesThatAlreadyFailed.add(instance);}}function prepareToThrowUncaughtError(error){if(!hasUncaughtError){hasUncaughtError=true;firstUncaughtError=error;}}var onUncaughtError=prepareToThrowUncaughtError;function captureCommitPhaseErrorOnRoot(rootFiber,sourceFiber,error){var errorInfo=createCapturedValue(error,sourceFiber);var update=createRootErrorUpdate(rootFiber,errorInfo,SyncLane);enqueueUpdate(rootFiber,update);var eventTime=requestEventTime();var root=markUpdateLaneFromFiberToRoot(rootFiber,SyncLane);if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function captureCommitPhaseError(sourceFiber,nearestMountedAncestor,error$1){if(sourceFiber.tag===HostRoot){// Error was thrown at the root. There is no parent, so the root\n// itself should capture it.\ncaptureCommitPhaseErrorOnRoot(sourceFiber,sourceFiber,error$1);return;}var fiber=null;{fiber=nearestMountedAncestor;}while(fiber!==null){if(fiber.tag===HostRoot){captureCommitPhaseErrorOnRoot(fiber,sourceFiber,error$1);return;}else if(fiber.tag===ClassComponent){var ctor=fiber.type;var instance=fiber.stateNode;if(typeof ctor.getDerivedStateFromError==='function'||typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance)){var errorInfo=createCapturedValue(error$1,sourceFiber);var update=createClassErrorUpdate(fiber,errorInfo,SyncLane);enqueueUpdate(fiber,update);var eventTime=requestEventTime();var root=markUpdateLaneFromFiberToRoot(fiber,SyncLane);if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}return;}}fiber=fiber[\"return\"];}{// TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n// will fire for errors that are thrown by destroy functions inside deleted\n// trees. What it should instead do is propagate the error to the parent of\n// the deleted tree. In the meantime, do not add this warning to the\n// allowlist; this is only for our internal use.\nerror('Internal React error: Attempted to capture a commit phase error '+'inside a detached tree. This indicates a bug in React. Likely '+'causes include deleting the same fiber more than once, committing an '+'already-finished tree, or an inconsistent return pointer.\\n\\n'+'Error message:\\n\\n%s',error$1);}}function pingSuspendedRoot(root,wakeable,pingedLanes){var pingCache=root.pingCache;if(pingCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will\n// never be thrown again.\npingCache[\"delete\"](wakeable);}var eventTime=requestEventTime();markRootPinged(root,pingedLanes);warnIfSuspenseResolutionNotWrappedWithActDEV(root);if(workInProgressRoot===root&&isSubsetOfLanes(workInProgressRootRenderLanes,pingedLanes)){// Received a ping at the same priority level at which we're currently\n// rendering. We might want to restart this render. This should mirror\n// the logic of whether or not a root suspends once it completes.\n// TODO: If we're rendering sync either due to Sync, Batched or expired,\n// we should probably never restart.\n// If we're suspended with delay, or if it's a retry, we'll always suspend\n// so we can always restart.\nif(workInProgressRootExitStatus===RootSuspendedWithDelay||workInProgressRootExitStatus===RootSuspended&&includesOnlyRetries(workInProgressRootRenderLanes)&&now()-globalMostRecentFallbackTime<FALLBACK_THROTTLE_MS){// Restart from the root.\nprepareFreshStack(root,NoLanes);}else{// Even though we can't restart right now, we might get an\n// opportunity later. So we mark this render as having a ping.\nworkInProgressRootPingedLanes=mergeLanes(workInProgressRootPingedLanes,pingedLanes);}}ensureRootIsScheduled(root,eventTime);}function retryTimedOutBoundary(boundaryFiber,retryLane){// The boundary fiber (a Suspense component or SuspenseList component)\n// previously was rendered in its fallback state. One of the promises that\n// suspended it has resolved, which means at least part of the tree was\n// likely unblocked. Try rendering again, at a new lanes.\nif(retryLane===NoLane){// TODO: Assign this to `suspenseState.retryLane`? to avoid\n// unnecessary entanglement?\nretryLane=requestRetryLane(boundaryFiber);}// TODO: Special case idle priority?\nvar eventTime=requestEventTime();var root=markUpdateLaneFromFiberToRoot(boundaryFiber,retryLane);if(root!==null){markRootUpdated(root,retryLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function retryDehydratedSuspenseBoundary(boundaryFiber){var suspenseState=boundaryFiber.memoizedState;var retryLane=NoLane;if(suspenseState!==null){retryLane=suspenseState.retryLane;}retryTimedOutBoundary(boundaryFiber,retryLane);}function resolveRetryWakeable(boundaryFiber,wakeable){var retryLane=NoLane;// Default\nvar retryCache;{switch(boundaryFiber.tag){case SuspenseComponent:retryCache=boundaryFiber.stateNode;var suspenseState=boundaryFiber.memoizedState;if(suspenseState!==null){retryLane=suspenseState.retryLane;}break;case SuspenseListComponent:retryCache=boundaryFiber.stateNode;break;default:throw new Error('Pinged unknown suspense boundary type. '+'This is probably a bug in React.');}}if(retryCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will\n// never be thrown again.\nretryCache[\"delete\"](wakeable);}retryTimedOutBoundary(boundaryFiber,retryLane);}// Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\nfunction jnd(timeElapsed){return timeElapsed<120?120:timeElapsed<480?480:timeElapsed<1080?1080:timeElapsed<1920?1920:timeElapsed<3000?3000:timeElapsed<4320?4320:ceil(timeElapsed/1960)*1960;}function checkForNestedUpdates(){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){nestedUpdateCount=0;rootWithNestedUpdates=null;throw new Error('Maximum update depth exceeded. This can happen when a component '+'repeatedly calls setState inside componentWillUpdate or '+'componentDidUpdate. React limits the number of nested updates to '+'prevent infinite loops.');}{if(nestedPassiveUpdateCount>NESTED_PASSIVE_UPDATE_LIMIT){nestedPassiveUpdateCount=0;error('Maximum update depth exceeded. This can happen when a component '+\"calls setState inside useEffect, but useEffect either doesn't \"+'have a dependency array, or one of the dependencies changes on '+'every render.');}}}function flushRenderPhaseStrictModeWarningsInDEV(){{ReactStrictModeWarnings.flushLegacyContextWarning();{ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();}}}function commitDoubleInvokeEffectsInDEV(fiber,hasPassiveEffects){{// TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n// so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n// Maybe not a big deal since this is DEV only behavior.\nsetCurrentFiber(fiber);invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectUnmountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectUnmountInDEV);}invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectMountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectMountInDEV);}resetCurrentFiber();}}function invokeEffectsInDev(firstChild,fiberFlags,invokeEffectFn){{// We don't need to re-check StrictEffectsMode here.\n// This function is only called if that check has already passed.\nvar current=firstChild;var subtreeRoot=null;while(current!==null){var primarySubtreeFlag=current.subtreeFlags&fiberFlags;if(current!==subtreeRoot&&current.child!==null&&primarySubtreeFlag!==NoFlags){current=current.child;}else{if((current.flags&fiberFlags)!==NoFlags){invokeEffectFn(current);}if(current.sibling!==null){current=current.sibling;}else{current=subtreeRoot=current[\"return\"];}}}}}var didWarnStateUpdateForNotYetMountedComponent=null;function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber){{if((executionContext&RenderContext)!==NoContext){// We let the other warning about render phase updates deal with this one.\nreturn;}if(!(fiber.mode&ConcurrentMode)){return;}var tag=fiber.tag;if(tag!==IndeterminateComponent&&tag!==HostRoot&&tag!==ClassComponent&&tag!==FunctionComponent&&tag!==ForwardRef&&tag!==MemoComponent&&tag!==SimpleMemoComponent){// Only warn for user-defined components, not internal ones like Suspense.\nreturn;}// We show the whole stack but dedupe on the top component's name because\n// the problematic code almost always lies inside that component.\nvar componentName=getComponentNameFromFiber(fiber)||'ReactComponent';if(didWarnStateUpdateForNotYetMountedComponent!==null){if(didWarnStateUpdateForNotYetMountedComponent.has(componentName)){return;}didWarnStateUpdateForNotYetMountedComponent.add(componentName);}else{didWarnStateUpdateForNotYetMountedComponent=new Set([componentName]);}var previousFiber=current;try{setCurrentFiber(fiber);error(\"Can't perform a React state update on a component that hasn't mounted yet. \"+'This indicates that you have a side-effect in your render function that '+'asynchronously later calls tries to update the component. Move this work to '+'useEffect instead.');}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}var beginWork$1;{var dummyFiber=null;beginWork$1=function beginWork$1(current,unitOfWork,lanes){// If a component throws an error, we replay it again in a synchronously\n// dispatched event, so that the debugger will treat it as an uncaught\n// error See ReactErrorUtils for more information.\n// Before entering the begin phase, copy the work-in-progress onto a dummy\n// fiber. If beginWork throws, we'll use this to reset the state.\nvar originalWorkInProgressCopy=assignFiberPropertiesInDEV(dummyFiber,unitOfWork);try{return beginWork(current,unitOfWork,lanes);}catch(originalError){if(originalError!==null&&_typeof(originalError)==='object'&&typeof originalError.then==='function'){// Don't replay promises. Treat everything else like an error.\nthrow originalError;}// Keep this code in sync with handleError; any changes here must have\n// corresponding changes there.\nresetContextDependencies();resetHooksAfterThrow();// Don't reset current debug fiber, since we're about to work on the\n// same fiber again.\n// Unwind the failed stack frame\nunwindInterruptedWork(current,unitOfWork);// Restore the original properties of the fiber.\nassignFiberPropertiesInDEV(unitOfWork,originalWorkInProgressCopy);if(unitOfWork.mode&ProfileMode){// Reset the profiler timer.\nstartProfilerTimer(unitOfWork);}// Run beginWork again.\ninvokeGuardedCallback(null,beginWork,null,current,unitOfWork,lanes);if(hasCaughtError()){var replayError=clearCaughtError();if(_typeof(replayError)==='object'&&replayError!==null&&replayError._suppressLogging&&_typeof(originalError)==='object'&&originalError!==null&&!originalError._suppressLogging){// If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\noriginalError._suppressLogging=true;}}// We always throw the original error in case the second render pass is not idempotent.\n// This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\nthrow originalError;}};}var didWarnAboutUpdateInRender=false;var didWarnAboutUpdateInRenderForAnotherComponent;{didWarnAboutUpdateInRenderForAnotherComponent=new Set();}function warnAboutRenderPhaseUpdatesInDEV(fiber){{if(isRendering&&!getIsUpdatingOpaqueValueInRenderPhaseInDEV()){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{var renderingComponentName=workInProgress&&getComponentNameFromFiber(workInProgress)||'Unknown';// Dedupe by the rendering component because it's the one that needs to be fixed.\nvar dedupeKey=renderingComponentName;if(!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)){didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);var setStateComponentName=getComponentNameFromFiber(fiber)||'Unknown';error('Cannot update a component (`%s`) while rendering a '+'different component (`%s`). To locate the bad setState() call inside `%s`, '+'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',setStateComponentName,renderingComponentName,renderingComponentName);}break;}case ClassComponent:{if(!didWarnAboutUpdateInRender){error('Cannot update during an existing state transition (such as '+'within `render`). Render methods should be a pure '+'function of props and state.');didWarnAboutUpdateInRender=true;}break;}}}}}function restorePendingUpdaters(root,lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;memoizedUpdaters.forEach(function(schedulingFiber){addFiberToLanesMap(root,schedulingFiber,lanes);});// This function intentionally does not clear memoized updaters.\n// Those may still be relevant to the current commit\n// and a future one (e.g. Suspense).\n}}}var fakeActCallbackNode={};function scheduleCallback$1(priorityLevel,callback){{// If we're currently inside an `act` scope, bypass Scheduler and push to\n// the `act` queue instead.\nvar actQueue=ReactCurrentActQueue$1.current;if(actQueue!==null){actQueue.push(callback);return fakeActCallbackNode;}else{return scheduleCallback(priorityLevel,callback);}}}function cancelCallback$1(callbackNode){if(callbackNode===fakeActCallbackNode){return;}// In production, always call Scheduler. This function will be stripped out.\nreturn cancelCallback(callbackNode);}function shouldForceFlushFallbacksInDEV(){// Never force flush in production. This function should get stripped out.\nreturn ReactCurrentActQueue$1.current!==null;}function warnIfUpdatesNotWrappedWithActDEV(fiber){{if(fiber.mode&ConcurrentMode){if(!isConcurrentActEnvironment()){// Not in an act environment. No need to warn.\nreturn;}}else{// Legacy mode has additional cases where we suppress a warning.\nif(!isLegacyActEnvironment()){// Not in an act environment. No need to warn.\nreturn;}if(executionContext!==NoContext){// Legacy mode doesn't warn if the update is batched, i.e.\n// batchedUpdates or flushSync.\nreturn;}if(fiber.tag!==FunctionComponent&&fiber.tag!==ForwardRef&&fiber.tag!==SimpleMemoComponent){// For backwards compatibility with pre-hooks code, legacy mode only\n// warns for updates that originate from a hook.\nreturn;}}if(ReactCurrentActQueue$1.current===null){var previousFiber=current;try{setCurrentFiber(fiber);error('An update to %s inside a test was not wrapped in act(...).\\n\\n'+'When testing, code that causes React state updates should be '+'wrapped into act(...):\\n\\n'+'act(() => {\\n'+'  /* fire events that update state */\\n'+'});\\n'+'/* assert on the output */\\n\\n'+\"This ensures that you're testing the behavior the user would see \"+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act',getComponentNameFromFiber(fiber));}finally{if(previousFiber){setCurrentFiber(fiber);}else{resetCurrentFiber();}}}}}function warnIfSuspenseResolutionNotWrappedWithActDEV(root){{if(root.tag!==LegacyRoot&&isConcurrentActEnvironment()&&ReactCurrentActQueue$1.current===null){error('A suspended resource finished loading inside a test, but the event '+'was not wrapped in act(...).\\n\\n'+'When testing, code that resolves suspended data should be wrapped '+'into act(...):\\n\\n'+'act(() => {\\n'+'  /* finish loading suspended data */\\n'+'});\\n'+'/* assert on the output */\\n\\n'+\"This ensures that you're testing the behavior the user would see \"+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act');}}}/* eslint-disable react-internal/prod-error-codes */var resolveFamily=null;// $FlowFixMe Flow gets confused by a WeakSet feature check below.\nvar failedBoundaries=null;var setRefreshHandler=function setRefreshHandler(handler){{resolveFamily=handler;}};function resolveFunctionForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn type;}var family=resolveFamily(type);if(family===undefined){return type;}// Use the latest known implementation.\nreturn family.current;}}function resolveClassForHotReloading(type){// No implementation differences.\nreturn resolveFunctionForHotReloading(type);}function resolveForwardRefForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn type;}var family=resolveFamily(type);if(family===undefined){// Check if we're dealing with a real forwardRef. Don't want to crash early.\nif(type!==null&&type!==undefined&&typeof type.render==='function'){// ForwardRef is special because its resolved .type is an object,\n// but it's possible that we only have its inner render function in the map.\n// If that inner render function is different, we'll build a new forwardRef type.\nvar currentRender=resolveFunctionForHotReloading(type.render);if(type.render!==currentRender){var syntheticType={$$typeof:REACT_FORWARD_REF_TYPE,render:currentRender};if(type.displayName!==undefined){syntheticType.displayName=type.displayName;}return syntheticType;}}return type;}// Use the latest known implementation.\nreturn family.current;}}function isCompatibleFamilyForHotReloading(fiber,element){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn false;}var prevType=fiber.elementType;var nextType=element.type;// If we got here, we know types aren't === equal.\nvar needsCompareFamilies=false;var $$typeofNextType=_typeof(nextType)==='object'&&nextType!==null?nextType.$$typeof:null;switch(fiber.tag){case ClassComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}break;}case FunctionComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){// We don't know the inner type yet.\n// We're going to assume that the lazy inner type is stable,\n// and so it is sufficient to avoid reconciling it away.\n// We're not going to unwrap or actually use the new lazy type.\nneedsCompareFamilies=true;}break;}case ForwardRef:{if($$typeofNextType===REACT_FORWARD_REF_TYPE){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}case MemoComponent:case SimpleMemoComponent:{if($$typeofNextType===REACT_MEMO_TYPE){// TODO: if it was but can no longer be simple,\n// we shouldn't set this.\nneedsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}default:return false;}// Check if both types have a family and it's the same one.\nif(needsCompareFamilies){// Note: memo() and forwardRef() we'll compare outer rather than inner type.\n// This means both of them need to be registered to preserve state.\n// If we unwrapped and compared the inner types for wrappers instead,\n// then we would risk falsely saying two separate memo(Foo)\n// calls are equivalent because they wrap the same Foo function.\nvar prevFamily=resolveFamily(prevType);if(prevFamily!==undefined&&prevFamily===resolveFamily(nextType)){return true;}}return false;}}function markFailedErrorBoundaryForHotReloading(fiber){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn;}if(typeof WeakSet!=='function'){return;}if(failedBoundaries===null){failedBoundaries=new WeakSet();}failedBoundaries.add(fiber);}}var scheduleRefresh=function scheduleRefresh(root,update){{if(resolveFamily===null){// Hot reloading is disabled.\nreturn;}var staleFamilies=update.staleFamilies,updatedFamilies=update.updatedFamilies;flushPassiveEffects();flushSync(function(){scheduleFibersWithFamiliesRecursively(root.current,updatedFamilies,staleFamilies);});}};var scheduleRoot=function scheduleRoot(root,element){{if(root.context!==emptyContextObject){// Super edge case: root has a legacy _renderSubtree context\n// but we don't know the parentComponent so we can't pass it.\n// Just ignore. We'll delete this with _renderSubtree code path later.\nreturn;}flushPassiveEffects();flushSync(function(){updateContainer(element,root,null,null);});}};function scheduleFibersWithFamiliesRecursively(fiber,updatedFamilies,staleFamilies){{var alternate=fiber.alternate,child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}if(resolveFamily===null){throw new Error('Expected resolveFamily to be set during hot reload.');}var needsRender=false;var needsRemount=false;if(candidateType!==null){var family=resolveFamily(candidateType);if(family!==undefined){if(staleFamilies.has(family)){needsRemount=true;}else if(updatedFamilies.has(family)){if(tag===ClassComponent){needsRemount=true;}else{needsRender=true;}}}}if(failedBoundaries!==null){if(failedBoundaries.has(fiber)||alternate!==null&&failedBoundaries.has(alternate)){needsRemount=true;}}if(needsRemount){fiber._debugNeedsRemount=true;}if(needsRemount||needsRender){scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);}if(child!==null&&!needsRemount){scheduleFibersWithFamiliesRecursively(child,updatedFamilies,staleFamilies);}if(sibling!==null){scheduleFibersWithFamiliesRecursively(sibling,updatedFamilies,staleFamilies);}}}var findHostInstancesForRefresh=function findHostInstancesForRefresh(root,families){{var hostInstances=new Set();var types=new Set(families.map(function(family){return family.current;}));findHostInstancesForMatchingFibersRecursively(root.current,types,hostInstances);return hostInstances;}};function findHostInstancesForMatchingFibersRecursively(fiber,types,hostInstances){{var child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}var didMatch=false;if(candidateType!==null){if(types.has(candidateType)){didMatch=true;}}if(didMatch){// We have a match. This only drills down to the closest host components.\n// There's no need to search deeper because for the purpose of giving\n// visual feedback, \"flashing\" outermost parent rectangles is sufficient.\nfindHostInstancesForFiberShallowly(fiber,hostInstances);}else{// If there's no match, maybe there will be one further down in the child tree.\nif(child!==null){findHostInstancesForMatchingFibersRecursively(child,types,hostInstances);}}if(sibling!==null){findHostInstancesForMatchingFibersRecursively(sibling,types,hostInstances);}}}function findHostInstancesForFiberShallowly(fiber,hostInstances){{var foundHostInstances=findChildHostInstancesForFiberShallowly(fiber,hostInstances);if(foundHostInstances){return;}// If we didn't find any host children, fallback to closest host parent.\nvar node=fiber;while(true){switch(node.tag){case HostComponent:hostInstances.add(node.stateNode);return;case HostPortal:hostInstances.add(node.stateNode.containerInfo);return;case HostRoot:hostInstances.add(node.stateNode.containerInfo);return;}if(node[\"return\"]===null){throw new Error('Expected to reach root first.');}node=node[\"return\"];}}}function findChildHostInstancesForFiberShallowly(fiber,hostInstances){{var node=fiber;var foundHostInstances=false;while(true){if(node.tag===HostComponent){// We got a match.\nfoundHostInstances=true;hostInstances.add(node.stateNode);// There may still be more, so keep searching.\n}else if(node.child!==null){node.child[\"return\"]=node;node=node.child;continue;}if(node===fiber){return foundHostInstances;}while(node.sibling===null){if(node[\"return\"]===null||node[\"return\"]===fiber){return foundHostInstances;}node=node[\"return\"];}node.sibling[\"return\"]=node[\"return\"];node=node.sibling;}}return false;}var hasBadMapPolyfill;{hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});/* eslint-disable no-new */new Map([[nonExtensibleObject,null]]);new Set([nonExtensibleObject]);/* eslint-enable no-new */}catch(e){// TODO: Consider warning about bad polyfills\nhasBadMapPolyfill=true;}}function FiberNode(tag,pendingProps,key,mode){// Instance\nthis.tag=tag;this.key=key;this.elementType=null;this.type=null;this.stateNode=null;// Fiber\nthis[\"return\"]=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=pendingProps;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.dependencies=null;this.mode=mode;// Effects\nthis.flags=NoFlags;this.subtreeFlags=NoFlags;this.deletions=null;this.lanes=NoLanes;this.childLanes=NoLanes;this.alternate=null;{// Note: The following is done to avoid a v8 performance cliff.\n//\n// Initializing the fields below to smis and later updating them with\n// double values will cause Fibers to end up having separate shapes.\n// This behavior/bug has something to do with Object.preventExtension().\n// Fortunately this only impacts DEV builds.\n// Unfortunately it makes React unusably slow for some applications.\n// To work around this, initialize the fields below with doubles.\n//\n// Learn more about this here:\n// https://github.com/facebook/react/issues/14365\n// https://bugs.chromium.org/p/v8/issues/detail?id=8538\nthis.actualDuration=Number.NaN;this.actualStartTime=Number.NaN;this.selfBaseDuration=Number.NaN;this.treeBaseDuration=Number.NaN;// It's okay to replace the initial doubles with smis after initialization.\n// This won't trigger the performance cliff mentioned above,\n// and it simplifies other profiler code (including DevTools).\nthis.actualDuration=0;this.actualStartTime=-1;this.selfBaseDuration=0;this.treeBaseDuration=0;}{// This isn't directly used but is handy for debugging internals:\nthis._debugSource=null;this._debugOwner=null;this._debugNeedsRemount=false;this._debugHookTypes=null;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\nvar createFiber=function createFiber(tag,pendingProps,key,mode){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\nreturn new FiberNode(tag,pendingProps,key,mode);};function shouldConstruct$1(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function isSimpleFunctionComponent(type){return typeof type==='function'&&!shouldConstruct$1(type)&&type.defaultProps===undefined;}function resolveLazyComponentTag(Component){if(typeof Component==='function'){return shouldConstruct$1(Component)?ClassComponent:FunctionComponent;}else if(Component!==undefined&&Component!==null){var $$typeof=Component.$$typeof;if($$typeof===REACT_FORWARD_REF_TYPE){return ForwardRef;}if($$typeof===REACT_MEMO_TYPE){return MemoComponent;}}return IndeterminateComponent;}// This is used to create an alternate fiber to do work on.\nfunction createWorkInProgress(current,pendingProps){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll\n// only ever need at most two versions of a tree. We pool the \"other\" unused\n// node that we're free to reuse. This is lazily created to avoid allocating\n// extra objects for things that are never updated. It also allow us to\n// reclaim the extra memory if needed.\nworkInProgress=createFiber(current.tag,pendingProps,current.key,current.mode);workInProgress.elementType=current.elementType;workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields\nworkInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;workInProgress._debugHookTypes=current._debugHookTypes;}workInProgress.alternate=current;current.alternate=workInProgress;}else{workInProgress.pendingProps=pendingProps;// Needed because Blocks store data on type.\nworkInProgress.type=current.type;// We already have an alternate.\n// Reset the effect tag.\nworkInProgress.flags=NoFlags;// The effects are no longer valid.\nworkInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;{// We intentionally reset, rather than copy, actualDuration & actualStartTime.\n// This prevents time from endlessly accumulating in new commits.\n// This has the downside of resetting values for different priority renders,\n// But works for yielding (the common case) and should support resuming.\nworkInProgress.actualDuration=0;workInProgress.actualStartTime=-1;}}// Reset all effects except static ones.\n// Static effects are not specific to a render.\nworkInProgress.flags=current.flags&StaticMask;workInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Clone the dependencies object. This is mutated during the render phase, so\n// it cannot be shared with the current fiber.\nvar currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};// These will be overridden during the parent's reconciliation\nworkInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;{workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}{workInProgress._debugNeedsRemount=current._debugNeedsRemount;switch(workInProgress.tag){case IndeterminateComponent:case FunctionComponent:case SimpleMemoComponent:workInProgress.type=resolveFunctionForHotReloading(current.type);break;case ClassComponent:workInProgress.type=resolveClassForHotReloading(current.type);break;case ForwardRef:workInProgress.type=resolveForwardRefForHotReloading(current.type);break;}}return workInProgress;}// Used to reuse a Fiber for a second pass.\nfunction resetWorkInProgress(workInProgress,renderLanes){// This resets the Fiber to what createFiber or createWorkInProgress would\n// have set the values to before during the first pass. Ideally this wouldn't\n// be necessary but unfortunately many code paths reads from the workInProgress\n// when they should be reading from current and writing to workInProgress.\n// We assume pendingProps, index, key, ref, return are still untouched to\n// avoid doing another reconciliation.\n// Reset the effect flags but keep any Placement tags, since that's something\n// that child fiber is setting, not the reconciliation.\nworkInProgress.flags&=StaticMask|Placement;// The effects are no longer valid.\nvar current=workInProgress.alternate;if(current===null){// Reset to createFiber's initial values.\nworkInProgress.childLanes=NoLanes;workInProgress.lanes=renderLanes;workInProgress.child=null;workInProgress.subtreeFlags=NoFlags;workInProgress.memoizedProps=null;workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.dependencies=null;workInProgress.stateNode=null;{// Note: We don't reset the actualTime counts. It's useful to accumulate\n// actual time across multiple render passes.\nworkInProgress.selfBaseDuration=0;workInProgress.treeBaseDuration=0;}}else{// Reset to the cloned values that createWorkInProgress would've.\nworkInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Needed because Blocks store data on type.\nworkInProgress.type=current.type;// Clone the dependencies object. This is mutated during the render phase, so\n// it cannot be shared with the current fiber.\nvar currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};{// Note: We don't reset the actualTime counts. It's useful to accumulate\n// actual time across multiple render passes.\nworkInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}}return workInProgress;}function createHostRootFiber(tag,isStrictMode,concurrentUpdatesByDefaultOverride){var mode;if(tag===ConcurrentRoot){mode=ConcurrentMode;if(isStrictMode===true){mode|=StrictLegacyMode;{mode|=StrictEffectsMode;}}}else{mode=NoMode;}if(isDevToolsPresent){// Always collect profile timings when DevTools are present.\n// This enables DevTools to start capturing timing at any point–\n// Without some nodes in the tree having empty base times.\nmode|=ProfileMode;}return createFiber(HostRoot,null,null,mode);}function createFiberFromTypeAndProps(type,// React$ElementType\nkey,pendingProps,owner,mode,lanes){var fiberTag=IndeterminateComponent;// The resolved type is set if we know what the final type will be. I.e. it's not lazy.\nvar resolvedType=type;if(typeof type==='function'){if(shouldConstruct$1(type)){fiberTag=ClassComponent;{resolvedType=resolveClassForHotReloading(resolvedType);}}else{{resolvedType=resolveFunctionForHotReloading(resolvedType);}}}else if(typeof type==='string'){fiberTag=HostComponent;}else{getTag:switch(type){case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,mode,lanes,key);case REACT_STRICT_MODE_TYPE:fiberTag=Mode;mode|=StrictLegacyMode;if((mode&ConcurrentMode)!==NoMode){// Strict effects should never run on legacy roots\nmode|=StrictEffectsMode;}break;case REACT_PROFILER_TYPE:return createFiberFromProfiler(pendingProps,mode,lanes,key);case REACT_SUSPENSE_TYPE:return createFiberFromSuspense(pendingProps,mode,lanes,key);case REACT_SUSPENSE_LIST_TYPE:return createFiberFromSuspenseList(pendingProps,mode,lanes,key);case REACT_OFFSCREEN_TYPE:return createFiberFromOffscreen(pendingProps,mode,lanes,key);case REACT_LEGACY_HIDDEN_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_SCOPE_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_CACHE_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_TRACING_MARKER_TYPE:// eslint-disable-next-line no-fallthrough\ncase REACT_DEBUG_TRACING_MODE_TYPE:// eslint-disable-next-line no-fallthrough\ndefault:{if(_typeof(type)==='object'&&type!==null){switch(type.$$typeof){case REACT_PROVIDER_TYPE:fiberTag=ContextProvider;break getTag;case REACT_CONTEXT_TYPE:// This is a consumer\nfiberTag=ContextConsumer;break getTag;case REACT_FORWARD_REF_TYPE:fiberTag=ForwardRef;{resolvedType=resolveForwardRefForHotReloading(resolvedType);}break getTag;case REACT_MEMO_TYPE:fiberTag=MemoComponent;break getTag;case REACT_LAZY_TYPE:fiberTag=LazyComponent;resolvedType=null;break getTag;}}var info='';{if(type===undefined||_typeof(type)==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+\"it's defined in, or you might have mixed up default and \"+'named imports.';}var ownerName=owner?getComponentNameFromFiber(owner):null;if(ownerName){info+='\\n\\nCheck the render method of `'+ownerName+'`.';}}throw new Error('Element type is invalid: expected a string (for built-in '+'components) or a class/function (for composite components) '+(\"but got: \"+(type==null?type:_typeof(type))+\".\"+info));}}}var fiber=createFiber(fiberTag,pendingProps,key,mode);fiber.elementType=type;fiber.type=resolvedType;fiber.lanes=lanes;{fiber._debugOwner=owner;}return fiber;}function createFiberFromElement(element,mode,lanes){var owner=null;{owner=element._owner;}var type=element.type;var key=element.key;var pendingProps=element.props;var fiber=createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,lanes);{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}return fiber;}function createFiberFromFragment(elements,mode,lanes,key){var fiber=createFiber(Fragment,elements,key,mode);fiber.lanes=lanes;return fiber;}function createFiberFromProfiler(pendingProps,mode,lanes,key){{if(typeof pendingProps.id!=='string'){error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.',_typeof(pendingProps.id));}}var fiber=createFiber(Profiler,pendingProps,key,mode|ProfileMode);fiber.elementType=REACT_PROFILER_TYPE;fiber.lanes=lanes;{fiber.stateNode={effectDuration:0,passiveEffectDuration:0};}return fiber;}function createFiberFromSuspense(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromSuspenseList(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseListComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_LIST_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromOffscreen(pendingProps,mode,lanes,key){var fiber=createFiber(OffscreenComponent,pendingProps,key,mode);fiber.elementType=REACT_OFFSCREEN_TYPE;fiber.lanes=lanes;var primaryChildInstance={};fiber.stateNode=primaryChildInstance;return fiber;}function createFiberFromText(content,mode,lanes){var fiber=createFiber(HostText,content,null,mode);fiber.lanes=lanes;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,null,NoMode);fiber.elementType='DELETED';return fiber;}function createFiberFromDehydratedFragment(dehydratedNode){var fiber=createFiber(DehydratedFragment,null,null,NoMode);fiber.stateNode=dehydratedNode;return fiber;}function createFiberFromPortal(portal,mode,lanes){var pendingProps=portal.children!==null?portal.children:[];var fiber=createFiber(HostPortal,pendingProps,portal.key,mode);fiber.lanes=lanes;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates\nimplementation:portal.implementation};return fiber;}// Used for stashing WIP properties to replay failed work in DEV.\nfunction assignFiberPropertiesInDEV(target,source){if(target===null){// This Fiber's initial properties will always be overwritten.\n// We only use a Fiber to ensure the same hidden class so DEV isn't slow.\ntarget=createFiber(IndeterminateComponent,null,null,NoMode);}// This is intentionally written as a list of all properties.\n// We tried to use Object.assign() instead but this is called in\n// the hottest path, and Object.assign() was too slow:\n// https://github.com/facebook/react/issues/12502\n// This code is DEV-only so size is not a concern.\ntarget.tag=source.tag;target.key=source.key;target.elementType=source.elementType;target.type=source.type;target.stateNode=source.stateNode;target[\"return\"]=source[\"return\"];target.child=source.child;target.sibling=source.sibling;target.index=source.index;target.ref=source.ref;target.pendingProps=source.pendingProps;target.memoizedProps=source.memoizedProps;target.updateQueue=source.updateQueue;target.memoizedState=source.memoizedState;target.dependencies=source.dependencies;target.mode=source.mode;target.flags=source.flags;target.subtreeFlags=source.subtreeFlags;target.deletions=source.deletions;target.lanes=source.lanes;target.childLanes=source.childLanes;target.alternate=source.alternate;{target.actualDuration=source.actualDuration;target.actualStartTime=source.actualStartTime;target.selfBaseDuration=source.selfBaseDuration;target.treeBaseDuration=source.treeBaseDuration;}target._debugSource=source._debugSource;target._debugOwner=source._debugOwner;target._debugNeedsRemount=source._debugNeedsRemount;target._debugHookTypes=source._debugHookTypes;return target;}function FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError){this.tag=tag;this.containerInfo=containerInfo;this.pendingChildren=null;this.current=null;this.pingCache=null;this.finishedWork=null;this.timeoutHandle=noTimeout;this.context=null;this.pendingContext=null;this.callbackNode=null;this.callbackPriority=NoLane;this.eventTimes=createLaneMap(NoLanes);this.expirationTimes=createLaneMap(NoTimestamp);this.pendingLanes=NoLanes;this.suspendedLanes=NoLanes;this.pingedLanes=NoLanes;this.expiredLanes=NoLanes;this.mutableReadLanes=NoLanes;this.finishedLanes=NoLanes;this.entangledLanes=NoLanes;this.entanglements=createLaneMap(NoLanes);this.identifierPrefix=identifierPrefix;this.onRecoverableError=onRecoverableError;{this.mutableSourceEagerHydrationData=null;}{this.effectDuration=0;this.passiveEffectDuration=0;}{this.memoizedUpdaters=new Set();var pendingUpdatersLaneMap=this.pendingUpdatersLaneMap=[];for(var _i=0;_i<TotalLanes;_i++){pendingUpdatersLaneMap.push(new Set());}}{switch(tag){case ConcurrentRoot:this._debugRootType=hydrate?'hydrateRoot()':'createRoot()';break;case LegacyRoot:this._debugRootType=hydrate?'hydrate()':'render()';break;}}}function createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,// TODO: We have several of these arguments that are conceptually part of the\n// host config, but because they are passed in at runtime, we have to thread\n// them through the root constructor. Perhaps we should put them all into a\n// single type, like a DynamicHostConfig that is defined by the renderer.\nidentifierPrefix,onRecoverableError,transitionCallbacks){var root=new FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError);// stateNode is any.\nvar uninitializedFiber=createHostRootFiber(tag,isStrictMode);root.current=uninitializedFiber;uninitializedFiber.stateNode=root;{var _initialState={element:initialChildren,isDehydrated:hydrate,cache:null,// not enabled yet\ntransitions:null};uninitializedFiber.memoizedState=_initialState;}initializeUpdateQueue(uninitializedFiber);return root;}var ReactVersion='18.0.0-fc46dba67-20220329';function createPortal(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.\nimplementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;{checkKeyStringCoercion(key);}return{// This tag allow us to uniquely identify this as a React Portal\n$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}var didWarnAboutNestedUpdates;var didWarnAboutFindNodeInStrictMode;{didWarnAboutNestedUpdates=false;didWarnAboutFindNodeInStrictMode={};}function getContextForSubtree(parentComponent){if(!parentComponent){return emptyContextObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);if(fiber.tag===ClassComponent){var Component=fiber.type;if(isContextProvider(Component)){return processChildContext(fiber,Component,parentContext);}}return parentContext;}function findHostInstanceWithWarning(component,methodName){{var fiber=get(component);if(fiber===undefined){if(typeof component.render==='function'){throw new Error('Unable to find node on an unmounted component.');}else{var keys=Object.keys(component).join(',');throw new Error(\"Argument appears to not be a ReactComponent. Keys: \"+keys);}}var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}if(hostFiber.mode&StrictLegacyMode){var componentName=getComponentNameFromFiber(fiber)||'Component';if(!didWarnAboutFindNodeInStrictMode[componentName]){didWarnAboutFindNodeInStrictMode[componentName]=true;var previousFiber=current;try{setCurrentFiber(hostFiber);if(fiber.mode&StrictLegacyMode){error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which is inside StrictMode. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}else{error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which renders StrictMode children. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}}finally{// Ideally this should reset to previous but this shouldn't be called in\n// render and there's another warning for that anyway.\nif(previousFiber){setCurrentFiber(previousFiber);}else{resetCurrentFiber();}}}}return hostFiber.stateNode;}}function createContainer(containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=false;var initialChildren=null;return createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);}function createHydrationContainer(initialChildren,// TODO: Remove `callback` when we delete legacy mode.\ncallback,containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=true;var root=createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);// TODO: Move this to FiberRoot constructor\nroot.context=getContextForSubtree(null);// Schedule the initial render. In a hydration root, this is different from\n// a regular update because the initial render must match was was rendered\n// on the server.\n// NOTE: This update intentionally doesn't have a payload. We're only using\n// the update to schedule work on the root fiber (and, for legacy roots, to\n// enqueue the callback if one is provided).\nvar current=root.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current);var update=createUpdate(eventTime,lane);update.callback=callback!==undefined&&callback!==null?callback:null;enqueueUpdate(current,update);scheduleInitialHydrationOnRoot(root,lane,eventTime);return root;}function updateContainer(element,container,parentComponent,callback){{onScheduleRoot(container,element);}var current$1=container.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current$1);{markRenderScheduled(lane);}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}{if(isRendering&&current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;error('Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\\n\\n'+'Check the render method of %s.',getComponentNameFromFiber(current)||'Unknown');}}var update=createUpdate(eventTime,lane);// Caution: React DevTools currently depends on this property\n// being called \"element\".\nupdate.payload={element:element};callback=callback===undefined?null:callback;if(callback!==null){{if(typeof callback!=='function'){error('render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}}update.callback=callback;}enqueueUpdate(current$1,update);var root=scheduleUpdateOnFiber(current$1,lane,eventTime);if(root!==null){entangleTransitions(root,current$1,lane);}return lane;}function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}}function attemptSynchronousHydration$1(fiber){switch(fiber.tag){case HostRoot:var root=fiber.stateNode;if(isRootDehydrated(root)){// Flush the first scheduled \"update\".\nvar lanes=getHighestPriorityPendingLanes(root);flushRoot(root,lanes);}break;case SuspenseComponent:var eventTime=requestEventTime();flushSync(function(){return scheduleUpdateOnFiber(fiber,SyncLane,eventTime);});// If we're still blocked after this, we need to increase\n// the priority of any promises resolving within this\n// boundary so that they next attempt also has higher pri.\nvar retryLane=SyncLane;markRetryLaneIfNotHydrated(fiber,retryLane);break;}}function markRetryLaneImpl(fiber,retryLane){var suspenseState=fiber.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){suspenseState.retryLane=higherPriorityLane(suspenseState.retryLane,retryLane);}}// Increases the priority of thenables when they resolve within this boundary.\nfunction markRetryLaneIfNotHydrated(fiber,retryLane){markRetryLaneImpl(fiber,retryLane);var alternate=fiber.alternate;if(alternate){markRetryLaneImpl(alternate,retryLane);}}function attemptContinuousHydration$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase\n// their priority and they should not suspend on I/O,\n// since you have to wrap anything that might suspend in\n// Suspense.\nreturn;}var eventTime=requestEventTime();var lane=SelectiveHydrationLane;scheduleUpdateOnFiber(fiber,lane,eventTime);markRetryLaneIfNotHydrated(fiber,lane);}function attemptHydrationAtCurrentPriority$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase\n// their priority other than synchronously flush it.\nreturn;}var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);scheduleUpdateOnFiber(fiber,lane,eventTime);markRetryLaneIfNotHydrated(fiber,lane);}function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}var shouldErrorImpl=function shouldErrorImpl(fiber){return null;};function shouldError(fiber){return shouldErrorImpl(fiber);}var shouldSuspendImpl=function shouldSuspendImpl(fiber){return false;};function shouldSuspend(fiber){return shouldSuspendImpl(fiber);}var overrideHookState=null;var overrideHookStateDeletePath=null;var overrideHookStateRenamePath=null;var overrideProps=null;var overridePropsDeletePath=null;var overridePropsRenamePath=null;var scheduleUpdate=null;var setErrorHandler=null;var setSuspenseHandler=null;{var copyWithDeleteImpl=function copyWithDeleteImpl(obj,path,index){var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===path.length){if(isArray(updated)){updated.splice(key,1);}else{delete updated[key];}return updated;}// $FlowFixMe number or string is fine here\nupdated[key]=copyWithDeleteImpl(obj[key],path,index+1);return updated;};var copyWithDelete=function copyWithDelete(obj,path){return copyWithDeleteImpl(obj,path,0);};var copyWithRenameImpl=function copyWithRenameImpl(obj,oldPath,newPath,index){var oldKey=oldPath[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===oldPath.length){var newKey=newPath[index];// $FlowFixMe number or string is fine here\nupdated[newKey]=updated[oldKey];if(isArray(updated)){updated.splice(oldKey,1);}else{delete updated[oldKey];}}else{// $FlowFixMe number or string is fine here\nupdated[oldKey]=copyWithRenameImpl(// $FlowFixMe number or string is fine here\nobj[oldKey],oldPath,newPath,index+1);}return updated;};var copyWithRename=function copyWithRename(obj,oldPath,newPath){if(oldPath.length!==newPath.length){warn('copyWithRename() expects paths of the same length');return;}else{for(var i=0;i<newPath.length-1;i++){if(oldPath[i]!==newPath[i]){warn('copyWithRename() expects paths to be the same except for the deepest key');return;}}}return copyWithRenameImpl(obj,oldPath,newPath,0);};var copyWithSetImpl=function copyWithSetImpl(obj,path,index,value){if(index>=path.length){return value;}var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);// $FlowFixMe number or string is fine here\nupdated[key]=copyWithSetImpl(obj[key],path,index+1,value);return updated;};var copyWithSet=function copyWithSet(obj,path,value){return copyWithSetImpl(obj,path,0,value);};var findHook=function findHook(fiber,id){// For now, the \"id\" of stateful hooks is just the stateful hook index.\n// This may change in the future with e.g. nested hooks.\nvar currentHook=fiber.memoizedState;while(currentHook!==null&&id>0){currentHook=currentHook.next;id--;}return currentHook;};// Support DevTools editable values for useState and useReducer.\noverrideHookState=function overrideHookState(fiber,id,path,value){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithSet(hook.memoizedState,path,value);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);}};overrideHookStateDeletePath=function overrideHookStateDeletePath(fiber,id,path){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithDelete(hook.memoizedState,path);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);}};overrideHookStateRenamePath=function overrideHookStateRenamePath(fiber,id,oldPath,newPath){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithRename(hook.memoizedState,oldPath,newPath);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n// because there is no update we can add for useReducer hooks that won't trigger an error.\n// (There's no appropriate action type for DevTools overrides.)\n// As a result though, React will see the scheduled update as a noop and bailout.\n// Shallow cloning props works as a workaround for now to bypass the bailout check.\nfiber.memoizedProps=assign({},fiber.memoizedProps);scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);}};// Support DevTools props for function components, forwardRef, memo, host components, etc.\noverrideProps=function overrideProps(fiber,path,value){fiber.pendingProps=copyWithSet(fiber.memoizedProps,path,value);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);};overridePropsDeletePath=function overridePropsDeletePath(fiber,path){fiber.pendingProps=copyWithDelete(fiber.memoizedProps,path);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);};overridePropsRenamePath=function overridePropsRenamePath(fiber,oldPath,newPath){fiber.pendingProps=copyWithRename(fiber.memoizedProps,oldPath,newPath);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);};scheduleUpdate=function scheduleUpdate(fiber){scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp);};setErrorHandler=function setErrorHandler(newShouldErrorImpl){shouldErrorImpl=newShouldErrorImpl;};setSuspenseHandler=function setSuspenseHandler(newShouldSuspendImpl){shouldSuspendImpl=newShouldSuspendImpl;};}function findHostInstanceByFiber(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}function emptyFindFiberByHostInstance(instance){return null;}function getCurrentFiberForDevTools(){return current;}function injectIntoDevTools(devToolsConfig){var findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;return injectInternals({bundleType:devToolsConfig.bundleType,version:devToolsConfig.version,rendererPackageName:devToolsConfig.rendererPackageName,rendererConfig:devToolsConfig.rendererConfig,overrideHookState:overrideHookState,overrideHookStateDeletePath:overrideHookStateDeletePath,overrideHookStateRenamePath:overrideHookStateRenamePath,overrideProps:overrideProps,overridePropsDeletePath:overridePropsDeletePath,overridePropsRenamePath:overridePropsRenamePath,setErrorHandler:setErrorHandler,setSuspenseHandler:setSuspenseHandler,scheduleUpdate:scheduleUpdate,currentDispatcherRef:ReactCurrentDispatcher,findHostInstanceByFiber:findHostInstanceByFiber,findFiberByHostInstance:findFiberByHostInstance||emptyFindFiberByHostInstance,// React Refresh\nfindHostInstancesForRefresh:findHostInstancesForRefresh,scheduleRefresh:scheduleRefresh,scheduleRoot:scheduleRoot,setRefreshHandler:setRefreshHandler,// Enables DevTools to append owner stacks to error messages in DEV mode.\ngetCurrentFiber:getCurrentFiberForDevTools,// Enables DevTools to detect reconciler version rather than renderer version\n// which may not match for third party renderers.\nreconcilerVersion:ReactVersion});}/* global reportError */var defaultOnRecoverableError=typeof reportError==='function'?// In modern browsers, reportError will dispatch an error event,\n// emulating an uncaught JavaScript error.\nreportError:function(error){// In older browsers and test environments, fallback to console.error.\n// eslint-disable-next-line react-internal/no-production-logging\nconsole['error'](error);};function ReactDOMRoot(internalRoot){this._internalRoot=internalRoot;}ReactDOMHydrationRoot.prototype.render=ReactDOMRoot.prototype.render=function(children){var root=this._internalRoot;if(root===null){throw new Error('Cannot update an unmounted root.');}{if(typeof arguments[1]==='function'){error('render(...): does not support the second callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}else if(isValidContainer(arguments[1])){error('You passed a container to the second argument of root.render(...). '+\"You don't need to pass it again since you already passed it to create the root.\");}else if(typeof arguments[1]!=='undefined'){error('You passed a second argument to root.render(...) but it only accepts '+'one argument.');}var container=root.containerInfo;if(container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(root.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of the '+'root container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+\"root.unmount() to empty a root's container.\");}}}}updateContainer(children,root,null,null);};ReactDOMHydrationRoot.prototype.unmount=ReactDOMRoot.prototype.unmount=function(){{if(typeof arguments[0]==='function'){error('unmount(...): does not support a callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}}var root=this._internalRoot;if(root!==null){this._internalRoot=null;var container=root.containerInfo;{if(isAlreadyRendering()){error('Attempted to synchronously unmount a root while React was already '+'rendering. React cannot finish unmounting the root until the '+'current render has completed, which may lead to a race condition.');}}flushSync(function(){updateContainer(null,root,null,null);});unmarkContainerAsRoot(container);}};function createRoot(container,options){if(!isValidContainer(container)){throw new Error('createRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;var transitionCallbacks=null;if(options!==null&&options!==undefined){{if(options.hydrate){warn('hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.');}else{if(_typeof(options)==='object'&&options!==null&&options.$$typeof===REACT_ELEMENT_TYPE){error('You passed a JSX element to createRoot. You probably meant to '+'call root.render instead. '+'Example usage:\\n\\n'+'  let root = createRoot(domContainer);\\n'+'  root.render(<App />);');}}}if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}if(options.transitionCallbacks!==undefined){transitionCallbacks=options.transitionCallbacks;}}var root=createContainer(container,ConcurrentRoot,null,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);return new ReactDOMRoot(root);}function ReactDOMHydrationRoot(internalRoot){this._internalRoot=internalRoot;}function scheduleHydration(target){if(target){queueExplicitHydrationTarget(target);}}ReactDOMHydrationRoot.prototype.unstable_scheduleHydration=scheduleHydration;function hydrateRoot(container,initialChildren,options){if(!isValidContainer(container)){throw new Error('hydrateRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);{if(initialChildren===undefined){error('Must provide initial children as second argument to hydrateRoot. '+'Example usage: hydrateRoot(domContainer, <App />)');}}// For now we reuse the whole bag of options since they contain\n// the hydration callbacks.\nvar hydrationCallbacks=options!=null?options:null;// TODO: Delete this option\nvar mutableSources=options!=null&&options.hydratedSources||null;var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;if(options!==null&&options!==undefined){if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}}var root=createHydrationContainer(initialChildren,null,container,ConcurrentRoot,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);// This can't be a comment node since hydration doesn't work on comment nodes anyway.\nlistenToAllSupportedEvents(container);if(mutableSources){for(var i=0;i<mutableSources.length;i++){var mutableSource=mutableSources[i];registerMutableSourceForHydration(root,mutableSource);}}return new ReactDOMHydrationRoot(root);}function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||!disableCommentsAsDOMContainers));}// TODO: Remove this function which also includes comment nodes.\n// We only use it in places that are currently more relaxed.\nfunction isValidContainerLegacy(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function warnIfReactDOMContainerInDEV(container){{if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('createRoot(): Creating roots directly with document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try using a container element created '+'for your app.');}if(isContainerMarkedAsRoot(container)){if(container._reactRootContainer){error('You are calling ReactDOMClient.createRoot() on a container that was previously '+'passed to ReactDOM.render(). This is not supported.');}else{error('You are calling ReactDOMClient.createRoot() on a container that '+'has already been passed to createRoot() before. Instead, call '+'root.render() on the existing root instead if you want to update it.');}}}}var ReactCurrentOwner$3=ReactSharedInternals.ReactCurrentOwner;var topLevelUpdateWarnings;{topLevelUpdateWarnings=function topLevelUpdateWarnings(container){if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(container._reactRootContainer.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode(rootEl));if(hasNonRootReactChild&&!isRootRenderedBySomeReact){error('render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');}if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}};}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function noopOnRecoverableError(){// This isn't reachable because onRecoverableError isn't called in the\n// legacy API.\n}function legacyCreateRootFromDOMContainer(container,initialChildren,parentComponent,callback,isHydrationContainer){if(isHydrationContainer){if(typeof callback==='function'){var originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}var root=createHydrationContainer(initialChildren,callback,container,LegacyRoot,null,// hydrationCallbacks\nfalse,// isStrictMode\nfalse,// concurrentUpdatesByDefaultOverride,\n'',// identifierPrefix\nnoopOnRecoverableError);container._reactRootContainer=root;markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);flushSync();return root;}else{// First clear any existing content.\nvar rootSibling;while(rootSibling=container.lastChild){container.removeChild(rootSibling);}if(typeof callback==='function'){var _originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(_root);_originalCallback.call(instance);};}var _root=createContainer(container,LegacyRoot,null,// hydrationCallbacks\nfalse,// isStrictMode\nfalse,// concurrentUpdatesByDefaultOverride,\n'',// identifierPrefix\nnoopOnRecoverableError);container._reactRootContainer=_root;markContainerAsRoot(_root.current,container);var _rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(_rootContainerElement);// Initial mount should not be batched.\nflushSync(function(){updateContainer(initialChildren,_root,parentComponent,callback);});return _root;}}function warnOnInvalidCallback$1(callback,callerName){{if(callback!==null&&typeof callback!=='function'){error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}}}function legacyRenderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){{topLevelUpdateWarnings(container);warnOnInvalidCallback$1(callback===undefined?null:callback,'render');}var maybeRoot=container._reactRootContainer;var root;if(!maybeRoot){// Initial mount\nroot=legacyCreateRootFromDOMContainer(container,children,parentComponent,callback,forceHydrate);}else{root=maybeRoot;if(typeof callback==='function'){var originalCallback=callback;callback=function callback(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}// Update\nupdateContainer(children,root,parentComponent,callback);}return getPublicRootInstance(root);}function findDOMNode(componentOrElement){{var owner=ReactCurrentOwner$3.current;if(owner!==null&&owner.stateNode!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;if(!warnedAboutRefsInRender){error('%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromType(owner.type)||'A component');}owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}{return findHostInstanceWithWarning(componentOrElement,'findDOMNode');}}function hydrate(element,container,callback){{error('ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot '+'instead. Until you switch to the new API, your app will behave as '+\"if it's running React 17. Learn \"+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.hydrate() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call hydrateRoot(container, element)?');}}// TODO: throw or warn if we couldn't hydrate?\nreturn legacyRenderSubtreeIntoContainer(null,element,container,true,callback);}function render(element,container,callback){{error('ReactDOM.render is no longer supported in React 18. Use createRoot '+'instead. Until you switch to the new API, your app will behave as '+\"if it's running React 17. Learn \"+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.render() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call root.render(element)?');}}return legacyRenderSubtreeIntoContainer(null,element,container,false,callback);}function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){{error('ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported '+'in React 18. Consider using a portal instead. Until you switch to '+\"the createRoot API, your app will behave as if it's running React \"+'17. Learn more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(containerNode)){throw new Error('Target container is not a DOM element.');}if(parentComponent==null||!has(parentComponent)){throw new Error('parentComponent must be a valid React Component');}return legacyRenderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);}function unmountComponentAtNode(container){if(!isValidContainerLegacy(container)){throw new Error('unmountComponentAtNode(...): Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?');}}if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode(rootEl);if(renderedByDifferentReact){error(\"unmountComponentAtNode(): The node you're attempting to unmount \"+'was rendered by another copy of React.');}}// Unmount should not be batched.\nflushSync(function(){legacyRenderSubtreeIntoContainer(null,null,container,false,function(){// $FlowFixMe This should probably use `delete container._reactRootContainer`\ncontainer._reactRootContainer=null;unmarkContainerAsRoot(container);});});// If you call unmountComponentAtNode twice in quick succession, you'll\n// get `true` twice. That's probably fine?\nreturn true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode(_rootEl));// Check if the container itself is a React root node.\nvar isContainerReactRoot=container.nodeType===ELEMENT_NODE&&isValidContainerLegacy(container.parentNode)&&!!container.parentNode._reactRootContainer;if(hasNonRootReactChild){error(\"unmountComponentAtNode(): The node you're attempting to unmount \"+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}}return false;}}setAttemptSynchronousHydration(attemptSynchronousHydration$1);setAttemptContinuousHydration(attemptContinuousHydration$1);setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);setGetCurrentUpdatePriority(getCurrentUpdatePriority);setAttemptHydrationAtPriority(runWithPriority);{if(typeof Map!=='function'||// $FlowIssue Flow incorrectly thinks Map has no prototype\nMap.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||// $FlowIssue Flow incorrectly thinks Set has no prototype\nSet.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){error('React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. https://reactjs.org/link/react-polyfills');}}setRestoreImplementation(restoreControlledState$3);setBatchingImplementation(batchedUpdates$1,discreteUpdates,flushSync);function createPortal$1(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(!isValidContainer(container)){throw new Error('Target container is not a DOM element.');}// TODO: pass ReactDOM portal implementation as third argument\n// $FlowFixMe The Flow type is opaque but there's no way to actually create it.\nreturn createPortal(children,container,null,key);}function renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){return unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback);}var Internals={usingClientEntryPoint:false,// Keep in sync with ReactTestUtils.js.\n// This is an array for better minification.\nEvents:[getInstanceFromNode,getNodeFromInstance,getFiberCurrentPropsFromNode,enqueueStateRestore,restoreStateIfNeeded,batchedUpdates$1]};function createRoot$1(container,options){{if(!Internals.usingClientEntryPoint){error('You are importing createRoot from \"react-dom\" which is not supported. '+'You should instead import it from \"react-dom/client\".');}}return createRoot(container,options);}function hydrateRoot$1(container,initialChildren,options){{if(!Internals.usingClientEntryPoint){error('You are importing hydrateRoot from \"react-dom\" which is not supported. '+'You should instead import it from \"react-dom/client\".');}}return hydrateRoot(container,initialChildren,options);}// Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n// eslint-disable-next-line no-redeclare\nfunction flushSync$1(fn){{if(isAlreadyRendering()){error('flushSync was called from inside a lifecycle method. React cannot '+'flush when React is already rendering. Consider moving this call to '+'a scheduler task or micro task.');}}return flushSync(fn);}var foundDevTools=injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.\nif(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.\nif(/^(https?|file):$/.test(protocol)){// eslint-disable-next-line react-internal/no-production-logging\nconsole.info('%cDownload the React DevTools '+'for a better development experience: '+'https://reactjs.org/link/react-devtools'+(protocol==='file:'?'\\nYou might need to use a local HTTP server (instead of file://): '+'https://reactjs.org/link/react-devtools-faq':''),'font-weight:bold');}}}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Internals;exports.createPortal=createPortal$1;exports.createRoot=createRoot$1;exports.findDOMNode=findDOMNode;exports.flushSync=flushSync$1;exports.hydrate=hydrate;exports.hydrateRoot=hydrateRoot$1;exports.render=render;exports.unmountComponentAtNode=unmountComponentAtNode;exports.unstable_batchedUpdates=batchedUpdates$1;exports.unstable_renderSubtreeIntoContainer=renderSubtreeIntoContainer;exports.version=ReactVersion;/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());}})();}\n\n//# sourceURL=webpack://reactappboiler/./node_modules/react-dom/cjs/react-dom.development.js?");

/***/ }),

/***/ "./node_modules/react-dom/client.js":
/*!******************************************!*\
  !*** ./node_modules/react-dom/client.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nvar m = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n\nif (false) {} else {\n  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n  exports.createRoot = function (c, o) {\n    i.usingClientEntryPoint = true;\n\n    try {\n      return m.createRoot(c, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n\n  exports.hydrateRoot = function (c, h, o) {\n    i.usingClientEntryPoint = true;\n\n    try {\n      return m.hydrateRoot(c, h, o);\n    } finally {\n      i.usingClientEntryPoint = false;\n    }\n  };\n}\n\n//# sourceURL=webpack://reactappboiler/./node_modules/react-dom/client.js?");

/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {\n    return;\n  }\n\n  if (true) {\n    // This branch is unreachable because this function is only called\n    // in production, but the condition is true only in development.\n    // Therefore if the branch is still here, dead code elimination wasn't\n    // properly applied.\n    // Don't change the message. React DevTools relies on it. Also make sure\n    // this message doesn't occur elsewhere in this function, or it will cause\n    // a false positive.\n    throw new Error('^_^');\n  }\n\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ \"./node_modules/react-dom/cjs/react-dom.development.js\");\n}\n\n//# sourceURL=webpack://reactappboiler/./node_modules/react-dom/index.js?");

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nif (true) {\n  (function () {\n    'use strict';\n\n    var React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\"); // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types.\n\n\n    var REACT_ELEMENT_TYPE = Symbol[\"for\"]('react.element');\n    var REACT_PORTAL_TYPE = Symbol[\"for\"]('react.portal');\n    var REACT_FRAGMENT_TYPE = Symbol[\"for\"]('react.fragment');\n    var REACT_STRICT_MODE_TYPE = Symbol[\"for\"]('react.strict_mode');\n    var REACT_PROFILER_TYPE = Symbol[\"for\"]('react.profiler');\n    var REACT_PROVIDER_TYPE = Symbol[\"for\"]('react.provider');\n    var REACT_CONTEXT_TYPE = Symbol[\"for\"]('react.context');\n    var REACT_FORWARD_REF_TYPE = Symbol[\"for\"]('react.forward_ref');\n    var REACT_SUSPENSE_TYPE = Symbol[\"for\"]('react.suspense');\n    var REACT_SUSPENSE_LIST_TYPE = Symbol[\"for\"]('react.suspense_list');\n    var REACT_MEMO_TYPE = Symbol[\"for\"]('react.memo');\n    var REACT_LAZY_TYPE = Symbol[\"for\"]('react.lazy');\n    var REACT_OFFSCREEN_TYPE = Symbol[\"for\"]('react.offscreen');\n    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || _typeof(maybeIterable) !== 'object') {\n        return null;\n      }\n\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n\n      return null;\n    }\n\n    var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n    function error(format) {\n      {\n        {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n\n          printWarning('error', format, args);\n        }\n      }\n    }\n\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n        var argsWithFormat = args.map(function (item) {\n          return String(item);\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    } // -----------------------------------------------------------------------------\n\n\n    var enableScopeAPI = false; // Experimental Create Event Handle API.\n\n    var enableCacheElement = false;\n    var enableTransitionTracing = false; // No known bugs, but needs performance testing\n\n    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n    // stuff. Intended to enable React core members to more easily debug scheduling\n    // issues in DEV builds.\n\n    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\n    var REACT_MODULE_REFERENCE = Symbol[\"for\"]('react.module.reference');\n\n    function isValidElementType(type) {\n      if (typeof type === 'string' || typeof type === 'function') {\n        return true;\n      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n        return true;\n      }\n\n      if (_typeof(type) === 'object' && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n        // types supported by any Flight configuration anywhere since\n        // we don't know which Flight build this will end up being used\n        // with.\n        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function getWrappedName(outerType, innerType, wrapperName) {\n      var displayName = outerType.displayName;\n\n      if (displayName) {\n        return displayName;\n      }\n\n      var functionName = innerType.displayName || innerType.name || '';\n      return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n    } // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\n    function getContextName(type) {\n      return type.displayName || 'Context';\n    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\n    function getComponentNameFromType(type) {\n      if (type == null) {\n        // Host root, text node or just invalid type.\n        return null;\n      }\n\n      {\n        if (typeof type.tag === 'number') {\n          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n        }\n      }\n\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n\n      if (typeof type === 'string') {\n        return type;\n      }\n\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return 'Fragment';\n\n        case REACT_PORTAL_TYPE:\n          return 'Portal';\n\n        case REACT_PROFILER_TYPE:\n          return 'Profiler';\n\n        case REACT_STRICT_MODE_TYPE:\n          return 'StrictMode';\n\n        case REACT_SUSPENSE_TYPE:\n          return 'Suspense';\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return 'SuspenseList';\n      }\n\n      if (_typeof(type) === 'object') {\n        switch (type.$$typeof) {\n          case REACT_CONTEXT_TYPE:\n            var context = type;\n            return getContextName(context) + '.Consumer';\n\n          case REACT_PROVIDER_TYPE:\n            var provider = type;\n            return getContextName(provider._context) + '.Provider';\n\n          case REACT_FORWARD_REF_TYPE:\n            return getWrappedName(type, type.render, 'ForwardRef');\n\n          case REACT_MEMO_TYPE:\n            var outerName = type.displayName || null;\n\n            if (outerName !== null) {\n              return outerName;\n            }\n\n            return getComponentNameFromType(type.type) || 'Memo';\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                return getComponentNameFromType(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n          // eslint-disable-next-line no-fallthrough\n        }\n      }\n\n      return null;\n    }\n\n    var assign = Object.assign; // Helpers to patch console.logs to avoid logging during side-effect free\n    // replaying on render function. This currently only patches the object\n    // lazily which won't cover if the log function was extracted eagerly.\n    // We could also eagerly patch the method.\n\n    var disabledDepth = 0;\n    var prevLog;\n    var prevInfo;\n    var prevWarn;\n    var prevError;\n    var prevGroup;\n    var prevGroupCollapsed;\n    var prevGroupEnd;\n\n    function disabledLog() {}\n\n    disabledLog.__reactDisabledLog = true;\n\n    function disableLogs() {\n      {\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          prevLog = console.log;\n          prevInfo = console.info;\n          prevWarn = console.warn;\n          prevError = console.error;\n          prevGroup = console.group;\n          prevGroupCollapsed = console.groupCollapsed;\n          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n          var props = {\n            configurable: true,\n            enumerable: true,\n            value: disabledLog,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            info: props,\n            log: props,\n            warn: props,\n            error: props,\n            group: props,\n            groupCollapsed: props,\n            groupEnd: props\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        disabledDepth++;\n      }\n    }\n\n    function reenableLogs() {\n      {\n        disabledDepth--;\n\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          var props = {\n            configurable: true,\n            enumerable: true,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            log: assign({}, props, {\n              value: prevLog\n            }),\n            info: assign({}, props, {\n              value: prevInfo\n            }),\n            warn: assign({}, props, {\n              value: prevWarn\n            }),\n            error: assign({}, props, {\n              value: prevError\n            }),\n            group: assign({}, props, {\n              value: prevGroup\n            }),\n            groupCollapsed: assign({}, props, {\n              value: prevGroupCollapsed\n            }),\n            groupEnd: assign({}, props, {\n              value: prevGroupEnd\n            })\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        if (disabledDepth < 0) {\n          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n        }\n      }\n    }\n\n    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n    var prefix;\n\n    function describeBuiltInComponentFrame(name, source, ownerFn) {\n      {\n        if (prefix === undefined) {\n          // Extract the VM specific prefix used by each line.\n          try {\n            throw Error();\n          } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || '';\n          }\n        } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n        return '\\n' + prefix + name;\n      }\n    }\n\n    var reentry = false;\n    var componentFrameCache;\n    {\n      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n      componentFrameCache = new PossiblyWeakMap();\n    }\n\n    function describeNativeComponentFrame(fn, construct) {\n      // If something asked for a stack inside a fake render, it should get ignored.\n      if (!fn || reentry) {\n        return '';\n      }\n\n      {\n        var frame = componentFrameCache.get(fn);\n\n        if (frame !== undefined) {\n          return frame;\n        }\n      }\n      var control;\n      reentry = true;\n      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n      Error.prepareStackTrace = undefined;\n      var previousDispatcher;\n      {\n        previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n        // for warnings.\n\n        ReactCurrentDispatcher.current = null;\n        disableLogs();\n      }\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function Fake() {\n            throw Error();\n          }; // $FlowFixMe\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function set() {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            }\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          }\n\n          fn();\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          // This extracts the first frame from the sample that isn't also in the control.\n          // Skipping one frame that we assume is the frame that calls the two.\n          var sampleLines = sample.stack.split('\\n');\n          var controlLines = control.stack.split('\\n');\n          var s = sampleLines.length - 1;\n          var c = controlLines.length - 1;\n\n          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n            // We expect at least one stack frame to be shared.\n            // Typically this will be the root most one. However, stack frames may be\n            // cut off due to maximum stack limits. In this case, one maybe cut off\n            // earlier than the other. We assume that the sample is longer or the same\n            // and there for cut off earlier. So we should find the root most frame in\n            // the sample somewhere in the control.\n            c--;\n          }\n\n          for (; s >= 1 && c >= 0; s--, c--) {\n            // Next we find the first one that isn't the same which should be the\n            // frame that called our sample function and the control.\n            if (sampleLines[s] !== controlLines[c]) {\n              // In V8, the first line is describing the message but other VMs don't.\n              // If we're about to return the first line, and the control is also on the same\n              // line, that's a pretty good indicator that our sample threw at same line as\n              // the control. I.e. before we entered the sample frame. So we ignore this result.\n              // This can happen if you passed a class to function component, or non-function.\n              if (s !== 1 || c !== 1) {\n                do {\n                  s--;\n                  c--; // We may still have similar intermediate frames from the construct call.\n                  // The next one that isn't the same should be our match though.\n\n                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                    // but we have a user-provided \"displayName\"\n                    // splice it in to make the stack more readable.\n\n\n                    if (fn.displayName && _frame.includes('<anonymous>')) {\n                      _frame = _frame.replace('<anonymous>', fn.displayName);\n                    }\n\n                    {\n                      if (typeof fn === 'function') {\n                        componentFrameCache.set(fn, _frame);\n                      }\n                    } // Return the line we found.\n\n                    return _frame;\n                  }\n                } while (s >= 1 && c >= 0);\n              }\n\n              break;\n            }\n          }\n        }\n      } finally {\n        reentry = false;\n        {\n          ReactCurrentDispatcher.current = previousDispatcher;\n          reenableLogs();\n        }\n        Error.prepareStackTrace = previousPrepareStackTrace;\n      } // Fallback to just using the name if we couldn't make it throw.\n\n\n      var name = fn ? fn.displayName || fn.name : '';\n      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n      {\n        if (typeof fn === 'function') {\n          componentFrameCache.set(fn, syntheticFrame);\n        }\n      }\n      return syntheticFrame;\n    }\n\n    function describeFunctionComponentFrame(fn, source, ownerFn) {\n      {\n        return describeNativeComponentFrame(fn, false);\n      }\n    }\n\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n\n    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n      if (type == null) {\n        return '';\n      }\n\n      if (typeof type === 'function') {\n        {\n          return describeNativeComponentFrame(type, shouldConstruct(type));\n        }\n      }\n\n      if (typeof type === 'string') {\n        return describeBuiltInComponentFrame(type);\n      }\n\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame('Suspense');\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame('SuspenseList');\n      }\n\n      if (_typeof(type) === 'object') {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeFunctionComponentFrame(type.render);\n\n          case REACT_MEMO_TYPE:\n            // Memo may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                // Lazy may contain any component type so we recursively resolve it.\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n        }\n      }\n\n      return '';\n    }\n\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var loggedTypeFailures = {};\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    function checkPropTypes(typeSpecs, values, location, componentName, element) {\n      {\n        // $FlowFixMe This is okay but Flow doesn't know it.\n        var has = Function.call.bind(hasOwnProperty);\n\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n            // fail the render phase where it didn't fail before. So we log it.\n            // After these have been cleaned up, we'll let them throw.\n\n            try {\n              // This is intentionally an invariant that gets caught. It's the same\n              // behavior as without this statement except with a better message.\n              if (typeof typeSpecs[typeSpecName] !== 'function') {\n                // eslint-disable-next-line react-internal/prod-error-codes\n                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + _typeof(typeSpecs[typeSpecName]) + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n                err.name = 'Invariant Violation';\n                throw err;\n              }\n\n              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n            } catch (ex) {\n              error$1 = ex;\n            }\n\n            if (error$1 && !(error$1 instanceof Error)) {\n              setCurrentlyValidatingElement(element);\n              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, _typeof(error$1));\n              setCurrentlyValidatingElement(null);\n            }\n\n            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n              // Only monitor this failure once because there tends to be a lot of the\n              // same error.\n              loggedTypeFailures[error$1.message] = true;\n              setCurrentlyValidatingElement(element);\n              error('Failed %s type: %s', location, error$1.message);\n              setCurrentlyValidatingElement(null);\n            }\n          }\n        }\n      }\n    }\n\n    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\n    function isArray(a) {\n      return isArrayImpl(a);\n    }\n    /*\n     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n     *\n     * The functions in this module will throw an easier-to-understand,\n     * easier-to-debug exception with a clear errors message message explaining the\n     * problem. (Instead of a confusing exception thrown inside the implementation\n     * of the `value` object).\n     */\n    // $FlowFixMe only called in DEV, so void return is not possible.\n\n\n    function typeName(value) {\n      {\n        // toStringTag is needed for namespaced types like Temporal.Instant\n        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n        return type;\n      }\n    } // $FlowFixMe only called in DEV, so void return is not possible.\n\n\n    function willCoercionThrow(value) {\n      {\n        try {\n          testStringCoercion(value);\n          return false;\n        } catch (e) {\n          return true;\n        }\n      }\n    }\n\n    function testStringCoercion(value) {\n      // If you ended up here by following an exception call stack, here's what's\n      // happened: you supplied an object or symbol value to React (as a prop, key,\n      // DOM attribute, CSS property, string ref, etc.) and when React tried to\n      // coerce it to a string using `'' + value`, an exception was thrown.\n      //\n      // The most common types that will cause this exception are `Symbol` instances\n      // and Temporal objects like `Temporal.Instant`. But any object that has a\n      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n      // exception. (Library authors do this to prevent users from using built-in\n      // numeric operators like `+` or comparison operators like `>=` because custom\n      // methods are needed to perform accurate arithmetic or comparison.)\n      //\n      // To fix the problem, coerce this object or symbol value to a string before\n      // passing it to React. The most reliable way is usually `String(value)`.\n      //\n      // To find which value is throwing, check the browser or debugger console.\n      // Before this exception was thrown, there should be `console.error` output\n      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n      // problem and how that type was used: key, atrribute, input value prop, etc.\n      // In most cases, this console output also shows the component and its\n      // ancestor components where the exception happened.\n      //\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      return '' + value;\n    }\n\n    function checkKeyStringCoercion(value) {\n      {\n        if (willCoercionThrow(value)) {\n          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n        }\n      }\n    }\n\n    var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true\n    };\n    var specialPropKeyWarningShown;\n    var specialPropRefWarningShown;\n    var didWarnAboutStringRefs;\n    {\n      didWarnAboutStringRefs = {};\n    }\n\n    function hasValidRef(config) {\n      {\n        if (hasOwnProperty.call(config, 'ref')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.ref !== undefined;\n    }\n\n    function hasValidKey(config) {\n      {\n        if (hasOwnProperty.call(config, 'key')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.key !== undefined;\n    }\n\n    function warnIfStringRefCannotBeAutoConverted(config, self) {\n      {\n        if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n          if (!didWarnAboutStringRefs[componentName]) {\n            error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n            didWarnAboutStringRefs[componentName] = true;\n          }\n        }\n      }\n    }\n\n    function defineKeyPropWarningGetter(props, displayName) {\n      {\n        var warnAboutAccessingKey = function warnAboutAccessingKey() {\n          if (!specialPropKeyWarningShown) {\n            specialPropKeyWarningShown = true;\n            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        };\n\n        warnAboutAccessingKey.isReactWarning = true;\n        Object.defineProperty(props, 'key', {\n          get: warnAboutAccessingKey,\n          configurable: true\n        });\n      }\n    }\n\n    function defineRefPropWarningGetter(props, displayName) {\n      {\n        var warnAboutAccessingRef = function warnAboutAccessingRef() {\n          if (!specialPropRefWarningShown) {\n            specialPropRefWarningShown = true;\n            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        };\n\n        warnAboutAccessingRef.isReactWarning = true;\n        Object.defineProperty(props, 'ref', {\n          get: warnAboutAccessingRef,\n          configurable: true\n        });\n      }\n    }\n    /**\n     * Factory method to create a new React element. This no longer adheres to\n     * the class pattern, so do not use new to call it. Also, instanceof check\n     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n     * if something is a React Element.\n     *\n     * @param {*} type\n     * @param {*} props\n     * @param {*} key\n     * @param {string|object} ref\n     * @param {*} owner\n     * @param {*} self A *temporary* helper to detect places where `this` is\n     * different from the `owner` when React.createElement is called, so that we\n     * can warn. We want to get rid of owner and replace string `ref`s with arrow\n     * functions, and as long as `this` and owner are the same, there will be no\n     * change in behavior.\n     * @param {*} source An annotation object (added by a transpiler or otherwise)\n     * indicating filename, line number, and/or other information.\n     * @internal\n     */\n\n\n    var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {\n      var element = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n        // Record the component responsible for creating this element.\n        _owner: owner\n      };\n      {\n        // The validation flag is currently mutative. We put it on\n        // an external backing store so that we can freeze the whole object.\n        // This can be replaced with a WeakMap once they are implemented in\n        // commonly used development environments.\n        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n        // the validation flag non-enumerable (where possible, which should\n        // include every environment we run tests in), so the test framework\n        // ignores it.\n\n        Object.defineProperty(element._store, 'validated', {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: false\n        }); // self and source are DEV only properties.\n\n        Object.defineProperty(element, '_self', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: self\n        }); // Two elements created in two different places should be considered\n        // equal for testing purposes and therefore we hide it from enumeration.\n\n        Object.defineProperty(element, '_source', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: source\n        });\n\n        if (Object.freeze) {\n          Object.freeze(element.props);\n          Object.freeze(element);\n        }\n      }\n      return element;\n    };\n    /**\n     * https://github.com/reactjs/rfcs/pull/107\n     * @param {*} type\n     * @param {object} props\n     * @param {string} key\n     */\n\n\n    function jsxDEV(type, config, maybeKey, source, self) {\n      {\n        var propName; // Reserved names are extracted\n\n        var props = {};\n        var key = null;\n        var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n        // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n        // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n        // but as an intermediary step, we will use jsxDEV for everything except\n        // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n        // key is explicitly declared to be undefined or not.\n\n        if (maybeKey !== undefined) {\n          {\n            checkKeyStringCoercion(maybeKey);\n          }\n          key = '' + maybeKey;\n        }\n\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        }\n\n        if (hasValidRef(config)) {\n          ref = config.ref;\n          warnIfStringRefCannotBeAutoConverted(config, self);\n        } // Remaining properties are added to a new props object\n\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            props[propName] = config[propName];\n          }\n        } // Resolve default props\n\n\n        if (type && type.defaultProps) {\n          var defaultProps = type.defaultProps;\n\n          for (propName in defaultProps) {\n            if (props[propName] === undefined) {\n              props[propName] = defaultProps[propName];\n            }\n          }\n        }\n\n        if (key || ref) {\n          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n          if (key) {\n            defineKeyPropWarningGetter(props, displayName);\n          }\n\n          if (ref) {\n            defineRefPropWarningGetter(props, displayName);\n          }\n        }\n\n        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n      }\n    }\n\n    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement$1(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    var propTypesMisspellWarningShown;\n    {\n      propTypesMisspellWarningShown = false;\n    }\n    /**\n     * Verifies the object is a ReactElement.\n     * See https://reactjs.org/docs/react-api.html#isvalidelement\n     * @param {?object} object\n     * @return {boolean} True if `object` is a ReactElement.\n     * @final\n     */\n\n    function isValidElement(object) {\n      {\n        return _typeof(object) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n      }\n    }\n\n    function getDeclarationErrorAddendum() {\n      {\n        if (ReactCurrentOwner$1.current) {\n          var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n          if (name) {\n            return '\\n\\nCheck the render method of `' + name + '`.';\n          }\n        }\n\n        return '';\n      }\n    }\n\n    function getSourceInfoErrorAddendum(source) {\n      {\n        if (source !== undefined) {\n          var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n          var lineNumber = source.lineNumber;\n          return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n        }\n\n        return '';\n      }\n    }\n    /**\n     * Warn if there's no key explicitly set on dynamic arrays of children or\n     * object keys are not valid. This allows us to keep track of children between\n     * updates.\n     */\n\n\n    var ownerHasKeyUseWarning = {};\n\n    function getCurrentComponentErrorInfo(parentType) {\n      {\n        var info = getDeclarationErrorAddendum();\n\n        if (!info) {\n          var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n          if (parentName) {\n            info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n          }\n        }\n\n        return info;\n      }\n    }\n    /**\n     * Warn if the element doesn't have an explicit key assigned to it.\n     * This element is in an array. The array could grow and shrink or be\n     * reordered. All children that haven't already been validated are required to\n     * have a \"key\" property assigned to it. Error statuses are cached so a warning\n     * will only be shown once.\n     *\n     * @internal\n     * @param {ReactElement} element Element that requires a key.\n     * @param {*} parentType element's parent's type.\n     */\n\n\n    function validateExplicitKey(element, parentType) {\n      {\n        if (!element._store || element._store.validated || element.key != null) {\n          return;\n        }\n\n        element._store.validated = true;\n        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n          return;\n        }\n\n        ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n        // property, it may be the creator of the child that's responsible for\n        // assigning it a key.\n\n        var childOwner = '';\n\n        if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n          // Give the component that originally created this child.\n          childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n        }\n\n        setCurrentlyValidatingElement$1(element);\n        error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n        setCurrentlyValidatingElement$1(null);\n      }\n    }\n    /**\n     * Ensure that every element either is passed in a static location, in an\n     * array with an explicit keys property defined, or in an object literal\n     * with valid key property.\n     *\n     * @internal\n     * @param {ReactNode} node Statically passed child of any type.\n     * @param {*} parentType node's parent's type.\n     */\n\n\n    function validateChildKeys(node, parentType) {\n      {\n        if (_typeof(node) !== 'object') {\n          return;\n        }\n\n        if (isArray(node)) {\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n\n            if (isValidElement(child)) {\n              validateExplicitKey(child, parentType);\n            }\n          }\n        } else if (isValidElement(node)) {\n          // This element was passed in a valid location.\n          if (node._store) {\n            node._store.validated = true;\n          }\n        } else if (node) {\n          var iteratorFn = getIteratorFn(node);\n\n          if (typeof iteratorFn === 'function') {\n            // Entry iterators used to provide implicit keys,\n            // but now we print a separate warning for them later.\n            if (iteratorFn !== node.entries) {\n              var iterator = iteratorFn.call(node);\n              var step;\n\n              while (!(step = iterator.next()).done) {\n                if (isValidElement(step.value)) {\n                  validateExplicitKey(step.value, parentType);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Given an element, validate that its props follow the propTypes definition,\n     * provided by the type.\n     *\n     * @param {ReactElement} element\n     */\n\n\n    function validatePropTypes(element) {\n      {\n        var type = element.type;\n\n        if (type === null || type === undefined || typeof type === 'string') {\n          return;\n        }\n\n        var propTypes;\n\n        if (typeof type === 'function') {\n          propTypes = type.propTypes;\n        } else if (_typeof(type) === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)) {\n          propTypes = type.propTypes;\n        } else {\n          return;\n        }\n\n        if (propTypes) {\n          // Intentionally inside to avoid triggering lazy initializers:\n          var name = getComponentNameFromType(type);\n          checkPropTypes(propTypes, element.props, 'prop', name, element);\n        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n          var _name = getComponentNameFromType(type);\n\n          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n        }\n\n        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n        }\n      }\n    }\n    /**\n     * Given a fragment, validate that it can only be provided with fragment props\n     * @param {ReactElement} fragment\n     */\n\n\n    function validateFragmentProps(fragment) {\n      {\n        var keys = Object.keys(fragment.props);\n\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n\n          if (key !== 'children' && key !== 'key') {\n            setCurrentlyValidatingElement$1(fragment);\n            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n            setCurrentlyValidatingElement$1(null);\n            break;\n          }\n        }\n\n        if (fragment.ref !== null) {\n          setCurrentlyValidatingElement$1(fragment);\n          error('Invalid attribute `ref` supplied to `React.Fragment`.');\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n\n    function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n      {\n        var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n        // succeed and there will likely be errors in render.\n\n        if (!validType) {\n          var info = '';\n\n          if (type === undefined || _typeof(type) === 'object' && type !== null && Object.keys(type).length === 0) {\n            info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n          }\n\n          var sourceInfo = getSourceInfoErrorAddendum(source);\n\n          if (sourceInfo) {\n            info += sourceInfo;\n          } else {\n            info += getDeclarationErrorAddendum();\n          }\n\n          var typeString;\n\n          if (type === null) {\n            typeString = 'null';\n          } else if (isArray(type)) {\n            typeString = 'array';\n          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n            typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n            info = ' Did you accidentally export a JSX literal instead of a component?';\n          } else {\n            typeString = _typeof(type);\n          }\n\n          error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n        }\n\n        var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n        // TODO: Drop this when these are no longer allowed as the type argument.\n\n        if (element == null) {\n          return element;\n        } // Skip key warning if the type isn't valid since our key validation logic\n        // doesn't expect a non-string/function type and can throw confusing errors.\n        // We don't want exception behavior to differ between dev and prod.\n        // (Rendering will throw with a helpful message and as soon as the type is\n        // fixed, the key warnings will appear.)\n\n\n        if (validType) {\n          var children = props.children;\n\n          if (children !== undefined) {\n            if (isStaticChildren) {\n              if (isArray(children)) {\n                for (var i = 0; i < children.length; i++) {\n                  validateChildKeys(children[i], type);\n                }\n\n                if (Object.freeze) {\n                  Object.freeze(children);\n                }\n              } else {\n                error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n              }\n            } else {\n              validateChildKeys(children, type);\n            }\n          }\n        }\n\n        if (type === REACT_FRAGMENT_TYPE) {\n          validateFragmentProps(element);\n        } else {\n          validatePropTypes(element);\n        }\n\n        return element;\n      }\n    } // These two functions exist to still get child warnings in dev\n    // even with the prod transform. This means that jsxDEV is purely\n    // opt-in behavior for better messages but that we won't stop\n    // giving you warnings if you use production apis.\n\n\n    function jsxWithValidationStatic(type, props, key) {\n      {\n        return jsxWithValidation(type, props, key, true);\n      }\n    }\n\n    function jsxWithValidationDynamic(type, props, key) {\n      {\n        return jsxWithValidation(type, props, key, false);\n      }\n    }\n\n    var jsx = jsxWithValidationDynamic; // we may want to special case jsxs internally to take advantage of static children.\n    // for now we can ship identical prod functions\n\n    var jsxs = jsxWithValidationStatic;\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsx = jsx;\n    exports.jsxs = jsxs;\n  })();\n}\n\n//# sourceURL=webpack://reactappboiler/./node_modules/react/cjs/react-jsx-runtime.development.js?");

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n/**\n * @license React\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nif (true) {\n  (function () {\n    'use strict';\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    }\n\n    var ReactVersion = '18.0.0-fc46dba67-20220329'; // ATTENTION\n    // When adding new symbols to this file,\n    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n    // The Symbol used to tag the ReactElement-like types.\n\n    var REACT_ELEMENT_TYPE = Symbol[\"for\"]('react.element');\n    var REACT_PORTAL_TYPE = Symbol[\"for\"]('react.portal');\n    var REACT_FRAGMENT_TYPE = Symbol[\"for\"]('react.fragment');\n    var REACT_STRICT_MODE_TYPE = Symbol[\"for\"]('react.strict_mode');\n    var REACT_PROFILER_TYPE = Symbol[\"for\"]('react.profiler');\n    var REACT_PROVIDER_TYPE = Symbol[\"for\"]('react.provider');\n    var REACT_CONTEXT_TYPE = Symbol[\"for\"]('react.context');\n    var REACT_FORWARD_REF_TYPE = Symbol[\"for\"]('react.forward_ref');\n    var REACT_SUSPENSE_TYPE = Symbol[\"for\"]('react.suspense');\n    var REACT_SUSPENSE_LIST_TYPE = Symbol[\"for\"]('react.suspense_list');\n    var REACT_MEMO_TYPE = Symbol[\"for\"]('react.memo');\n    var REACT_LAZY_TYPE = Symbol[\"for\"]('react.lazy');\n    var REACT_OFFSCREEN_TYPE = Symbol[\"for\"]('react.offscreen');\n    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n    function getIteratorFn(maybeIterable) {\n      if (maybeIterable === null || _typeof(maybeIterable) !== 'object') {\n        return null;\n      }\n\n      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n      if (typeof maybeIterator === 'function') {\n        return maybeIterator;\n      }\n\n      return null;\n    }\n    /**\n     * Keeps track of the current dispatcher.\n     */\n\n\n    var ReactCurrentDispatcher = {\n      /**\n       * @internal\n       * @type {ReactComponent}\n       */\n      current: null\n    };\n    /**\n     * Keeps track of the current batch's configuration such as how long an update\n     * should suspend for if it needs to.\n     */\n\n    var ReactCurrentBatchConfig = {\n      transition: null\n    };\n    var ReactCurrentActQueue = {\n      current: null,\n      // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n      isBatchingLegacy: false,\n      didScheduleLegacyUpdate: false\n    };\n    /**\n     * Keeps track of the current owner.\n     *\n     * The current owner is the component who should own any components that are\n     * currently being constructed.\n     */\n\n    var ReactCurrentOwner = {\n      /**\n       * @internal\n       * @type {ReactComponent}\n       */\n      current: null\n    };\n    var ReactDebugCurrentFrame = {};\n    var currentExtraStackFrame = null;\n\n    function setExtraStackFrame(stack) {\n      {\n        currentExtraStackFrame = stack;\n      }\n    }\n\n    {\n      ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {\n        {\n          currentExtraStackFrame = stack;\n        }\n      }; // Stack implementation injected by the current renderer.\n\n\n      ReactDebugCurrentFrame.getCurrentStack = null;\n\n      ReactDebugCurrentFrame.getStackAddendum = function () {\n        var stack = ''; // Add an extra top frame while an element is being validated\n\n        if (currentExtraStackFrame) {\n          stack += currentExtraStackFrame;\n        } // Delegate to the injected renderer-specific implementation\n\n\n        var impl = ReactDebugCurrentFrame.getCurrentStack;\n\n        if (impl) {\n          stack += impl() || '';\n        }\n\n        return stack;\n      };\n    } // -----------------------------------------------------------------------------\n\n    var enableScopeAPI = false; // Experimental Create Event Handle API.\n\n    var enableCacheElement = false;\n    var enableTransitionTracing = false; // No known bugs, but needs performance testing\n\n    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n    // stuff. Intended to enable React core members to more easily debug scheduling\n    // issues in DEV builds.\n\n    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\n    var ReactSharedInternals = {\n      ReactCurrentDispatcher: ReactCurrentDispatcher,\n      ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n      ReactCurrentOwner: ReactCurrentOwner\n    };\n    {\n      ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n      ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n    } // by calls to these methods by a Babel plugin.\n    //\n    // In PROD (or in packages without access to React internals),\n    // they are left as they are instead.\n\n    function warn(format) {\n      {\n        {\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          printWarning('warn', format, args);\n        }\n      }\n    }\n\n    function error(format) {\n      {\n        {\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n\n          printWarning('error', format, args);\n        }\n      }\n    }\n\n    function printWarning(level, format, args) {\n      // When changing this logic, you might want to also\n      // update consoleWithStackDev.www.js as well.\n      {\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n        if (stack !== '') {\n          format += '%s';\n          args = args.concat([stack]);\n        } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n        var argsWithFormat = args.map(function (item) {\n          return String(item);\n        }); // Careful: RN currently depends on this prefix\n\n        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n        // breaks IE9: https://github.com/facebook/react/issues/13610\n        // eslint-disable-next-line react-internal/no-production-logging\n\n        Function.prototype.apply.call(console[level], console, argsWithFormat);\n      }\n    }\n\n    var didWarnStateUpdateForUnmountedComponent = {};\n\n    function warnNoop(publicInstance, callerName) {\n      {\n        var _constructor = publicInstance.constructor;\n        var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n        var warningKey = componentName + \".\" + callerName;\n\n        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n          return;\n        }\n\n        error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n        didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n      }\n    }\n    /**\n     * This is the abstract API for an update queue.\n     */\n\n\n    var ReactNoopUpdateQueue = {\n      /**\n       * Checks whether or not this composite component is mounted.\n       * @param {ReactClass} publicInstance The instance we want to test.\n       * @return {boolean} True if mounted, false otherwise.\n       * @protected\n       * @final\n       */\n      isMounted: function isMounted(publicInstance) {\n        return false;\n      },\n\n      /**\n       * Forces an update. This should only be invoked when it is known with\n       * certainty that we are **not** in a DOM transaction.\n       *\n       * You may want to call this when you know that some deeper aspect of the\n       * component's state has changed but `setState` was not called.\n       *\n       * This will not invoke `shouldComponentUpdate`, but it will invoke\n       * `componentWillUpdate` and `componentDidUpdate`.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} callerName name of the calling function in the public API.\n       * @internal\n       */\n      enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {\n        warnNoop(publicInstance, 'forceUpdate');\n      },\n\n      /**\n       * Replaces all of the state. Always use this or `setState` to mutate state.\n       * You should treat `this.state` as immutable.\n       *\n       * There is no guarantee that `this.state` will be immediately updated, so\n       * accessing `this.state` after calling this method may return the old value.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {object} completeState Next state.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} callerName name of the calling function in the public API.\n       * @internal\n       */\n      enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {\n        warnNoop(publicInstance, 'replaceState');\n      },\n\n      /**\n       * Sets a subset of the state. This only exists because _pendingState is\n       * internal. This provides a merging strategy that is not available to deep\n       * properties which is confusing. TODO: Expose pendingState or don't use it\n       * during the merge.\n       *\n       * @param {ReactClass} publicInstance The instance that should rerender.\n       * @param {object} partialState Next partial state to be merged with state.\n       * @param {?function} callback Called after component is updated.\n       * @param {?string} Name of the calling function in the public API.\n       * @internal\n       */\n      enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {\n        warnNoop(publicInstance, 'setState');\n      }\n    };\n    var assign = Object.assign;\n    var emptyObject = {};\n    {\n      Object.freeze(emptyObject);\n    }\n    /**\n     * Base class helpers for the updating state of a component.\n     */\n\n    function Component(props, context, updater) {\n      this.props = props;\n      this.context = context; // If a component has string refs, we will assign a different object later.\n\n      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n      // renderer.\n\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n\n    Component.prototype.isReactComponent = {};\n    /**\n     * Sets a subset of the state. Always use this to mutate\n     * state. You should treat `this.state` as immutable.\n     *\n     * There is no guarantee that `this.state` will be immediately updated, so\n     * accessing `this.state` after calling this method may return the old value.\n     *\n     * There is no guarantee that calls to `setState` will run synchronously,\n     * as they may eventually be batched together.  You can provide an optional\n     * callback that will be executed when the call to setState is actually\n     * completed.\n     *\n     * When a function is provided to setState, it will be called at some point in\n     * the future (not synchronously). It will be called with the up to date\n     * component arguments (state, props, context). These values can be different\n     * from this.* because your function may be called after receiveProps but before\n     * shouldComponentUpdate, and this new state, props, and context will not yet be\n     * assigned to this.\n     *\n     * @param {object|function} partialState Next partial state or function to\n     *        produce next partial state to be merged with current state.\n     * @param {?function} callback Called after state is updated.\n     * @final\n     * @protected\n     */\n\n    Component.prototype.setState = function (partialState, callback) {\n      if (_typeof(partialState) !== 'object' && typeof partialState !== 'function' && partialState != null) {\n        throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');\n      }\n\n      this.updater.enqueueSetState(this, partialState, callback, 'setState');\n    };\n    /**\n     * Forces an update. This should only be invoked when it is known with\n     * certainty that we are **not** in a DOM transaction.\n     *\n     * You may want to call this when you know that some deeper aspect of the\n     * component's state has changed but `setState` was not called.\n     *\n     * This will not invoke `shouldComponentUpdate`, but it will invoke\n     * `componentWillUpdate` and `componentDidUpdate`.\n     *\n     * @param {?function} callback Called after update is complete.\n     * @final\n     * @protected\n     */\n\n\n    Component.prototype.forceUpdate = function (callback) {\n      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n    };\n    /**\n     * Deprecated APIs. These APIs used to exist on classic React classes but since\n     * we would like to deprecate them, we're not going to move them over to this\n     * modern base class. Instead, we define a getter that warns if it's accessed.\n     */\n\n\n    {\n      var deprecatedAPIs = {\n        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n      };\n\n      var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {\n        Object.defineProperty(Component.prototype, methodName, {\n          get: function get() {\n            warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n            return undefined;\n          }\n        });\n      };\n\n      for (var fnName in deprecatedAPIs) {\n        if (deprecatedAPIs.hasOwnProperty(fnName)) {\n          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n        }\n      }\n    }\n\n    function ComponentDummy() {}\n\n    ComponentDummy.prototype = Component.prototype;\n    /**\n     * Convenience component with default shallow equality check for sCU.\n     */\n\n    function PureComponent(props, context, updater) {\n      this.props = props;\n      this.context = context; // If a component has string refs, we will assign a different object later.\n\n      this.refs = emptyObject;\n      this.updater = updater || ReactNoopUpdateQueue;\n    }\n\n    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n\n    assign(pureComponentPrototype, Component.prototype);\n    pureComponentPrototype.isPureReactComponent = true; // an immutable object with a single mutable value\n\n    function createRef() {\n      var refObject = {\n        current: null\n      };\n      {\n        Object.seal(refObject);\n      }\n      return refObject;\n    }\n\n    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\n    function isArray(a) {\n      return isArrayImpl(a);\n    }\n    /*\n     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n     *\n     * The functions in this module will throw an easier-to-understand,\n     * easier-to-debug exception with a clear errors message message explaining the\n     * problem. (Instead of a confusing exception thrown inside the implementation\n     * of the `value` object).\n     */\n    // $FlowFixMe only called in DEV, so void return is not possible.\n\n\n    function typeName(value) {\n      {\n        // toStringTag is needed for namespaced types like Temporal.Instant\n        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n        return type;\n      }\n    } // $FlowFixMe only called in DEV, so void return is not possible.\n\n\n    function willCoercionThrow(value) {\n      {\n        try {\n          testStringCoercion(value);\n          return false;\n        } catch (e) {\n          return true;\n        }\n      }\n    }\n\n    function testStringCoercion(value) {\n      // If you ended up here by following an exception call stack, here's what's\n      // happened: you supplied an object or symbol value to React (as a prop, key,\n      // DOM attribute, CSS property, string ref, etc.) and when React tried to\n      // coerce it to a string using `'' + value`, an exception was thrown.\n      //\n      // The most common types that will cause this exception are `Symbol` instances\n      // and Temporal objects like `Temporal.Instant`. But any object that has a\n      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n      // exception. (Library authors do this to prevent users from using built-in\n      // numeric operators like `+` or comparison operators like `>=` because custom\n      // methods are needed to perform accurate arithmetic or comparison.)\n      //\n      // To fix the problem, coerce this object or symbol value to a string before\n      // passing it to React. The most reliable way is usually `String(value)`.\n      //\n      // To find which value is throwing, check the browser or debugger console.\n      // Before this exception was thrown, there should be `console.error` output\n      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n      // problem and how that type was used: key, atrribute, input value prop, etc.\n      // In most cases, this console output also shows the component and its\n      // ancestor components where the exception happened.\n      //\n      // eslint-disable-next-line react-internal/safe-string-coercion\n      return '' + value;\n    }\n\n    function checkKeyStringCoercion(value) {\n      {\n        if (willCoercionThrow(value)) {\n          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n        }\n      }\n    }\n\n    function getWrappedName(outerType, innerType, wrapperName) {\n      var displayName = outerType.displayName;\n\n      if (displayName) {\n        return displayName;\n      }\n\n      var functionName = innerType.displayName || innerType.name || '';\n      return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n    } // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\n    function getContextName(type) {\n      return type.displayName || 'Context';\n    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\n    function getComponentNameFromType(type) {\n      if (type == null) {\n        // Host root, text node or just invalid type.\n        return null;\n      }\n\n      {\n        if (typeof type.tag === 'number') {\n          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n        }\n      }\n\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n\n      if (typeof type === 'string') {\n        return type;\n      }\n\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return 'Fragment';\n\n        case REACT_PORTAL_TYPE:\n          return 'Portal';\n\n        case REACT_PROFILER_TYPE:\n          return 'Profiler';\n\n        case REACT_STRICT_MODE_TYPE:\n          return 'StrictMode';\n\n        case REACT_SUSPENSE_TYPE:\n          return 'Suspense';\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return 'SuspenseList';\n      }\n\n      if (_typeof(type) === 'object') {\n        switch (type.$$typeof) {\n          case REACT_CONTEXT_TYPE:\n            var context = type;\n            return getContextName(context) + '.Consumer';\n\n          case REACT_PROVIDER_TYPE:\n            var provider = type;\n            return getContextName(provider._context) + '.Provider';\n\n          case REACT_FORWARD_REF_TYPE:\n            return getWrappedName(type, type.render, 'ForwardRef');\n\n          case REACT_MEMO_TYPE:\n            var outerName = type.displayName || null;\n\n            if (outerName !== null) {\n              return outerName;\n            }\n\n            return getComponentNameFromType(type.type) || 'Memo';\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                return getComponentNameFromType(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n          // eslint-disable-next-line no-fallthrough\n        }\n      }\n\n      return null;\n    }\n\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    var RESERVED_PROPS = {\n      key: true,\n      ref: true,\n      __self: true,\n      __source: true\n    };\n    var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n    {\n      didWarnAboutStringRefs = {};\n    }\n\n    function hasValidRef(config) {\n      {\n        if (hasOwnProperty.call(config, 'ref')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.ref !== undefined;\n    }\n\n    function hasValidKey(config) {\n      {\n        if (hasOwnProperty.call(config, 'key')) {\n          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n          if (getter && getter.isReactWarning) {\n            return false;\n          }\n        }\n      }\n      return config.key !== undefined;\n    }\n\n    function defineKeyPropWarningGetter(props, displayName) {\n      var warnAboutAccessingKey = function warnAboutAccessingKey() {\n        {\n          if (!specialPropKeyWarningShown) {\n            specialPropKeyWarningShown = true;\n            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        }\n      };\n\n      warnAboutAccessingKey.isReactWarning = true;\n      Object.defineProperty(props, 'key', {\n        get: warnAboutAccessingKey,\n        configurable: true\n      });\n    }\n\n    function defineRefPropWarningGetter(props, displayName) {\n      var warnAboutAccessingRef = function warnAboutAccessingRef() {\n        {\n          if (!specialPropRefWarningShown) {\n            specialPropRefWarningShown = true;\n            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n          }\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n\n    function warnIfStringRefCannotBeAutoConverted(config) {\n      {\n        if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n          if (!didWarnAboutStringRefs[componentName]) {\n            error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n            didWarnAboutStringRefs[componentName] = true;\n          }\n        }\n      }\n    }\n    /**\n     * Factory method to create a new React element. This no longer adheres to\n     * the class pattern, so do not use new to call it. Also, instanceof check\n     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n     * if something is a React Element.\n     *\n     * @param {*} type\n     * @param {*} props\n     * @param {*} key\n     * @param {string|object} ref\n     * @param {*} owner\n     * @param {*} self A *temporary* helper to detect places where `this` is\n     * different from the `owner` when React.createElement is called, so that we\n     * can warn. We want to get rid of owner and replace string `ref`s with arrow\n     * functions, and as long as `this` and owner are the same, there will be no\n     * change in behavior.\n     * @param {*} source An annotation object (added by a transpiler or otherwise)\n     * indicating filename, line number, and/or other information.\n     * @internal\n     */\n\n\n    var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {\n      var element = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: REACT_ELEMENT_TYPE,\n        // Built-in properties that belong on the element\n        type: type,\n        key: key,\n        ref: ref,\n        props: props,\n        // Record the component responsible for creating this element.\n        _owner: owner\n      };\n      {\n        // The validation flag is currently mutative. We put it on\n        // an external backing store so that we can freeze the whole object.\n        // This can be replaced with a WeakMap once they are implemented in\n        // commonly used development environments.\n        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n        // the validation flag non-enumerable (where possible, which should\n        // include every environment we run tests in), so the test framework\n        // ignores it.\n\n        Object.defineProperty(element._store, 'validated', {\n          configurable: false,\n          enumerable: false,\n          writable: true,\n          value: false\n        }); // self and source are DEV only properties.\n\n        Object.defineProperty(element, '_self', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: self\n        }); // Two elements created in two different places should be considered\n        // equal for testing purposes and therefore we hide it from enumeration.\n\n        Object.defineProperty(element, '_source', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: source\n        });\n\n        if (Object.freeze) {\n          Object.freeze(element.props);\n          Object.freeze(element);\n        }\n      }\n      return element;\n    };\n    /**\n     * Create and return a new ReactElement of the given type.\n     * See https://reactjs.org/docs/react-api.html#createelement\n     */\n\n\n    function createElement(type, config, children) {\n      var propName; // Reserved names are extracted\n\n      var props = {};\n      var key = null;\n      var ref = null;\n      var self = null;\n      var source = null;\n\n      if (config != null) {\n        if (hasValidRef(config)) {\n          ref = config.ref;\n          {\n            warnIfStringRefCannotBeAutoConverted(config);\n          }\n        }\n\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        }\n\n        self = config.__self === undefined ? null : config.__self;\n        source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            props[propName] = config[propName];\n          }\n        }\n      } // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n\n\n      var childrenLength = arguments.length - 2;\n\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n\n        {\n          if (Object.freeze) {\n            Object.freeze(childArray);\n          }\n        }\n        props.children = childArray;\n      } // Resolve default props\n\n\n      if (type && type.defaultProps) {\n        var defaultProps = type.defaultProps;\n\n        for (propName in defaultProps) {\n          if (props[propName] === undefined) {\n            props[propName] = defaultProps[propName];\n          }\n        }\n      }\n\n      {\n        if (key || ref) {\n          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n          if (key) {\n            defineKeyPropWarningGetter(props, displayName);\n          }\n\n          if (ref) {\n            defineRefPropWarningGetter(props, displayName);\n          }\n        }\n      }\n      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n    }\n\n    function cloneAndReplaceKey(oldElement, newKey) {\n      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n      return newElement;\n    }\n    /**\n     * Clone and return a new ReactElement using element as the starting point.\n     * See https://reactjs.org/docs/react-api.html#cloneelement\n     */\n\n\n    function cloneElement(element, config, children) {\n      if (element === null || element === undefined) {\n        throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n      }\n\n      var propName; // Original props are copied\n\n      var props = assign({}, element.props); // Reserved names are extracted\n\n      var key = element.key;\n      var ref = element.ref; // Self is preserved since the owner is preserved.\n\n      var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n      // transpiler, and the original source is probably a better indicator of the\n      // true owner.\n\n      var source = element._source; // Owner will be preserved, unless ref is overridden\n\n      var owner = element._owner;\n\n      if (config != null) {\n        if (hasValidRef(config)) {\n          // Silently steal the ref from the parent.\n          ref = config.ref;\n          owner = ReactCurrentOwner.current;\n        }\n\n        if (hasValidKey(config)) {\n          {\n            checkKeyStringCoercion(config.key);\n          }\n          key = '' + config.key;\n        } // Remaining properties override existing props\n\n\n        var defaultProps;\n\n        if (element.type && element.type.defaultProps) {\n          defaultProps = element.type.defaultProps;\n        }\n\n        for (propName in config) {\n          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n            if (config[propName] === undefined && defaultProps !== undefined) {\n              // Resolve default props\n              props[propName] = defaultProps[propName];\n            } else {\n              props[propName] = config[propName];\n            }\n          }\n        }\n      } // Children can be more than one argument, and those are transferred onto\n      // the newly allocated props object.\n\n\n      var childrenLength = arguments.length - 2;\n\n      if (childrenLength === 1) {\n        props.children = children;\n      } else if (childrenLength > 1) {\n        var childArray = Array(childrenLength);\n\n        for (var i = 0; i < childrenLength; i++) {\n          childArray[i] = arguments[i + 2];\n        }\n\n        props.children = childArray;\n      }\n\n      return ReactElement(element.type, key, ref, self, source, owner, props);\n    }\n    /**\n     * Verifies the object is a ReactElement.\n     * See https://reactjs.org/docs/react-api.html#isvalidelement\n     * @param {?object} object\n     * @return {boolean} True if `object` is a ReactElement.\n     * @final\n     */\n\n\n    function isValidElement(object) {\n      return _typeof(object) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n    }\n\n    var SEPARATOR = '.';\n    var SUBSEPARATOR = ':';\n    /**\n     * Escape and wrap key so it is safe to use as a reactid\n     *\n     * @param {string} key to be escaped.\n     * @return {string} the escaped key.\n     */\n\n    function escape(key) {\n      var escapeRegex = /[=:]/g;\n      var escaperLookup = {\n        '=': '=0',\n        ':': '=2'\n      };\n      var escapedString = key.replace(escapeRegex, function (match) {\n        return escaperLookup[match];\n      });\n      return '$' + escapedString;\n    }\n    /**\n     * TODO: Test that a single child and an array with one item have the same key\n     * pattern.\n     */\n\n\n    var didWarnAboutMaps = false;\n    var userProvidedKeyEscapeRegex = /\\/+/g;\n\n    function escapeUserProvidedKey(text) {\n      return text.replace(userProvidedKeyEscapeRegex, '$&/');\n    }\n    /**\n     * Generate a key string that identifies a element within a set.\n     *\n     * @param {*} element A element that could contain a manual key.\n     * @param {number} index Index that is used if a manual key is not provided.\n     * @return {string}\n     */\n\n\n    function getElementKey(element, index) {\n      // Do some typechecking here since we call this blindly. We want to ensure\n      // that we don't block potential future ES APIs.\n      if (_typeof(element) === 'object' && element !== null && element.key != null) {\n        // Explicit key\n        {\n          checkKeyStringCoercion(element.key);\n        }\n        return escape('' + element.key);\n      } // Implicit key determined by the index in the set\n\n\n      return index.toString(36);\n    }\n\n    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n      var type = _typeof(children);\n\n      if (type === 'undefined' || type === 'boolean') {\n        // All of the above are perceived as null.\n        children = null;\n      }\n\n      var invokeCallback = false;\n\n      if (children === null) {\n        invokeCallback = true;\n      } else {\n        switch (type) {\n          case 'string':\n          case 'number':\n            invokeCallback = true;\n            break;\n\n          case 'object':\n            switch (children.$$typeof) {\n              case REACT_ELEMENT_TYPE:\n              case REACT_PORTAL_TYPE:\n                invokeCallback = true;\n            }\n\n        }\n      }\n\n      if (invokeCallback) {\n        var _child = children;\n        var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\n        // so that it's consistent if the number of children grows:\n\n        var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n\n        if (isArray(mappedChild)) {\n          var escapedChildKey = '';\n\n          if (childKey != null) {\n            escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n          }\n\n          mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {\n            return c;\n          });\n        } else if (mappedChild != null) {\n          if (isValidElement(mappedChild)) {\n            {\n              // The `if` statement here prevents auto-disabling of the safe\n              // coercion ESLint rule, so we must manually disable it below.\n              // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n              if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n                checkKeyStringCoercion(mappedChild.key);\n              }\n            }\n            mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as\n            // traverseAllChildren used to do for objects as children\n            escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n            mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);\n          }\n\n          array.push(mappedChild);\n        }\n\n        return 1;\n      }\n\n      var child;\n      var nextName;\n      var subtreeCount = 0; // Count of children found in the current subtree.\n\n      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n      if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n          child = children[i];\n          nextName = nextNamePrefix + getElementKey(child, i);\n          subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n        }\n      } else {\n        var iteratorFn = getIteratorFn(children);\n\n        if (typeof iteratorFn === 'function') {\n          var iterableChildren = children;\n          {\n            // Warn about using Maps as children\n            if (iteratorFn === iterableChildren.entries) {\n              if (!didWarnAboutMaps) {\n                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n              }\n\n              didWarnAboutMaps = true;\n            }\n          }\n          var iterator = iteratorFn.call(iterableChildren);\n          var step;\n          var ii = 0;\n\n          while (!(step = iterator.next()).done) {\n            child = step.value;\n            nextName = nextNamePrefix + getElementKey(child, ii++);\n            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n          }\n        } else if (type === 'object') {\n          // eslint-disable-next-line react-internal/safe-string-coercion\n          var childrenString = String(children);\n          throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n        }\n      }\n\n      return subtreeCount;\n    }\n    /**\n     * Maps children that are typically specified as `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n     *\n     * The provided mapFunction(child, index) will be called for each\n     * leaf child.\n     *\n     * @param {?*} children Children tree container.\n     * @param {function(*, int)} func The map function.\n     * @param {*} context Context for mapFunction.\n     * @return {object} Object containing the ordered map of results.\n     */\n\n\n    function mapChildren(children, func, context) {\n      if (children == null) {\n        return children;\n      }\n\n      var result = [];\n      var count = 0;\n      mapIntoArray(children, result, '', '', function (child) {\n        return func.call(context, child, count++);\n      });\n      return result;\n    }\n    /**\n     * Count the number of children that are typically specified as\n     * `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrencount\n     *\n     * @param {?*} children Children tree container.\n     * @return {number} The number of children.\n     */\n\n\n    function countChildren(children) {\n      var n = 0;\n      mapChildren(children, function () {\n        n++; // Don't return anything\n      });\n      return n;\n    }\n    /**\n     * Iterates through children that are typically specified as `props.children`.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n     *\n     * The provided forEachFunc(child, index) will be called for each\n     * leaf child.\n     *\n     * @param {?*} children Children tree container.\n     * @param {function(*, int)} forEachFunc\n     * @param {*} forEachContext Context for forEachContext.\n     */\n\n\n    function forEachChildren(children, forEachFunc, forEachContext) {\n      mapChildren(children, function () {\n        forEachFunc.apply(this, arguments); // Don't return anything.\n      }, forEachContext);\n    }\n    /**\n     * Flatten a children object (typically specified as `props.children`) and\n     * return an array with appropriately re-keyed children.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n     */\n\n\n    function toArray(children) {\n      return mapChildren(children, function (child) {\n        return child;\n      }) || [];\n    }\n    /**\n     * Returns the first child in a collection of children and verifies that there\n     * is only one child in the collection.\n     *\n     * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n     *\n     * The current implementation of this function assumes that a single child gets\n     * passed without a wrapper, but the purpose of this helper function is to\n     * abstract away the particular structure of children.\n     *\n     * @param {?object} children Child collection structure.\n     * @return {ReactElement} The first and only `ReactElement` contained in the\n     * structure.\n     */\n\n\n    function onlyChild(children) {\n      if (!isValidElement(children)) {\n        throw new Error('React.Children.only expected to receive a single React element child.');\n      }\n\n      return children;\n    }\n\n    function createContext(defaultValue) {\n      // TODO: Second argument used to be an optional `calculateChangedBits`\n      // function. Warn to reserve for future use?\n      var context = {\n        $$typeof: REACT_CONTEXT_TYPE,\n        // As a workaround to support multiple concurrent renderers, we categorize\n        // some renderers as primary and others as secondary. We only expect\n        // there to be two concurrent renderers at most: React Native (primary) and\n        // Fabric (secondary); React DOM (primary) and React ART (secondary).\n        // Secondary renderers store their context values on separate fields.\n        _currentValue: defaultValue,\n        _currentValue2: defaultValue,\n        // Used to track how many concurrent renderers this context currently\n        // supports within in a single renderer. Such as parallel server rendering.\n        _threadCount: 0,\n        // These are circular\n        Provider: null,\n        Consumer: null,\n        // Add these to use same hidden class in VM as ServerContext\n        _defaultValue: null,\n        _globalName: null\n      };\n      context.Provider = {\n        $$typeof: REACT_PROVIDER_TYPE,\n        _context: context\n      };\n      var hasWarnedAboutUsingNestedContextConsumers = false;\n      var hasWarnedAboutUsingConsumerProvider = false;\n      var hasWarnedAboutDisplayNameOnConsumer = false;\n      {\n        // A separate object, but proxies back to the original context object for\n        // backwards compatibility. It has a different $$typeof, so we can properly\n        // warn for the incorrect usage of Context as a Consumer.\n        var Consumer = {\n          $$typeof: REACT_CONTEXT_TYPE,\n          _context: context\n        }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\n\n        Object.defineProperties(Consumer, {\n          Provider: {\n            get: function get() {\n              if (!hasWarnedAboutUsingConsumerProvider) {\n                hasWarnedAboutUsingConsumerProvider = true;\n                error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\n              }\n\n              return context.Provider;\n            },\n            set: function set(_Provider) {\n              context.Provider = _Provider;\n            }\n          },\n          _currentValue: {\n            get: function get() {\n              return context._currentValue;\n            },\n            set: function set(_currentValue) {\n              context._currentValue = _currentValue;\n            }\n          },\n          _currentValue2: {\n            get: function get() {\n              return context._currentValue2;\n            },\n            set: function set(_currentValue2) {\n              context._currentValue2 = _currentValue2;\n            }\n          },\n          _threadCount: {\n            get: function get() {\n              return context._threadCount;\n            },\n            set: function set(_threadCount) {\n              context._threadCount = _threadCount;\n            }\n          },\n          Consumer: {\n            get: function get() {\n              if (!hasWarnedAboutUsingNestedContextConsumers) {\n                hasWarnedAboutUsingNestedContextConsumers = true;\n                error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n              }\n\n              return context.Consumer;\n            }\n          },\n          displayName: {\n            get: function get() {\n              return context.displayName;\n            },\n            set: function set(displayName) {\n              if (!hasWarnedAboutDisplayNameOnConsumer) {\n                warn('Setting `displayName` on Context.Consumer has no effect. ' + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n                hasWarnedAboutDisplayNameOnConsumer = true;\n              }\n            }\n          }\n        }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\n\n        context.Consumer = Consumer;\n      }\n      {\n        context._currentRenderer = null;\n        context._currentRenderer2 = null;\n      }\n      return context;\n    }\n\n    var Uninitialized = -1;\n    var Pending = 0;\n    var Resolved = 1;\n    var Rejected = 2;\n\n    function lazyInitializer(payload) {\n      if (payload._status === Uninitialized) {\n        var ctor = payload._result;\n        var thenable = ctor(); // Transition to the next state.\n        // This might throw either because it's missing or throws. If so, we treat it\n        // as still uninitialized and try again next time. Which is the same as what\n        // happens if the ctor or any wrappers processing the ctor throws. This might\n        // end up fixing it if the resolution was a concurrency bug.\n\n        thenable.then(function (moduleObject) {\n          if (payload._status === Pending || payload._status === Uninitialized) {\n            // Transition to the next state.\n            var resolved = payload;\n            resolved._status = Resolved;\n            resolved._result = moduleObject;\n          }\n        }, function (error) {\n          if (payload._status === Pending || payload._status === Uninitialized) {\n            // Transition to the next state.\n            var rejected = payload;\n            rejected._status = Rejected;\n            rejected._result = error;\n          }\n        });\n\n        if (payload._status === Uninitialized) {\n          // In case, we're still uninitialized, then we're waiting for the thenable\n          // to resolve. Set it as pending in the meantime.\n          var pending = payload;\n          pending._status = Pending;\n          pending._result = thenable;\n        }\n      }\n\n      if (payload._status === Resolved) {\n        var moduleObject = payload._result;\n        {\n          if (moduleObject === undefined) {\n            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\\n\\n\" + 'Did you accidentally put curly braces around the import?', moduleObject);\n          }\n        }\n        {\n          if (!('default' in moduleObject)) {\n            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\", moduleObject);\n          }\n        }\n        return moduleObject[\"default\"];\n      } else {\n        throw payload._result;\n      }\n    }\n\n    function lazy(ctor) {\n      var payload = {\n        // We use these fields to store the result.\n        _status: Uninitialized,\n        _result: ctor\n      };\n      var lazyType = {\n        $$typeof: REACT_LAZY_TYPE,\n        _payload: payload,\n        _init: lazyInitializer\n      };\n      {\n        // In production, this would just set it on the object.\n        var defaultProps;\n        var propTypes; // $FlowFixMe\n\n        Object.defineProperties(lazyType, {\n          defaultProps: {\n            configurable: true,\n            get: function get() {\n              return defaultProps;\n            },\n            set: function set(newDefaultProps) {\n              error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n              defaultProps = newDefaultProps; // Match production behavior more closely:\n              // $FlowFixMe\n\n              Object.defineProperty(lazyType, 'defaultProps', {\n                enumerable: true\n              });\n            }\n          },\n          propTypes: {\n            configurable: true,\n            get: function get() {\n              return propTypes;\n            },\n            set: function set(newPropTypes) {\n              error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n              propTypes = newPropTypes; // Match production behavior more closely:\n              // $FlowFixMe\n\n              Object.defineProperty(lazyType, 'propTypes', {\n                enumerable: true\n              });\n            }\n          }\n        });\n      }\n      return lazyType;\n    }\n\n    function forwardRef(render) {\n      {\n        if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n          error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\n        } else if (typeof render !== 'function') {\n          error('forwardRef requires a render function but was given %s.', render === null ? 'null' : _typeof(render));\n        } else {\n          if (render.length !== 0 && render.length !== 2) {\n            error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');\n          }\n        }\n\n        if (render != null) {\n          if (render.defaultProps != null || render.propTypes != null) {\n            error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');\n          }\n        }\n      }\n      var elementType = {\n        $$typeof: REACT_FORWARD_REF_TYPE,\n        render: render\n      };\n      {\n        var ownName;\n        Object.defineProperty(elementType, 'displayName', {\n          enumerable: false,\n          configurable: true,\n          get: function get() {\n            return ownName;\n          },\n          set: function set(name) {\n            ownName = name; // The inner component shouldn't inherit this display name in most cases,\n            // because the component may be used elsewhere.\n            // But it's nice for anonymous functions to inherit the name,\n            // so that our component-stack generation logic will display their frames.\n            // An anonymous function generally suggests a pattern like:\n            //   React.forwardRef((props, ref) => {...});\n            // This kind of inner function is not used elsewhere so the side effect is okay.\n\n            if (!render.name && !render.displayName) {\n              render.displayName = name;\n            }\n          }\n        });\n      }\n      return elementType;\n    }\n\n    var REACT_MODULE_REFERENCE = Symbol[\"for\"]('react.module.reference');\n\n    function isValidElementType(type) {\n      if (typeof type === 'string' || typeof type === 'function') {\n        return true;\n      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n        return true;\n      }\n\n      if (_typeof(type) === 'object' && type !== null) {\n        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n        // types supported by any Flight configuration anywhere since\n        // we don't know which Flight build this will end up being used\n        // with.\n        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    function memo(type, compare) {\n      {\n        if (!isValidElementType(type)) {\n          error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : _typeof(type));\n        }\n      }\n      var elementType = {\n        $$typeof: REACT_MEMO_TYPE,\n        type: type,\n        compare: compare === undefined ? null : compare\n      };\n      {\n        var ownName;\n        Object.defineProperty(elementType, 'displayName', {\n          enumerable: false,\n          configurable: true,\n          get: function get() {\n            return ownName;\n          },\n          set: function set(name) {\n            ownName = name; // The inner component shouldn't inherit this display name in most cases,\n            // because the component may be used elsewhere.\n            // But it's nice for anonymous functions to inherit the name,\n            // so that our component-stack generation logic will display their frames.\n            // An anonymous function generally suggests a pattern like:\n            //   React.memo((props) => {...});\n            // This kind of inner function is not used elsewhere so the side effect is okay.\n\n            if (!type.name && !type.displayName) {\n              type.displayName = name;\n            }\n          }\n        });\n      }\n      return elementType;\n    }\n\n    function resolveDispatcher() {\n      var dispatcher = ReactCurrentDispatcher.current;\n      {\n        if (dispatcher === null) {\n          error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n        }\n      } // Will result in a null access error if accessed outside render phase. We\n      // intentionally don't throw our own error because this is in a hot path.\n      // Also helps ensure this is inlined.\n\n      return dispatcher;\n    }\n\n    function useContext(Context) {\n      var dispatcher = resolveDispatcher();\n      {\n        // TODO: add a more generic warning for invalid values.\n        if (Context._context !== undefined) {\n          var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n          // and nobody should be using this in existing code.\n\n          if (realContext.Consumer === Context) {\n            error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n          } else if (realContext.Provider === Context) {\n            error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n          }\n        }\n      }\n      return dispatcher.useContext(Context);\n    }\n\n    function useState(initialState) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useState(initialState);\n    }\n\n    function useReducer(reducer, initialArg, init) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useReducer(reducer, initialArg, init);\n    }\n\n    function useRef(initialValue) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useRef(initialValue);\n    }\n\n    function useEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useEffect(create, deps);\n    }\n\n    function useInsertionEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useInsertionEffect(create, deps);\n    }\n\n    function useLayoutEffect(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useLayoutEffect(create, deps);\n    }\n\n    function useCallback(callback, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useCallback(callback, deps);\n    }\n\n    function useMemo(create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useMemo(create, deps);\n    }\n\n    function useImperativeHandle(ref, create, deps) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useImperativeHandle(ref, create, deps);\n    }\n\n    function useDebugValue(value, formatterFn) {\n      {\n        var dispatcher = resolveDispatcher();\n        return dispatcher.useDebugValue(value, formatterFn);\n      }\n    }\n\n    function useTransition() {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useTransition();\n    }\n\n    function useDeferredValue(value) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useDeferredValue(value);\n    }\n\n    function useId() {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useId();\n    }\n\n    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n      var dispatcher = resolveDispatcher();\n      return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    } // Helpers to patch console.logs to avoid logging during side-effect free\n    // replaying on render function. This currently only patches the object\n    // lazily which won't cover if the log function was extracted eagerly.\n    // We could also eagerly patch the method.\n\n\n    var disabledDepth = 0;\n    var prevLog;\n    var prevInfo;\n    var prevWarn;\n    var prevError;\n    var prevGroup;\n    var prevGroupCollapsed;\n    var prevGroupEnd;\n\n    function disabledLog() {}\n\n    disabledLog.__reactDisabledLog = true;\n\n    function disableLogs() {\n      {\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          prevLog = console.log;\n          prevInfo = console.info;\n          prevWarn = console.warn;\n          prevError = console.error;\n          prevGroup = console.group;\n          prevGroupCollapsed = console.groupCollapsed;\n          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n          var props = {\n            configurable: true,\n            enumerable: true,\n            value: disabledLog,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            info: props,\n            log: props,\n            warn: props,\n            error: props,\n            group: props,\n            groupCollapsed: props,\n            groupEnd: props\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        disabledDepth++;\n      }\n    }\n\n    function reenableLogs() {\n      {\n        disabledDepth--;\n\n        if (disabledDepth === 0) {\n          /* eslint-disable react-internal/no-production-logging */\n          var props = {\n            configurable: true,\n            enumerable: true,\n            writable: true\n          }; // $FlowFixMe Flow thinks console is immutable.\n\n          Object.defineProperties(console, {\n            log: assign({}, props, {\n              value: prevLog\n            }),\n            info: assign({}, props, {\n              value: prevInfo\n            }),\n            warn: assign({}, props, {\n              value: prevWarn\n            }),\n            error: assign({}, props, {\n              value: prevError\n            }),\n            group: assign({}, props, {\n              value: prevGroup\n            }),\n            groupCollapsed: assign({}, props, {\n              value: prevGroupCollapsed\n            }),\n            groupEnd: assign({}, props, {\n              value: prevGroupEnd\n            })\n          });\n          /* eslint-enable react-internal/no-production-logging */\n        }\n\n        if (disabledDepth < 0) {\n          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n        }\n      }\n    }\n\n    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n    var prefix;\n\n    function describeBuiltInComponentFrame(name, source, ownerFn) {\n      {\n        if (prefix === undefined) {\n          // Extract the VM specific prefix used by each line.\n          try {\n            throw Error();\n          } catch (x) {\n            var match = x.stack.trim().match(/\\n( *(at )?)/);\n            prefix = match && match[1] || '';\n          }\n        } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n        return '\\n' + prefix + name;\n      }\n    }\n\n    var reentry = false;\n    var componentFrameCache;\n    {\n      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n      componentFrameCache = new PossiblyWeakMap();\n    }\n\n    function describeNativeComponentFrame(fn, construct) {\n      // If something asked for a stack inside a fake render, it should get ignored.\n      if (!fn || reentry) {\n        return '';\n      }\n\n      {\n        var frame = componentFrameCache.get(fn);\n\n        if (frame !== undefined) {\n          return frame;\n        }\n      }\n      var control;\n      reentry = true;\n      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n      Error.prepareStackTrace = undefined;\n      var previousDispatcher;\n      {\n        previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n        // for warnings.\n\n        ReactCurrentDispatcher$1.current = null;\n        disableLogs();\n      }\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function Fake() {\n            throw Error();\n          }; // $FlowFixMe\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function set() {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if ((typeof Reflect === \"undefined\" ? \"undefined\" : _typeof(Reflect)) === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            }\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          }\n\n          fn();\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          // This extracts the first frame from the sample that isn't also in the control.\n          // Skipping one frame that we assume is the frame that calls the two.\n          var sampleLines = sample.stack.split('\\n');\n          var controlLines = control.stack.split('\\n');\n          var s = sampleLines.length - 1;\n          var c = controlLines.length - 1;\n\n          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n            // We expect at least one stack frame to be shared.\n            // Typically this will be the root most one. However, stack frames may be\n            // cut off due to maximum stack limits. In this case, one maybe cut off\n            // earlier than the other. We assume that the sample is longer or the same\n            // and there for cut off earlier. So we should find the root most frame in\n            // the sample somewhere in the control.\n            c--;\n          }\n\n          for (; s >= 1 && c >= 0; s--, c--) {\n            // Next we find the first one that isn't the same which should be the\n            // frame that called our sample function and the control.\n            if (sampleLines[s] !== controlLines[c]) {\n              // In V8, the first line is describing the message but other VMs don't.\n              // If we're about to return the first line, and the control is also on the same\n              // line, that's a pretty good indicator that our sample threw at same line as\n              // the control. I.e. before we entered the sample frame. So we ignore this result.\n              // This can happen if you passed a class to function component, or non-function.\n              if (s !== 1 || c !== 1) {\n                do {\n                  s--;\n                  c--; // We may still have similar intermediate frames from the construct call.\n                  // The next one that isn't the same should be our match though.\n\n                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                    // but we have a user-provided \"displayName\"\n                    // splice it in to make the stack more readable.\n\n\n                    if (fn.displayName && _frame.includes('<anonymous>')) {\n                      _frame = _frame.replace('<anonymous>', fn.displayName);\n                    }\n\n                    {\n                      if (typeof fn === 'function') {\n                        componentFrameCache.set(fn, _frame);\n                      }\n                    } // Return the line we found.\n\n                    return _frame;\n                  }\n                } while (s >= 1 && c >= 0);\n              }\n\n              break;\n            }\n          }\n        }\n      } finally {\n        reentry = false;\n        {\n          ReactCurrentDispatcher$1.current = previousDispatcher;\n          reenableLogs();\n        }\n        Error.prepareStackTrace = previousPrepareStackTrace;\n      } // Fallback to just using the name if we couldn't make it throw.\n\n\n      var name = fn ? fn.displayName || fn.name : '';\n      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n      {\n        if (typeof fn === 'function') {\n          componentFrameCache.set(fn, syntheticFrame);\n        }\n      }\n      return syntheticFrame;\n    }\n\n    function describeFunctionComponentFrame(fn, source, ownerFn) {\n      {\n        return describeNativeComponentFrame(fn, false);\n      }\n    }\n\n    function shouldConstruct(Component) {\n      var prototype = Component.prototype;\n      return !!(prototype && prototype.isReactComponent);\n    }\n\n    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n      if (type == null) {\n        return '';\n      }\n\n      if (typeof type === 'function') {\n        {\n          return describeNativeComponentFrame(type, shouldConstruct(type));\n        }\n      }\n\n      if (typeof type === 'string') {\n        return describeBuiltInComponentFrame(type);\n      }\n\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame('Suspense');\n\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame('SuspenseList');\n      }\n\n      if (_typeof(type) === 'object') {\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return describeFunctionComponentFrame(type.render);\n\n          case REACT_MEMO_TYPE:\n            // Memo may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n          case REACT_LAZY_TYPE:\n            {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n\n              try {\n                // Lazy may contain any component type so we recursively resolve it.\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {}\n            }\n        }\n      }\n\n      return '';\n    }\n\n    var loggedTypeFailures = {};\n    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\n    function setCurrentlyValidatingElement(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n        } else {\n          ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n        }\n      }\n    }\n\n    function checkPropTypes(typeSpecs, values, location, componentName, element) {\n      {\n        // $FlowFixMe This is okay but Flow doesn't know it.\n        var has = Function.call.bind(hasOwnProperty);\n\n        for (var typeSpecName in typeSpecs) {\n          if (has(typeSpecs, typeSpecName)) {\n            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n            // fail the render phase where it didn't fail before. So we log it.\n            // After these have been cleaned up, we'll let them throw.\n\n            try {\n              // This is intentionally an invariant that gets caught. It's the same\n              // behavior as without this statement except with a better message.\n              if (typeof typeSpecs[typeSpecName] !== 'function') {\n                // eslint-disable-next-line react-internal/prod-error-codes\n                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + _typeof(typeSpecs[typeSpecName]) + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n                err.name = 'Invariant Violation';\n                throw err;\n              }\n\n              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n            } catch (ex) {\n              error$1 = ex;\n            }\n\n            if (error$1 && !(error$1 instanceof Error)) {\n              setCurrentlyValidatingElement(element);\n              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, _typeof(error$1));\n              setCurrentlyValidatingElement(null);\n            }\n\n            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n              // Only monitor this failure once because there tends to be a lot of the\n              // same error.\n              loggedTypeFailures[error$1.message] = true;\n              setCurrentlyValidatingElement(element);\n              error('Failed %s type: %s', location, error$1.message);\n              setCurrentlyValidatingElement(null);\n            }\n          }\n        }\n      }\n    }\n\n    function setCurrentlyValidatingElement$1(element) {\n      {\n        if (element) {\n          var owner = element._owner;\n          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n          setExtraStackFrame(stack);\n        } else {\n          setExtraStackFrame(null);\n        }\n      }\n    }\n\n    var propTypesMisspellWarningShown;\n    {\n      propTypesMisspellWarningShown = false;\n    }\n\n    function getDeclarationErrorAddendum() {\n      if (ReactCurrentOwner.current) {\n        var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n        if (name) {\n          return '\\n\\nCheck the render method of `' + name + '`.';\n        }\n      }\n\n      return '';\n    }\n\n    function getSourceInfoErrorAddendum(source) {\n      if (source !== undefined) {\n        var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n        var lineNumber = source.lineNumber;\n        return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n      }\n\n      return '';\n    }\n\n    function getSourceInfoErrorAddendumForProps(elementProps) {\n      if (elementProps !== null && elementProps !== undefined) {\n        return getSourceInfoErrorAddendum(elementProps.__source);\n      }\n\n      return '';\n    }\n    /**\n     * Warn if there's no key explicitly set on dynamic arrays of children or\n     * object keys are not valid. This allows us to keep track of children between\n     * updates.\n     */\n\n\n    var ownerHasKeyUseWarning = {};\n\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = getDeclarationErrorAddendum();\n\n      if (!info) {\n        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n        if (parentName) {\n          info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n        }\n      }\n\n      return info;\n    }\n    /**\n     * Warn if the element doesn't have an explicit key assigned to it.\n     * This element is in an array. The array could grow and shrink or be\n     * reordered. All children that haven't already been validated are required to\n     * have a \"key\" property assigned to it. Error statuses are cached so a warning\n     * will only be shown once.\n     *\n     * @internal\n     * @param {ReactElement} element Element that requires a key.\n     * @param {*} parentType element's parent's type.\n     */\n\n\n    function validateExplicitKey(element, parentType) {\n      if (!element._store || element._store.validated || element.key != null) {\n        return;\n      }\n\n      element._store.validated = true;\n      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n        return;\n      }\n\n      ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n      // property, it may be the creator of the child that's responsible for\n      // assigning it a key.\n\n      var childOwner = '';\n\n      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n        // Give the component that originally created this child.\n        childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n      }\n\n      {\n        setCurrentlyValidatingElement$1(element);\n        error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n        setCurrentlyValidatingElement$1(null);\n      }\n    }\n    /**\n     * Ensure that every element either is passed in a static location, in an\n     * array with an explicit keys property defined, or in an object literal\n     * with valid key property.\n     *\n     * @internal\n     * @param {ReactNode} node Statically passed child of any type.\n     * @param {*} parentType node's parent's type.\n     */\n\n\n    function validateChildKeys(node, parentType) {\n      if (_typeof(node) !== 'object') {\n        return;\n      }\n\n      if (isArray(node)) {\n        for (var i = 0; i < node.length; i++) {\n          var child = node[i];\n\n          if (isValidElement(child)) {\n            validateExplicitKey(child, parentType);\n          }\n        }\n      } else if (isValidElement(node)) {\n        // This element was passed in a valid location.\n        if (node._store) {\n          node._store.validated = true;\n        }\n      } else if (node) {\n        var iteratorFn = getIteratorFn(node);\n\n        if (typeof iteratorFn === 'function') {\n          // Entry iterators used to provide implicit keys,\n          // but now we print a separate warning for them later.\n          if (iteratorFn !== node.entries) {\n            var iterator = iteratorFn.call(node);\n            var step;\n\n            while (!(step = iterator.next()).done) {\n              if (isValidElement(step.value)) {\n                validateExplicitKey(step.value, parentType);\n              }\n            }\n          }\n        }\n      }\n    }\n    /**\n     * Given an element, validate that its props follow the propTypes definition,\n     * provided by the type.\n     *\n     * @param {ReactElement} element\n     */\n\n\n    function validatePropTypes(element) {\n      {\n        var type = element.type;\n\n        if (type === null || type === undefined || typeof type === 'string') {\n          return;\n        }\n\n        var propTypes;\n\n        if (typeof type === 'function') {\n          propTypes = type.propTypes;\n        } else if (_typeof(type) === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        type.$$typeof === REACT_MEMO_TYPE)) {\n          propTypes = type.propTypes;\n        } else {\n          return;\n        }\n\n        if (propTypes) {\n          // Intentionally inside to avoid triggering lazy initializers:\n          var name = getComponentNameFromType(type);\n          checkPropTypes(propTypes, element.props, 'prop', name, element);\n        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n          var _name = getComponentNameFromType(type);\n\n          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n        }\n\n        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n        }\n      }\n    }\n    /**\n     * Given a fragment, validate that it can only be provided with fragment props\n     * @param {ReactElement} fragment\n     */\n\n\n    function validateFragmentProps(fragment) {\n      {\n        var keys = Object.keys(fragment.props);\n\n        for (var i = 0; i < keys.length; i++) {\n          var key = keys[i];\n\n          if (key !== 'children' && key !== 'key') {\n            setCurrentlyValidatingElement$1(fragment);\n            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n            setCurrentlyValidatingElement$1(null);\n            break;\n          }\n        }\n\n        if (fragment.ref !== null) {\n          setCurrentlyValidatingElement$1(fragment);\n          error('Invalid attribute `ref` supplied to `React.Fragment`.');\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n\n    function createElementWithValidation(type, props, children) {\n      var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n\n      if (!validType) {\n        var info = '';\n\n        if (type === undefined || _typeof(type) === 'object' && type !== null && Object.keys(type).length === 0) {\n          info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n        }\n\n        var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n\n        if (sourceInfo) {\n          info += sourceInfo;\n        } else {\n          info += getDeclarationErrorAddendum();\n        }\n\n        var typeString;\n\n        if (type === null) {\n          typeString = 'null';\n        } else if (isArray(type)) {\n          typeString = 'array';\n        } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n          typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n          info = ' Did you accidentally export a JSX literal instead of a component?';\n        } else {\n          typeString = _typeof(type);\n        }\n\n        {\n          error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n        }\n      }\n\n      var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n      // TODO: Drop this when these are no longer allowed as the type argument.\n\n      if (element == null) {\n        return element;\n      } // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing errors.\n      // We don't want exception behavior to differ between dev and prod.\n      // (Rendering will throw with a helpful message and as soon as the type is\n      // fixed, the key warnings will appear.)\n\n\n      if (validType) {\n        for (var i = 2; i < arguments.length; i++) {\n          validateChildKeys(arguments[i], type);\n        }\n      }\n\n      if (type === REACT_FRAGMENT_TYPE) {\n        validateFragmentProps(element);\n      } else {\n        validatePropTypes(element);\n      }\n\n      return element;\n    }\n\n    var didWarnAboutDeprecatedCreateFactory = false;\n\n    function createFactoryWithValidation(type) {\n      var validatedFactory = createElementWithValidation.bind(null, type);\n      validatedFactory.type = type;\n      {\n        if (!didWarnAboutDeprecatedCreateFactory) {\n          didWarnAboutDeprecatedCreateFactory = true;\n          warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\n        } // Legacy hook: remove it\n\n\n        Object.defineProperty(validatedFactory, 'type', {\n          enumerable: false,\n          get: function get() {\n            warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n            Object.defineProperty(this, 'type', {\n              value: type\n            });\n            return type;\n          }\n        });\n      }\n      return validatedFactory;\n    }\n\n    function cloneElementWithValidation(element, props, children) {\n      var newElement = cloneElement.apply(this, arguments);\n\n      for (var i = 2; i < arguments.length; i++) {\n        validateChildKeys(arguments[i], newElement.type);\n      }\n\n      validatePropTypes(newElement);\n      return newElement;\n    }\n\n    function startTransition(scope, options) {\n      var prevTransition = ReactCurrentBatchConfig.transition;\n      ReactCurrentBatchConfig.transition = {};\n      var currentTransition = ReactCurrentBatchConfig.transition;\n      {\n        ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n      }\n\n      try {\n        scope();\n      } finally {\n        ReactCurrentBatchConfig.transition = prevTransition;\n        {\n          if (prevTransition === null && currentTransition._updatedFibers) {\n            var updatedFibersCount = currentTransition._updatedFibers.size;\n\n            if (updatedFibersCount > 10) {\n              warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n            }\n\n            currentTransition._updatedFibers.clear();\n          }\n        }\n      }\n    }\n\n    var didWarnAboutMessageChannel = false;\n    var enqueueTaskImpl = null;\n\n    function enqueueTask(task) {\n      if (enqueueTaskImpl === null) {\n        try {\n          // read require off the module object to get around the bundlers.\n          // we don't want them to detect a require and bundle a Node polyfill.\n          var requireString = ('require' + Math.random()).slice(0, 7);\n          var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's\n          // version of setImmediate, bypassing fake timers if any.\n\n          enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;\n        } catch (_err) {\n          // we're in a browser\n          // we can't use regular timers because they may still be faked\n          // so we try MessageChannel+postMessage instead\n          enqueueTaskImpl = function enqueueTaskImpl(callback) {\n            {\n              if (didWarnAboutMessageChannel === false) {\n                didWarnAboutMessageChannel = true;\n\n                if (typeof MessageChannel === 'undefined') {\n                  error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');\n                }\n              }\n            }\n            var channel = new MessageChannel();\n            channel.port1.onmessage = callback;\n            channel.port2.postMessage(undefined);\n          };\n        }\n      }\n\n      return enqueueTaskImpl(task);\n    }\n\n    var actScopeDepth = 0;\n    var didWarnNoAwaitAct = false;\n\n    function act(callback) {\n      {\n        // `act` calls can be nested, so we track the depth. This represents the\n        // number of `act` scopes on the stack.\n        var prevActScopeDepth = actScopeDepth;\n        actScopeDepth++;\n\n        if (ReactCurrentActQueue.current === null) {\n          // This is the outermost `act` scope. Initialize the queue. The reconciler\n          // will detect the queue and use it instead of Scheduler.\n          ReactCurrentActQueue.current = [];\n        }\n\n        var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n        var result;\n\n        try {\n          // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n          // set to `true` while the given callback is executed, not for updates\n          // triggered during an async event, because this is how the legacy\n          // implementation of `act` behaved.\n          ReactCurrentActQueue.isBatchingLegacy = true;\n          result = callback(); // Replicate behavior of original `act` implementation in legacy mode,\n          // which flushed updates immediately after the scope function exits, even\n          // if it's an async function.\n\n          if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n            var queue = ReactCurrentActQueue.current;\n\n            if (queue !== null) {\n              ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n              flushActQueue(queue);\n            }\n          }\n        } catch (error) {\n          popActScope(prevActScopeDepth);\n          throw error;\n        } finally {\n          ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n        }\n\n        if (result !== null && _typeof(result) === 'object' && typeof result.then === 'function') {\n          var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait\n          // for it to resolve before exiting the current scope.\n\n          var wasAwaited = false;\n          var thenable = {\n            then: function then(resolve, reject) {\n              wasAwaited = true;\n              thenableResult.then(function (returnValue) {\n                popActScope(prevActScopeDepth);\n\n                if (actScopeDepth === 0) {\n                  // We've exited the outermost act scope. Recursively flush the\n                  // queue until there's no remaining work.\n                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                } else {\n                  resolve(returnValue);\n                }\n              }, function (error) {\n                // The callback threw an error.\n                popActScope(prevActScopeDepth);\n                reject(error);\n              });\n            }\n          };\n          {\n            if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {\n              // eslint-disable-next-line no-undef\n              Promise.resolve().then(function () {}).then(function () {\n                if (!wasAwaited) {\n                  didWarnNoAwaitAct = true;\n                  error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');\n                }\n              });\n            }\n          }\n          return thenable;\n        } else {\n          var returnValue = result; // The callback is not an async function. Exit the current scope\n          // immediately, without awaiting.\n\n          popActScope(prevActScopeDepth);\n\n          if (actScopeDepth === 0) {\n            // Exiting the outermost act scope. Flush the queue.\n            var _queue = ReactCurrentActQueue.current;\n\n            if (_queue !== null) {\n              flushActQueue(_queue);\n              ReactCurrentActQueue.current = null;\n            } // Return a thenable. If the user awaits it, we'll flush again in\n            // case additional work was scheduled by a microtask.\n\n\n            var _thenable = {\n              then: function then(resolve, reject) {\n                // Confirm we haven't re-entered another `act` scope, in case\n                // the user does something weird like await the thenable\n                // multiple times.\n                if (ReactCurrentActQueue.current === null) {\n                  // Recursively flush the queue until there's no remaining work.\n                  ReactCurrentActQueue.current = [];\n                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                } else {\n                  resolve(returnValue);\n                }\n              }\n            };\n            return _thenable;\n          } else {\n            // Since we're inside a nested `act` scope, the returned thenable\n            // immediately resolves. The outer scope will flush the queue.\n            var _thenable2 = {\n              then: function then(resolve, reject) {\n                resolve(returnValue);\n              }\n            };\n            return _thenable2;\n          }\n        }\n      }\n    }\n\n    function popActScope(prevActScopeDepth) {\n      {\n        if (prevActScopeDepth !== actScopeDepth - 1) {\n          error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');\n        }\n\n        actScopeDepth = prevActScopeDepth;\n      }\n    }\n\n    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n      {\n        var queue = ReactCurrentActQueue.current;\n\n        if (queue !== null) {\n          try {\n            flushActQueue(queue);\n            enqueueTask(function () {\n              if (queue.length === 0) {\n                // No additional work was scheduled. Finish.\n                ReactCurrentActQueue.current = null;\n                resolve(returnValue);\n              } else {\n                // Keep flushing work until there's none left.\n                recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n              }\n            });\n          } catch (error) {\n            reject(error);\n          }\n        } else {\n          resolve(returnValue);\n        }\n      }\n    }\n\n    var isFlushing = false;\n\n    function flushActQueue(queue) {\n      {\n        if (!isFlushing) {\n          // Prevent re-entrance.\n          isFlushing = true;\n          var i = 0;\n\n          try {\n            for (; i < queue.length; i++) {\n              var callback = queue[i];\n\n              do {\n                callback = callback(true);\n              } while (callback !== null);\n            }\n\n            queue.length = 0;\n          } catch (error) {\n            // If something throws, leave the remaining callbacks on the queue.\n            queue = queue.slice(i + 1);\n            throw error;\n          } finally {\n            isFlushing = false;\n          }\n        }\n      }\n    }\n\n    var createElement$1 = createElementWithValidation;\n    var cloneElement$1 = cloneElementWithValidation;\n    var createFactory = createFactoryWithValidation;\n    var Children = {\n      map: mapChildren,\n      forEach: forEachChildren,\n      count: countChildren,\n      toArray: toArray,\n      only: onlyChild\n    };\n    exports.Children = Children;\n    exports.Component = Component;\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.Profiler = REACT_PROFILER_TYPE;\n    exports.PureComponent = PureComponent;\n    exports.StrictMode = REACT_STRICT_MODE_TYPE;\n    exports.Suspense = REACT_SUSPENSE_TYPE;\n    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\n    exports.cloneElement = cloneElement$1;\n    exports.createContext = createContext;\n    exports.createElement = createElement$1;\n    exports.createFactory = createFactory;\n    exports.createRef = createRef;\n    exports.forwardRef = forwardRef;\n    exports.isValidElement = isValidElement;\n    exports.lazy = lazy;\n    exports.memo = memo;\n    exports.startTransition = startTransition;\n    exports.unstable_act = act;\n    exports.useCallback = useCallback;\n    exports.useContext = useContext;\n    exports.useDebugValue = useDebugValue;\n    exports.useDeferredValue = useDeferredValue;\n    exports.useEffect = useEffect;\n    exports.useId = useId;\n    exports.useImperativeHandle = useImperativeHandle;\n    exports.useInsertionEffect = useInsertionEffect;\n    exports.useLayoutEffect = useLayoutEffect;\n    exports.useMemo = useMemo;\n    exports.useReducer = useReducer;\n    exports.useRef = useRef;\n    exports.useState = useState;\n    exports.useSyncExternalStore = useSyncExternalStore;\n    exports.useTransition = useTransition;\n    exports.version = ReactVersion;\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n    }\n  })();\n}\n\n//# sourceURL=webpack://reactappboiler/./node_modules/react/cjs/react.development.js?");

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ \"./node_modules/react/cjs/react.development.js\");\n}\n\n//# sourceURL=webpack://reactappboiler/./node_modules/react/index.js?");

/***/ }),

/***/ "./node_modules/react/jsx-runtime.js":
/*!*******************************************!*\
  !*** ./node_modules/react/jsx-runtime.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-runtime.development.js\");\n}\n\n//# sourceURL=webpack://reactappboiler/./node_modules/react/jsx-runtime.js?");

/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nif (true) {\n  (function () {\n    'use strict';\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    }\n\n    var enableSchedulerDebugging = false;\n    var enableProfiling = false;\n    var frameYieldMs = 5;\n\n    function push(heap, node) {\n      var index = heap.length;\n      heap.push(node);\n      siftUp(heap, node, index);\n    }\n\n    function peek(heap) {\n      return heap.length === 0 ? null : heap[0];\n    }\n\n    function pop(heap) {\n      if (heap.length === 0) {\n        return null;\n      }\n\n      var first = heap[0];\n      var last = heap.pop();\n\n      if (last !== first) {\n        heap[0] = last;\n        siftDown(heap, last, 0);\n      }\n\n      return first;\n    }\n\n    function siftUp(heap, node, i) {\n      var index = i;\n\n      while (index > 0) {\n        var parentIndex = index - 1 >>> 1;\n        var parent = heap[parentIndex];\n\n        if (compare(parent, node) > 0) {\n          // The parent is larger. Swap positions.\n          heap[parentIndex] = node;\n          heap[index] = parent;\n          index = parentIndex;\n        } else {\n          // The parent is smaller. Exit.\n          return;\n        }\n      }\n    }\n\n    function siftDown(heap, node, i) {\n      var index = i;\n      var length = heap.length;\n      var halfLength = length >>> 1;\n\n      while (index < halfLength) {\n        var leftIndex = (index + 1) * 2 - 1;\n        var left = heap[leftIndex];\n        var rightIndex = leftIndex + 1;\n        var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n\n        if (compare(left, node) < 0) {\n          if (rightIndex < length && compare(right, left) < 0) {\n            heap[index] = right;\n            heap[rightIndex] = node;\n            index = rightIndex;\n          } else {\n            heap[index] = left;\n            heap[leftIndex] = node;\n            index = leftIndex;\n          }\n        } else if (rightIndex < length && compare(right, node) < 0) {\n          heap[index] = right;\n          heap[rightIndex] = node;\n          index = rightIndex;\n        } else {\n          // Neither child is smaller. Exit.\n          return;\n        }\n      }\n    }\n\n    function compare(a, b) {\n      // Compare sort index first, then task id.\n      var diff = a.sortIndex - b.sortIndex;\n      return diff !== 0 ? diff : a.id - b.id;\n    } // TODO: Use symbols?\n\n\n    var ImmediatePriority = 1;\n    var UserBlockingPriority = 2;\n    var NormalPriority = 3;\n    var LowPriority = 4;\n    var IdlePriority = 5;\n\n    function markTaskErrored(task, ms) {}\n    /* eslint-disable no-var */\n\n\n    var hasPerformanceNow = (typeof performance === \"undefined\" ? \"undefined\" : _typeof(performance)) === 'object' && typeof performance.now === 'function';\n\n    if (hasPerformanceNow) {\n      var localPerformance = performance;\n\n      exports.unstable_now = function () {\n        return localPerformance.now();\n      };\n    } else {\n      var localDate = Date;\n      var initialTime = localDate.now();\n\n      exports.unstable_now = function () {\n        return localDate.now() - initialTime;\n      };\n    } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n    // Math.pow(2, 30) - 1\n    // 0b111111111111111111111111111111\n\n\n    var maxSigned31BitInt = 1073741823; // Times out immediately\n\n    var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\n    var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\n    var NORMAL_PRIORITY_TIMEOUT = 5000;\n    var LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n\n    var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n\n    var taskQueue = [];\n    var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n\n    var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\n\n    var currentTask = null;\n    var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n\n    var isPerformingWork = false;\n    var isHostCallbackScheduled = false;\n    var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n\n    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;\n    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;\n    var localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom\n\n    var isInputPending = typeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n\n    function advanceTimers(currentTime) {\n      // Check for tasks that are no longer delayed and add them to the queue.\n      var timer = peek(timerQueue);\n\n      while (timer !== null) {\n        if (timer.callback === null) {\n          // Timer was cancelled.\n          pop(timerQueue);\n        } else if (timer.startTime <= currentTime) {\n          // Timer fired. Transfer to the task queue.\n          pop(timerQueue);\n          timer.sortIndex = timer.expirationTime;\n          push(taskQueue, timer);\n        } else {\n          // Remaining timers are pending.\n          return;\n        }\n\n        timer = peek(timerQueue);\n      }\n    }\n\n    function handleTimeout(currentTime) {\n      isHostTimeoutScheduled = false;\n      advanceTimers(currentTime);\n\n      if (!isHostCallbackScheduled) {\n        if (peek(taskQueue) !== null) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        } else {\n          var firstTimer = peek(timerQueue);\n\n          if (firstTimer !== null) {\n            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n          }\n        }\n      }\n    }\n\n    function flushWork(hasTimeRemaining, initialTime) {\n      isHostCallbackScheduled = false;\n\n      if (isHostTimeoutScheduled) {\n        // We scheduled a timeout but it's no longer needed. Cancel it.\n        isHostTimeoutScheduled = false;\n        cancelHostTimeout();\n      }\n\n      isPerformingWork = true;\n      var previousPriorityLevel = currentPriorityLevel;\n\n      try {\n        if (enableProfiling) {\n          try {\n            return workLoop(hasTimeRemaining, initialTime);\n          } catch (error) {\n            if (currentTask !== null) {\n              var currentTime = exports.unstable_now();\n              markTaskErrored(currentTask, currentTime);\n              currentTask.isQueued = false;\n            }\n\n            throw error;\n          }\n        } else {\n          // No catch in prod code path.\n          return workLoop(hasTimeRemaining, initialTime);\n        }\n      } finally {\n        currentTask = null;\n        currentPriorityLevel = previousPriorityLevel;\n        isPerformingWork = false;\n      }\n    }\n\n    function workLoop(hasTimeRemaining, initialTime) {\n      var currentTime = initialTime;\n      advanceTimers(currentTime);\n      currentTask = peek(taskQueue);\n\n      while (currentTask !== null && !enableSchedulerDebugging) {\n        if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n          // This currentTask hasn't expired, and we've reached the deadline.\n          break;\n        }\n\n        var callback = currentTask.callback;\n\n        if (typeof callback === 'function') {\n          currentTask.callback = null;\n          currentPriorityLevel = currentTask.priorityLevel;\n          var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n          var continuationCallback = callback(didUserCallbackTimeout);\n          currentTime = exports.unstable_now();\n\n          if (typeof continuationCallback === 'function') {\n            currentTask.callback = continuationCallback;\n          } else {\n            if (currentTask === peek(taskQueue)) {\n              pop(taskQueue);\n            }\n          }\n\n          advanceTimers(currentTime);\n        } else {\n          pop(taskQueue);\n        }\n\n        currentTask = peek(taskQueue);\n      } // Return whether there's additional work\n\n\n      if (currentTask !== null) {\n        return true;\n      } else {\n        var firstTimer = peek(timerQueue);\n\n        if (firstTimer !== null) {\n          requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n        }\n\n        return false;\n      }\n    }\n\n    function unstable_runWithPriority(priorityLevel, eventHandler) {\n      switch (priorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n        case LowPriority:\n        case IdlePriority:\n          break;\n\n        default:\n          priorityLevel = NormalPriority;\n      }\n\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n\n    function unstable_next(eventHandler) {\n      var priorityLevel;\n\n      switch (currentPriorityLevel) {\n        case ImmediatePriority:\n        case UserBlockingPriority:\n        case NormalPriority:\n          // Shift down to normal priority\n          priorityLevel = NormalPriority;\n          break;\n\n        default:\n          // Anything lower than normal priority should remain at the current level.\n          priorityLevel = currentPriorityLevel;\n          break;\n      }\n\n      var previousPriorityLevel = currentPriorityLevel;\n      currentPriorityLevel = priorityLevel;\n\n      try {\n        return eventHandler();\n      } finally {\n        currentPriorityLevel = previousPriorityLevel;\n      }\n    }\n\n    function unstable_wrapCallback(callback) {\n      var parentPriorityLevel = currentPriorityLevel;\n      return function () {\n        // This is a fork of runWithPriority, inlined for performance.\n        var previousPriorityLevel = currentPriorityLevel;\n        currentPriorityLevel = parentPriorityLevel;\n\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          currentPriorityLevel = previousPriorityLevel;\n        }\n      };\n    }\n\n    function unstable_scheduleCallback(priorityLevel, callback, options) {\n      var currentTime = exports.unstable_now();\n      var startTime;\n\n      if (_typeof(options) === 'object' && options !== null) {\n        var delay = options.delay;\n\n        if (typeof delay === 'number' && delay > 0) {\n          startTime = currentTime + delay;\n        } else {\n          startTime = currentTime;\n        }\n      } else {\n        startTime = currentTime;\n      }\n\n      var timeout;\n\n      switch (priorityLevel) {\n        case ImmediatePriority:\n          timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n          break;\n\n        case UserBlockingPriority:\n          timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n          break;\n\n        case IdlePriority:\n          timeout = IDLE_PRIORITY_TIMEOUT;\n          break;\n\n        case LowPriority:\n          timeout = LOW_PRIORITY_TIMEOUT;\n          break;\n\n        case NormalPriority:\n        default:\n          timeout = NORMAL_PRIORITY_TIMEOUT;\n          break;\n      }\n\n      var expirationTime = startTime + timeout;\n      var newTask = {\n        id: taskIdCounter++,\n        callback: callback,\n        priorityLevel: priorityLevel,\n        startTime: startTime,\n        expirationTime: expirationTime,\n        sortIndex: -1\n      };\n\n      if (startTime > currentTime) {\n        // This is a delayed task.\n        newTask.sortIndex = startTime;\n        push(timerQueue, newTask);\n\n        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n          // All tasks are delayed, and this is the task with the earliest delay.\n          if (isHostTimeoutScheduled) {\n            // Cancel an existing timeout.\n            cancelHostTimeout();\n          } else {\n            isHostTimeoutScheduled = true;\n          } // Schedule a timeout.\n\n\n          requestHostTimeout(handleTimeout, startTime - currentTime);\n        }\n      } else {\n        newTask.sortIndex = expirationTime;\n        push(taskQueue, newTask); // wait until the next time we yield.\n\n        if (!isHostCallbackScheduled && !isPerformingWork) {\n          isHostCallbackScheduled = true;\n          requestHostCallback(flushWork);\n        }\n      }\n\n      return newTask;\n    }\n\n    function unstable_pauseExecution() {}\n\n    function unstable_continueExecution() {\n      if (!isHostCallbackScheduled && !isPerformingWork) {\n        isHostCallbackScheduled = true;\n        requestHostCallback(flushWork);\n      }\n    }\n\n    function unstable_getFirstCallbackNode() {\n      return peek(taskQueue);\n    }\n\n    function unstable_cancelCallback(task) {\n      // remove from the queue because you can't remove arbitrary nodes from an\n      // array based heap, only the first one.)\n      task.callback = null;\n    }\n\n    function unstable_getCurrentPriorityLevel() {\n      return currentPriorityLevel;\n    }\n\n    var isMessageLoopRunning = false;\n    var scheduledHostCallback = null;\n    var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n    // thread, like user events. By default, it yields multiple times per frame.\n    // It does not attempt to align with frame boundaries, since most tasks don't\n    // need to be frame aligned; for those that do, use requestAnimationFrame.\n\n    var frameInterval = frameYieldMs;\n    var startTime = -1;\n\n    function shouldYieldToHost() {\n      var timeElapsed = exports.unstable_now() - startTime;\n\n      if (timeElapsed < frameInterval) {\n        // The main thread has only been blocked for a really short amount of time;\n        // smaller than a single frame. Don't yield yet.\n        return false;\n      } // The main thread has been blocked for a non-negligible amount of time. We\n\n\n      return true;\n    }\n\n    function requestPaint() {}\n\n    function forceFrameRate(fps) {\n      if (fps < 0 || fps > 125) {\n        // Using console['error'] to evade Babel and ESLint\n        console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');\n        return;\n      }\n\n      if (fps > 0) {\n        frameInterval = Math.floor(1000 / fps);\n      } else {\n        // reset the framerate\n        frameInterval = frameYieldMs;\n      }\n    }\n\n    var performWorkUntilDeadline = function performWorkUntilDeadline() {\n      if (scheduledHostCallback !== null) {\n        var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n        // has been blocked.\n\n        startTime = currentTime;\n        var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the\n        // error can be observed.\n        //\n        // Intentionally not using a try-catch, since that makes some debugging\n        // techniques harder. Instead, if `scheduledHostCallback` errors, then\n        // `hasMoreWork` will remain true, and we'll continue the work loop.\n\n        var hasMoreWork = true;\n\n        try {\n          hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n        } finally {\n          if (hasMoreWork) {\n            // If there's more work, schedule the next message event at the end\n            // of the preceding one.\n            schedulePerformWorkUntilDeadline();\n          } else {\n            isMessageLoopRunning = false;\n            scheduledHostCallback = null;\n          }\n        }\n      } else {\n        isMessageLoopRunning = false;\n      } // Yielding to the browser will give it a chance to paint, so we can\n\n    };\n\n    var schedulePerformWorkUntilDeadline;\n\n    if (typeof localSetImmediate === 'function') {\n      // Node.js and old IE.\n      // There's a few reasons for why we prefer setImmediate.\n      //\n      // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n      // (Even though this is a DOM fork of the Scheduler, you could get here\n      // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n      // https://github.com/facebook/react/issues/20756\n      //\n      // But also, it runs earlier which is the semantic we want.\n      // If other browsers ever implement it, it's better to use it.\n      // Although both of these would be inferior to native scheduling.\n      schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {\n        localSetImmediate(performWorkUntilDeadline);\n      };\n    } else if (typeof MessageChannel !== 'undefined') {\n      // DOM and Worker environments.\n      // We prefer MessageChannel because of the 4ms setTimeout clamping.\n      var channel = new MessageChannel();\n      var port = channel.port2;\n      channel.port1.onmessage = performWorkUntilDeadline;\n\n      schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {\n        port.postMessage(null);\n      };\n    } else {\n      // We should only fallback here in non-browser environments.\n      schedulePerformWorkUntilDeadline = function schedulePerformWorkUntilDeadline() {\n        localSetTimeout(performWorkUntilDeadline, 0);\n      };\n    }\n\n    function requestHostCallback(callback) {\n      scheduledHostCallback = callback;\n\n      if (!isMessageLoopRunning) {\n        isMessageLoopRunning = true;\n        schedulePerformWorkUntilDeadline();\n      }\n    }\n\n    function requestHostTimeout(callback, ms) {\n      taskTimeoutID = localSetTimeout(function () {\n        callback(exports.unstable_now());\n      }, ms);\n    }\n\n    function cancelHostTimeout() {\n      localClearTimeout(taskTimeoutID);\n      taskTimeoutID = -1;\n    }\n\n    var unstable_requestPaint = requestPaint;\n    var unstable_Profiling = null;\n    exports.unstable_IdlePriority = IdlePriority;\n    exports.unstable_ImmediatePriority = ImmediatePriority;\n    exports.unstable_LowPriority = LowPriority;\n    exports.unstable_NormalPriority = NormalPriority;\n    exports.unstable_Profiling = unstable_Profiling;\n    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n    exports.unstable_cancelCallback = unstable_cancelCallback;\n    exports.unstable_continueExecution = unstable_continueExecution;\n    exports.unstable_forceFrameRate = forceFrameRate;\n    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n    exports.unstable_next = unstable_next;\n    exports.unstable_pauseExecution = unstable_pauseExecution;\n    exports.unstable_requestPaint = unstable_requestPaint;\n    exports.unstable_runWithPriority = unstable_runWithPriority;\n    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n    exports.unstable_shouldYield = shouldYieldToHost;\n    exports.unstable_wrapCallback = unstable_wrapCallback;\n    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\n    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n    }\n  })();\n}\n\n//# sourceURL=webpack://reactappboiler/./node_modules/scheduler/cjs/scheduler.development.js?");

/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"./node_modules/scheduler/cjs/scheduler.development.js\");\n}\n\n//# sourceURL=webpack://reactappboiler/./node_modules/scheduler/index.js?");

/***/ }),

/***/ "./src/Components/HeroSection/HeroSection.js":
/*!***************************************************!*\
  !*** ./src/Components/HeroSection/HeroSection.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Example)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Images_independent_logo_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Images/independent-logo.png */ \"./src/Images/independent-logo.png\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/* This example requires Tailwind CSS v2.0+ */\n\n\n\n\n\n\nvar navigation = [{\n  name: 'Product',\n  href: '#'\n}, {\n  name: 'Features',\n  href: '#'\n}, {\n  name: 'Marketplace',\n  href: '#'\n}, {\n  name: 'Company',\n  href: '#'\n}];\nfunction Example() {\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", {\n    className: \"relative bg-white overflow-hidden\",\n    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n      className: \"max-w-7xl mx-auto\",\n      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", {\n        className: \"relative z-10 pb-8 bg-white sm:pb-16 md:pb-20 lg:max-w-2xl lg:w-full lg:pb-28 xl:pb-32\",\n        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"svg\", {\n          className: \"hidden lg:block absolute right-0 inset-y-0 h-full w-48 text-white transform translate-x-1/2\",\n          fill: \"currentColor\",\n          viewBox: \"0 0 100 100\",\n          preserveAspectRatio: \"none\",\n          \"aria-hidden\": \"true\",\n          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"polygon\", {\n            points: \"50,0 100,0 50,100 0,100\"\n          })\n        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n          className: \"relative pt-6 px-4 sm:px-6 lg:px-8\",\n          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"nav\", {\n            className: \"relative flex items-center justify-between\",\n            \"aria-label\": \"Global\",\n            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n              className: \"flex items-center flex-grow flex-shrink-0 lg:flex-grow-0\",\n              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n                className: \"flex items-center justify-between w-full md:w-auto\",\n                children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"a\", {\n                  href: \"#\",\n                  children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"img\", {\n                    className: \"h-24 p-[1px] w-auto sm:h-28 lg:h-32 bg-black rounded-full\",\n                    src: _Images_independent_logo_png__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n                    alt: \"Independent MMA & Fitness Logo\"\n                  })\n                })\n              })\n            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n              className: \"shadow-lg shadow-indigo-400 bg-indigo-800 rounded-md p-2\",\n              children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"a\", {\n                href: \"#\",\n                className: \"font-medium text-white hover:text-indigo-500\",\n                children: \"Sign Up\"\n              })\n            })]\n          })\n        }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"main\", {\n          className: \"mt-10 mx-auto max-w-7xl px-4 sm:mt-12 sm:px-6 md:mt-16 lg:mt-20 lg:px-8 xl:mt-28\",\n          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", {\n            className: \"sm:text-center lg:text-left\",\n            children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"h1\", {\n              className: \"text-4xl tracking-tight font-extrabold text-gray-900 sm:text-5xl md:text-6xl\",\n              children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", {\n                className: \"block xl:inline\",\n                children: \"Data to enrich your\"\n              }), ' ', /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"span\", {\n                className: \"block text-indigo-600 xl:inline\",\n                children: \"online business\"\n              })]\n            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"p\", {\n              className: \"mt-3 text-base text-gray-500 sm:mt-5 sm:text-lg sm:max-w-xl sm:mx-auto md:mt-5 md:text-xl lg:mx-0\",\n              children: \"Anim aute id magna aliqua ad ad non deserunt sunt. Qui irure qui lorem cupidatat commodo. Elit sunt amet fugiat veniam occaecat fugiat aliqua.\"\n            }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", {\n              className: \"mt-5 sm:mt-8 sm:flex sm:justify-center lg:justify-start\",\n              children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n                className: \"rounded-md shadow\",\n                children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"a\", {\n                  href: \"#\",\n                  className: \"w-full flex items-center justify-center px-8 py-3 border border-transparent text-base font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 md:py-4 md:text-lg md:px-10\",\n                  children: \"Get started\"\n                })\n              }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n                className: \"mt-3 sm:mt-0 sm:ml-3\",\n                children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"a\", {\n                  href: \"#\",\n                  className: \"w-full flex items-center justify-center px-8 py-3 border border-transparent text-base font-medium rounded-md text-indigo-700 bg-indigo-100 hover:bg-indigo-200 md:py-4 md:text-lg md:px-10\",\n                  children: \"Live demo\"\n                })\n              })]\n            })]\n          })\n        })]\n      })\n    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", {\n      className: \"lg:absolute lg:inset-y-0 lg:right-0 lg:w-1/2\",\n      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"img\", {\n        className: \"h-56 w-full object-cover sm:h-72 md:h-96 lg:w-full lg:h-full\",\n        src: \"https://images.unsplash.com/photo-1551434678-e076c223a692?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2850&q=80\",\n        alt: \"\"\n      })\n    })]\n  });\n}\n\n//# sourceURL=webpack://reactappboiler/./src/Components/HeroSection/HeroSection.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom/client */ \"./node_modules/react-dom/client.js\");\n/* harmony import */ var _Components_HeroSection_HeroSection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Components/HeroSection/HeroSection */ \"./src/Components/HeroSection/HeroSection.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n\n\n\n\n\nvar App = function App() {\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(_Components_HeroSection_HeroSection__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {});\n};\n\nvar container = document.getElementById(\"root\");\nvar root = react_dom_client__WEBPACK_IMPORTED_MODULE_1__.createRoot(container);\nroot.render( /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_3__.jsx)(App, {}));\n\n//# sourceURL=webpack://reactappboiler/./src/index.js?");

/***/ }),

/***/ "./src/Images/independent-logo.png":
/*!*****************************************!*\
  !*** ./src/Images/independent-logo.png ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"data:image/png;base64,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IFdpbmRvd3M8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhtcDpDcmVhdGVEYXRlPjIwMTQtMTEtMTFUMTQ6Mzc6MzdaPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMTQtMTEtMTFUMTQ6Mzk6NTVaPC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgICAgIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiCiAgICAgICAgICAgIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyI+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAo8P3hwYWNrZXQgZW5kPSJ3Ij8+8slqJAAAIABJREFUeJzsnXmcHVWZ93/POaeq7la9d7rTSWffSCCENSQsIoggooCguIGM4oLb6+so7zjvDKOv48zIOKPj6OjgOqIzroiCQGRfwxqSQCD7nk4v6e3WXavqnOf9o24noXO70yFLdyf3++F+EnLvrXqqbtV56lnO7xAzo0KFE4GeFSuE0bo6yGab3OnTJ8Samtwwm60Ks9mZKh6f4tTW2hAi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\");\n\n//# sourceURL=webpack://reactappboiler/./src/Images/independent-logo.png?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;